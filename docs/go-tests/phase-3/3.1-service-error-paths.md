# Phase 3.1: Add Service Error Path Tests

**Objective**: Improve service layer coverage by adding comprehensive error scenario testing

**Current State**: Many services have 40-60% coverage
**Target State**: All services reach 70-80% coverage

## Overview

While most services have good happy-path coverage, error scenarios and edge cases are often missing. This phase focuses on testing:
- Database connection failures
- Validation errors (unique constraints, foreign keys)
- Not found errors
- Permission/authorization errors
- Concurrent modification conflicts
- Transaction rollback scenarios
- Pagination edge cases
- Search with special characters
- Null/empty input handling

## Services Requiring Improvement

| Package | Current Coverage | Target Coverage |
|---------|-----------------|-----------------|
| activity | 40.2% | 75% |
| movement | 43.9% | 70% |
| loan | 46.5% | 75% |
| company | 47.3% | 70% |
| user | 33.9% | 70% |
| notification | 37.9% | 70% |
| workspace | 42.2% | 70% |
| member | 48.5% | 70% |

## Test Pattern for Error Scenarios

### 1. Validation Error Tests

```go
func TestItemService_Create_ValidationErrors(t *testing.T) {
    t.Run("returns error for duplicate SKU", func(t *testing.T) {
        mockRepo := new(MockItemRepository)
        mockRepo.On("Save", mock.Anything, mock.Anything).
            Return(postgres.ErrUniqueViolation)

        svc := item.NewService(mockRepo)
        _, err := svc.Create(ctx, workspaceID, item.CreateInput{
            Name: "Laptop",
            SKU:  "DUPLICATE-SKU",
        })

        assert.Error(t, err)
        assert.Equal(t, item.ErrDuplicateSKU, err)
        mockRepo.AssertExpectations(t)
    })

    t.Run("returns error for invalid workspace", func(t *testing.T) {
        mockRepo := new(MockItemRepository)
        mockRepo.On("Save", mock.Anything, mock.Anything).
            Return(postgres.ErrForeignKeyViolation)

        svc := item.NewService(mockRepo)
        _, err := svc.Create(ctx, uuid.Nil, item.CreateInput{
            Name: "Laptop",
        })

        assert.Error(t, err)
        mockRepo.AssertExpectations(t)
    })

    t.Run("returns error for invalid category reference", func(t *testing.T) {
        mockRepo := new(MockItemRepository)
        categoryID := uuid.New()

        mockRepo.On("Save", mock.Anything, mock.MatchedBy(func(i *item.Item) bool {
            return i.CategoryID != nil && *i.CategoryID == categoryID
        })).Return(postgres.ErrForeignKeyViolation)

        svc := item.NewService(mockRepo)
        _, err := svc.Create(ctx, workspaceID, item.CreateInput{
            Name:       "Laptop",
            CategoryID: &categoryID,
        })

        assert.Error(t, err)
    })
}
```

### 2. Not Found Error Tests

```go
func TestItemService_Update_NotFoundErrors(t *testing.T) {
    t.Run("returns ErrNotFound when item doesn't exist", func(t *testing.T) {
        mockRepo := new(MockItemRepository)
        itemID := uuid.New()

        mockRepo.On("GetByID", mock.Anything, itemID, workspaceID).
            Return(nil, item.ErrNotFound)

        svc := item.NewService(mockRepo)
        _, err := svc.Update(ctx, itemID, workspaceID, item.UpdateInput{
            Name: strPtr("Updated"),
        })

        assert.Equal(t, item.ErrNotFound, err)
        mockRepo.AssertExpectations(t)
    })

    t.Run("returns ErrNotFound when item in different workspace", func(t *testing.T) {
        mockRepo := new(MockItemRepository)
        itemID := uuid.New()
        differentWorkspace := uuid.New()

        mockRepo.On("GetByID", mock.Anything, itemID, differentWorkspace).
            Return(nil, item.ErrNotFound)

        svc := item.NewService(mockRepo)
        _, err := svc.Update(ctx, itemID, differentWorkspace, item.UpdateInput{
            Name: strPtr("Updated"),
        })

        assert.Equal(t, item.ErrNotFound, err)
    })
}
```

### 3. Pagination Edge Case Tests

```go
func TestItemService_List_PaginationEdgeCases(t *testing.T) {
    t.Run("handles offset beyond count", func(t *testing.T) {
        mockRepo := new(MockItemRepository)

        mockRepo.On("List", mock.Anything, workspaceID, 1000, 10).
            Return([]*item.Item{}, nil)
        mockRepo.On("Count", mock.Anything, workspaceID).
            Return(50, nil)

        svc := item.NewService(mockRepo)
        items, total, err := svc.List(ctx, workspaceID, 1000, 10)

        assert.NoError(t, err)
        assert.Empty(t, items)
        assert.Equal(t, 50, total)
        mockRepo.AssertExpectations(t)
    })

    t.Run("handles negative offset", func(t *testing.T) {
        mockRepo := new(MockItemRepository)

        svc := item.NewService(mockRepo)
        _, _, err := svc.List(ctx, workspaceID, -1, 10)

        assert.Error(t, err)
        assert.Contains(t, err.Error(), "offset")
    })

    t.Run("handles negative limit", func(t *testing.T) {
        mockRepo := new(MockItemRepository)

        svc := item.NewService(mockRepo)
        _, _, err := svc.List(ctx, workspaceID, 0, -1)

        assert.Error(t, err)
        assert.Contains(t, err.Error(), "limit")
    })

    t.Run("handles limit exceeding maximum", func(t *testing.T) {
        mockRepo := new(MockItemRepository)

        // If there's a max limit (e.g., 1000), test it
        mockRepo.On("List", mock.Anything, workspaceID, 0, 1000).
            Return([]*item.Item{}, nil)
        mockRepo.On("Count", mock.Anything, workspaceID).
            Return(0, nil)

        svc := item.NewService(mockRepo)
        _, _, err := svc.List(ctx, workspaceID, 0, 10000) // Requesting more than max

        // Service should cap it at max
        assert.NoError(t, err)
        mockRepo.AssertExpectations(t)
    })
}
```

### 4. Search Edge Case Tests

```go
func TestItemService_Search_EdgeCases(t *testing.T) {
    t.Run("handles empty search query", func(t *testing.T) {
        mockRepo := new(MockItemRepository)

        svc := item.NewService(mockRepo)
        _, _, err := svc.Search(ctx, workspaceID, "", 0, 10)

        assert.Error(t, err)
        assert.Contains(t, err.Error(), "query")
    })

    t.Run("handles special characters in search", func(t *testing.T) {
        mockRepo := new(MockItemRepository)

        mockRepo.On("Search", mock.Anything, workspaceID, "%test_", 0, 10).
            Return([]*item.Item{}, nil)
        mockRepo.On("CountSearch", mock.Anything, workspaceID, "%test_").
            Return(0, nil)

        svc := item.NewService(mockRepo)
        items, total, err := svc.Search(ctx, workspaceID, "%test_", 0, 10)

        assert.NoError(t, err)
        assert.Empty(t, items)
        assert.Equal(t, 0, total)
    })

    t.Run("handles very long search query", func(t *testing.T) {
        mockRepo := new(MockItemRepository)
        longQuery := strings.Repeat("a", 1000)

        svc := item.NewService(mockRepo)
        _, _, err := svc.Search(ctx, workspaceID, longQuery, 0, 10)

        assert.Error(t, err)
        assert.Contains(t, err.Error(), "query too long")
    })
}
```

### 5. Transaction and Concurrency Tests

```go
func TestItemService_Delete_TransactionScenarios(t *testing.T) {
    t.Run("rolls back transaction on error", func(t *testing.T) {
        mockRepo := new(MockItemRepository)
        itemID := uuid.New()

        // First get succeeds
        testItem := &item.Item{ID: itemID, WorkspaceID: workspaceID}
        mockRepo.On("GetByID", mock.Anything, itemID, workspaceID).
            Return(testItem, nil)

        // But delete fails (e.g., foreign key constraint)
        mockRepo.On("Delete", mock.Anything, itemID).
            Return(postgres.ErrForeignKeyViolation)

        svc := item.NewService(mockRepo)
        err := svc.Delete(ctx, itemID, workspaceID)

        assert.Error(t, err)
        assert.Contains(t, err.Error(), "cannot delete")
        mockRepo.AssertExpectations(t)
    })

    t.Run("handles concurrent modification", func(t *testing.T) {
        mockRepo := new(MockItemRepository)
        itemID := uuid.New()

        testItem := &item.Item{
            ID:          itemID,
            WorkspaceID: workspaceID,
            Version:     1, // Assuming optimistic locking
        }

        mockRepo.On("GetByID", mock.Anything, itemID, workspaceID).
            Return(testItem, nil)

        // Update fails due to version mismatch
        mockRepo.On("Update", mock.Anything, mock.Anything).
            Return(item.ErrConcurrentModification)

        svc := item.NewService(mockRepo)
        _, err := svc.Update(ctx, itemID, workspaceID, item.UpdateInput{
            Name: strPtr("Updated"),
        })

        assert.Equal(t, item.ErrConcurrentModification, err)
    })
}
```

### 6. Database Connection Error Tests

```go
func TestItemService_DatabaseErrors(t *testing.T) {
    t.Run("handles database connection timeout", func(t *testing.T) {
        mockRepo := new(MockItemRepository)

        mockRepo.On("List", mock.Anything, workspaceID, 0, 10).
            Return(nil, context.DeadlineExceeded)

        svc := item.NewService(mockRepo)
        _, _, err := svc.List(ctx, workspaceID, 0, 10)

        assert.Error(t, err)
        assert.Contains(t, err.Error(), "timeout")
    })

    t.Run("handles database unavailable", func(t *testing.T) {
        mockRepo := new(MockItemRepository)

        mockRepo.On("GetByID", mock.Anything, mock.Anything, workspaceID).
            Return(nil, errors.New("connection refused"))

        svc := item.NewService(mockRepo)
        _, err := svc.GetByID(ctx, uuid.New(), workspaceID)

        assert.Error(t, err)
    })
}
```

## Domain-Specific Error Scenarios

### Loan Service
- Loan already returned
- Loan overdue restrictions
- Inventory not available for loan
- Borrower has too many active loans
- Due date in the past

### Inventory Service
- Invalid condition transition (e.g., NEW â†’ DAMAGED)
- Invalid status transition
- Negative quantities
- Moving inventory to non-existent location
- Container capacity exceeded

### Workspace Service
- Duplicate slug
- Cannot delete workspace with active items
- Last owner cannot be removed

### Member Service
- User already member of workspace
- Cannot change role of last owner
- Invalid role transition

## Files to Extend

Extend existing `*_service_test.go` files:
- `internal/domain/warehouse/activity/service_test.go`
- `internal/domain/warehouse/movement/service_test.go`
- `internal/domain/warehouse/loan/service_test.go`
- `internal/domain/warehouse/company/service_test.go`
- `internal/domain/auth/user/service_test.go`
- `internal/domain/auth/notification/service_test.go`
- `internal/domain/auth/workspace/service_test.go`
- `internal/domain/auth/member/service_test.go`

## Estimated Effort

- **Time**: 25-30 hours
- **Tests to add**: 150-200

## Success Criteria

- [ ] All validation error scenarios are tested
- [ ] Not found errors are covered for all operations
- [ ] Pagination edge cases (negative, zero, beyond max) are tested
- [ ] Search edge cases (empty, special chars) are tested
- [ ] Database errors and timeouts are handled
- [ ] Transaction rollbacks are tested
- [ ] Concurrent modification scenarios are covered
- [ ] Service coverage reaches 70-80%

## Running Tests

```bash
# Test specific service with error scenarios
go test ./internal/domain/warehouse/loan -run TestLoanService -v -cover

# Test all services
go test ./internal/domain/... -cover

# Check coverage improvement
go test ./internal/domain/auth/user -coverprofile=coverage.out
go tool cover -func=coverage.out
```

## Next Steps

After completing service error path tests, proceed to [Phase 4: Integration Test Expansion](../phase-4/).
