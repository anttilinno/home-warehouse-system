# Phase 5.3: Add Batch Operation Tests

**Objective**: Complete batch package testing with comprehensive service tests

**Package**: `internal/domain/batch`

## Overview

The batch service allows multiple operations to be executed in a single request. Test all supported entity types and operations with mocked service dependencies.

## Batch Service Tests

```go
package batch_test

import (
    "context"
    "encoding/json"
    "testing"

    "github.com/google/uuid"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"

    "github.com/antti/home-warehouse/go-backend/internal/domain/batch"
    "github.com/antti/home-warehouse/go-backend/internal/domain/warehouse/item"
)

func TestBatchService_ItemOperations(t *testing.T) {
    mockItemSvc := new(MockItemService)
    mockLocationSvc := new(MockLocationService)
    svc := batch.NewService(mockItemSvc, mockLocationSvc, nil, nil, nil, nil, nil)

    workspaceID := uuid.New()
    ctx := context.Background()

    t.Run("creates multiple items in batch", func(t *testing.T) {
        testItem1 := &item.Item{ID: uuid.New(), Name: "Item 1"}
        testItem2 := &item.Item{ID: uuid.New(), Name: "Item 2"}

        mockItemSvc.On("Create", mock.Anything, workspaceID, mock.Anything).
            Return(testItem1, nil).Once()
        mockItemSvc.On("Create", mock.Anything, workspaceID, mock.Anything).
            Return(testItem2, nil).Once()

        req := batch.BatchRequest{
            Operations: []batch.Operation{
                {
                    Operation:  batch.OperationCreate,
                    EntityType: batch.EntityItem,
                    Data:       json.RawMessage(`{"name":"Item 1"}`),
                },
                {
                    Operation:  batch.OperationCreate,
                    EntityType: batch.EntityItem,
                    Data:       json.RawMessage(`{"name":"Item 2"}`),
                },
            },
        }

        resp, err := svc.ProcessBatch(ctx, workspaceID, req)

        assert.NoError(t, err)
        assert.Equal(t, 2, resp.Succeeded)
        assert.Equal(t, 0, resp.Failed)
        assert.Len(t, resp.Results, 2)
        mockItemSvc.AssertExpectations(t)
    })

    t.Run("updates item in batch", func(t *testing.T) {
        itemID := uuid.New()
        updatedItem := &item.Item{ID: itemID, Name: "Updated"}

        mockItemSvc.On("GetByID", mock.Anything, itemID, workspaceID).
            Return(&item.Item{ID: itemID}, nil)
        mockItemSvc.On("Update", mock.Anything, itemID, workspaceID, mock.Anything).
            Return(updatedItem, nil)

        req := batch.BatchRequest{
            Operations: []batch.Operation{
                {
                    Operation:  batch.OperationUpdate,
                    EntityType: batch.EntityItem,
                    EntityID:   &itemID,
                    Data:       json.RawMessage(`{"name":"Updated"}`),
                },
            },
        }

        resp, err := svc.ProcessBatch(ctx, workspaceID, req)

        assert.NoError(t, err)
        assert.Equal(t, 1, resp.Succeeded)
        mockItemSvc.AssertExpectations(t)
    })

    t.Run("deletes item in batch", func(t *testing.T) {
        itemID := uuid.New()

        mockItemSvc.On("Delete", mock.Anything, itemID, workspaceID).
            Return(nil)

        req := batch.BatchRequest{
            Operations: []batch.Operation{
                {
                    Operation:  batch.OperationDelete,
                    EntityType: batch.EntityItem,
                    EntityID:   &itemID,
                },
            },
        }

        resp, err := svc.ProcessBatch(ctx, workspaceID, req)

        assert.NoError(t, err)
        assert.Equal(t, 1, resp.Succeeded)
    })

    t.Run("handles partial batch failures", func(t *testing.T) {
        itemID := uuid.New()

        // First operation succeeds
        mockItemSvc.On("Create", mock.Anything, workspaceID, mock.Anything).
            Return(&item.Item{ID: uuid.New()}, nil).Once()

        // Second operation fails
        mockItemSvc.On("Delete", mock.Anything, itemID, workspaceID).
            Return(item.ErrNotFound)

        req := batch.BatchRequest{
            Operations: []batch.Operation{
                {
                    Operation:  batch.OperationCreate,
                    EntityType: batch.EntityItem,
                    Data:       json.RawMessage(`{"name":"Item"}`),
                },
                {
                    Operation:  batch.OperationDelete,
                    EntityType: batch.EntityItem,
                    EntityID:   &itemID,
                },
            },
        }

        resp, err := svc.ProcessBatch(ctx, workspaceID, req)

        assert.NoError(t, err) // Batch itself doesn't error
        assert.Equal(t, 1, resp.Succeeded)
        assert.Equal(t, 1, resp.Failed)
        assert.Len(t, resp.Results, 2)
        assert.True(t, resp.Results[0].Success)
        assert.False(t, resp.Results[1].Success)
        assert.NotEmpty(t, resp.Results[1].Error)
    })
}

func TestBatchService_MultipleEntityTypes(t *testing.T) {
    mockItemSvc := new(MockItemService)
    mockLocationSvc := new(MockLocationService)
    svc := batch.NewService(mockItemSvc, mockLocationSvc, nil, nil, nil, nil, nil)

    workspaceID := uuid.New()
    ctx := context.Background()

    t.Run("processes different entity types in same batch", func(t *testing.T) {
        testItem := &item.Item{ID: uuid.New()}
        testLocation := &location.Location{ID: uuid.New()}

        mockItemSvc.On("Create", mock.Anything, workspaceID, mock.Anything).
            Return(testItem, nil)
        mockLocationSvc.On("Create", mock.Anything, workspaceID, mock.Anything).
            Return(testLocation, nil)

        req := batch.BatchRequest{
            Operations: []batch.Operation{
                {
                    Operation:  batch.OperationCreate,
                    EntityType: batch.EntityItem,
                    Data:       json.RawMessage(`{"name":"Item"}`),
                },
                {
                    Operation:  batch.OperationCreate,
                    EntityType: batch.EntityLocation,
                    Data:       json.RawMessage(`{"name":"Location"}`),
                },
            },
        }

        resp, err := svc.ProcessBatch(ctx, workspaceID, req)

        assert.NoError(t, err)
        assert.Equal(t, 2, resp.Succeeded)
        mockItemSvc.AssertExpectations(t)
        mockLocationSvc.AssertExpectations(t)
    })
}

func TestBatchService_ValidationErrors(t *testing.T) {
    svc := batch.NewService(nil, nil, nil, nil, nil, nil, nil)
    workspaceID := uuid.New()
    ctx := context.Background()

    t.Run("returns error for invalid operation", func(t *testing.T) {
        req := batch.BatchRequest{
            Operations: []batch.Operation{
                {
                    Operation:  "invalid",
                    EntityType: batch.EntityItem,
                },
            },
        }

        _, err := svc.ProcessBatch(ctx, workspaceID, req)
        assert.Error(t, err)
    })

    t.Run("returns error for invalid entity type", func(t *testing.T) {
        req := batch.BatchRequest{
            Operations: []batch.Operation{
                {
                    Operation:  batch.OperationCreate,
                    EntityType: "invalid",
                },
            },
        }

        _, err := svc.ProcessBatch(ctx, workspaceID, req)
        assert.Error(t, err)
    })

    t.Run("returns error for update without entity ID", func(t *testing.T) {
        req := batch.BatchRequest{
            Operations: []batch.Operation{
                {
                    Operation:  batch.OperationUpdate,
                    EntityType: batch.EntityItem,
                    Data:       json.RawMessage(`{"name":"Updated"}`),
                },
            },
        }

        _, err := svc.ProcessBatch(ctx, workspaceID, req)
        assert.Error(t, err)
    })

    t.Run("returns error for empty batch", func(t *testing.T) {
        req := batch.BatchRequest{
            Operations: []batch.Operation{},
        }

        _, err := svc.ProcessBatch(ctx, workspaceID, req)
        assert.Error(t, err)
    })

    t.Run("returns error for batch exceeding size limit", func(t *testing.T) {
        operations := make([]batch.Operation, 1001) // Assuming max is 1000
        for i := range operations {
            operations[i] = batch.Operation{
                Operation:  batch.OperationCreate,
                EntityType: batch.EntityItem,
                Data:       json.RawMessage(`{"name":"Item"}`),
            }
        }

        req := batch.BatchRequest{Operations: operations}

        _, err := svc.ProcessBatch(ctx, workspaceID, req)
        assert.Error(t, err)
    })
}
```

## Files to Create/Extend

- `internal/domain/batch/service_test.go` (extend)

## Estimated Effort

- **Time**: 5-6 hours
- **Tests to add**: 25-30

## Success Criteria

- [ ] All batch operations (create, update, delete) are tested
- [ ] Multiple entity types can be processed in one batch
- [ ] Partial failures are handled correctly
- [ ] Validation errors are caught
- [ ] Batch size limits are enforced
- [ ] Coverage for `internal/domain/batch` reaches 75%+

## Running Tests

```bash
go test ./internal/domain/batch -v -cover
```

## Next Steps

After completing batch tests, proceed to [5.4 Test Coverage Analysis & Gap Filling](5.4-coverage-gap-filling.md).
