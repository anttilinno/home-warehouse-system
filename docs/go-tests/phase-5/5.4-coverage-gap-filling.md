# Phase 5.4: Test Coverage Analysis & Gap Filling

**Objective**: Identify and fill remaining coverage gaps to reach 95% overall coverage

## Overview

After completing Phases 1-4 and tasks 5.1-5.3, conduct a thorough coverage analysis to identify any remaining untested code paths and create targeted tests to fill those gaps.

## Coverage Analysis Process

### Step 1: Generate Coverage Report

```bash
# Run all tests with coverage
go test ./... -coverprofile=coverage.out -covermode=atomic

# Generate function-level coverage report
go tool cover -func=coverage.out > coverage-functions.txt

# Generate HTML coverage report
go tool cover -html=coverage.out -o coverage.html

# Get overall coverage percentage
go tool cover -func=coverage.out | grep total | awk '{print $3}'
```

### Step 2: Identify Low-Coverage Packages

```bash
# Find packages with <95% coverage
go tool cover -func=coverage.out | grep -v "100.0%" | sort -k3 -n | head -20
```

### Step 3: Review HTML Coverage Report

Open `coverage.html` in a browser and manually review red (uncovered) sections:

```bash
open coverage.html  # macOS
xdg-open coverage.html  # Linux
```

Focus on:
- Error handling branches
- Edge case validations
- Initialization code
- Cleanup/defer blocks
- Rarely executed paths

## Common Gap Categories

### 1. Error Handling Branches

Look for uncovered error returns:

```go
// Example of commonly missed error branch
func ProcessData(data []byte) error {
    if len(data) == 0 {
        return ErrEmptyData  // â† Often uncovered
    }
    // ... rest of function
}
```

Add test:
```go
func TestProcessData_EmptyData(t *testing.T) {
    err := ProcessData([]byte{})
    assert.Equal(t, ErrEmptyData, err)
}
```

### 2. Context Cancellation

Test context cancellation scenarios:

```go
func TestService_WithCancelledContext(t *testing.T) {
    ctx, cancel := context.WithCancel(context.Background())
    cancel() // Cancel immediately

    _, err := svc.LongRunningOperation(ctx)
    assert.Equal(t, context.Canceled, err)
}
```

### 3. Nil Pointer Checks

```go
func TestFunction_WithNilInput(t *testing.T) {
    result := ProcessOptionalData(nil)
    assert.NotNil(t, result) // Or whatever the expected behavior is
}
```

### 4. Init Functions and Constructors

```go
func TestNewService_WithNilDependency(t *testing.T) {
    svc := NewService(nil)
    // Test default behavior or panic recovery
}
```

### 5. Deferred Cleanup Code

```go
func TestFunction_CleanupOnError(t *testing.T) {
    // Setup code that should trigger defer cleanup
    // Verify cleanup happened
}
```

### 6. Rare Enum Values

```go
func TestStatusString_AllValues(t *testing.T) {
    tests := []Status{
        StatusActive,
        StatusInactive,
        StatusPending,
        StatusArchived,  // â† Often forgotten
        StatusDeleted,   // â† Often forgotten
    }

    for _, status := range tests {
        t.Run(status.String(), func(t *testing.T) {
            assert.NotEmpty(t, status.String())
        })
    }
}
```

## Systematic Gap-Filling Process

### For Each Package <95% Coverage:

1. **Identify Uncovered Lines**
   ```bash
   go test ./internal/domain/warehouse/item -coverprofile=item-coverage.out
   go tool cover -html=item-coverage.out
   ```

2. **Categorize Gaps**
   - Error handling: X lines
   - Edge cases: Y lines
   - Enum values: Z lines
   - etc.

3. **Create Targeted Tests**
   Add specific test functions to cover identified gaps

4. **Verify Improvement**
   ```bash
   go test ./internal/domain/warehouse/item -cover
   # Should show improved percentage
   ```

5. **Repeat** until package reaches 95%

## Package-by-Package Checklist

Use this template for each low-coverage package:

```markdown
### Package: internal/domain/warehouse/item

Current Coverage: 87.3%
Target Coverage: 95%

Gaps Identified:
- [ ] Line 45-48: Error handling for invalid category ID
- [ ] Line 102: Nil check for optional description
- [ ] Line 156-159: SearchVector generation edge case
- [ ] Line 203: Enum value handling for unknown condition

Tests to Add:
1. TestItem_InvalidCategoryID - covers lines 45-48
2. TestItem_NilDescription - covers line 102
3. TestSearchVector_EmptyFields - covers lines 156-159
4. TestCondition_UnknownValue - covers line 203

After Adding Tests:
New Coverage: 95.2% âœ“
```

## Helper Tools

### Coverage Diff Tool

Create a script to compare coverage before/after:

```bash
#!/bin/bash
# coverage-diff.sh

go test ./... -coverprofile=before.out
# ... make changes ...
go test ./... -coverprofile=after.out

echo "Coverage Before:"
go tool cover -func=before.out | grep total

echo "Coverage After:"
go tool cover -func=after.out | grep total
```

### Find Untested Functions

```bash
# List functions with 0% coverage
go tool cover -func=coverage.out | awk '$3 == "0.0%" {print $1}'
```

## Expected Gaps to Fill

Based on typical patterns, expect to add ~40-60 tests across:

- **Error handling branches**: 15-20 tests
- **Edge case validations**: 10-15 tests
- **Enum/const completeness**: 5-10 tests
- **Nil/empty input handling**: 5-10 tests
- **Context cancellation**: 3-5 tests
- **Initialization edge cases**: 5-8 tests

## Verification Checklist

Before considering Phase 5 complete:

- [ ] Overall coverage >= 95%
- [ ] No package <90% (except intentional exclusions)
- [ ] All critical paths tested
- [ ] Error branches covered
- [ ] Edge cases handled
- [ ] HTML report reviewed manually
- [ ] No obvious gaps remain

## Final Coverage Report

Generate final report:

```bash
go test ./... -coverprofile=final-coverage.out -covermode=atomic

# Overall stats
echo "=== Final Coverage Report ==="
go tool cover -func=final-coverage.out | grep total

# Per-package breakdown
echo "\n=== Package Coverage ==="
go tool cover -func=final-coverage.out | grep -E "^github.com/antti.*\.go:" | \
    awk '{pkg=$1; sub(/\/[^/]+\.go.*/, "", pkg); coverage[pkg]+=$3; count[pkg]++}
    END {for (p in coverage) printf "%-60s %.1f%%\n", p, coverage[p]/count[p]}' | \
    sort -k2 -n

# Generate badge
COVERAGE=$(go tool cover -func=final-coverage.out | grep total | awk '{print $3}')
echo "\n=== Coverage Badge ==="
echo "![Coverage](https://img.shields.io/badge/coverage-${COVERAGE}-brightgreen)"
```

## Files Modified

Throughout this task, you'll extend existing test files across the codebase. No specific new files, but expect to modify 20-40 `*_test.go` files.

## Estimated Effort

- **Time**: 8-10 hours
- **Tests to add**: 40-60

## Success Criteria

- [ ] Overall coverage reaches 95%+
- [ ] All packages have >90% coverage
- [ ] HTML report shows minimal red sections
- [ ] All error paths are tested
- [ ] Edge cases are covered
- [ ] Manual review confirms no critical gaps

## Running Final Tests

```bash
# Complete test run with coverage
go test ./... -v -coverprofile=final-coverage.out -covermode=atomic

# Verify coverage
go tool cover -func=final-coverage.out | grep total

# Expected output:
# total:  (statements)  95.2%
```

## Phase 5 Complete!

After completing all Phase 5 tasks, you should have:
- âœ… Router and API setup tested
- âœ… Documentation routes tested
- âœ… Batch operations tested
- âœ… All coverage gaps filled

**Total Phase 5 Impact**: +3.1% overall coverage (91.9% â†’ 95%+)

**CONGRATULATIONS!** The test coverage improvement plan is complete. You've achieved 95% test coverage across the Go backend! ðŸŽ‰
