# Phase 4.1: Expand E2E Integration Tests

**Objective**: Add comprehensive integration tests for complex workflows and cross-domain operations

## Overview

Integration tests verify that multiple components work together correctly with a real database. These tests use the `//go:build integration` tag and run against a test PostgreSQL database.

## New Test Files Needed

| Test File | Description | Test Count |
|-----------|-------------|------------|
| `attachment_flow_test.go` | File upload/download workflows | 8-10 |
| `company_flow_test.go` | Company CRUD operations | 6-8 |
| `label_flow_test.go` | Label management and item associations | 6-8 |
| `favorite_flow_test.go` | Favorite operations | 5-6 |
| `activity_flow_test.go` | Activity tracking across operations | 8-10 |
| `movement_flow_test.go` | Inventory movement tracking | 8-10 |
| `deleted_flow_test.go` | Soft delete/restore workflows | 6-8 |
| `permission_flow_test.go` | Role-based access control | 10-12 |
| `concurrent_flow_test.go` | Concurrent operations and locks | 6-8 |
| `pagination_flow_test.go` | Large dataset pagination | 5-6 |

## Integration Test Structure

```go
//go:build integration
// +build integration

package integration_test

import (
    "context"
    "fmt"
    "net/http"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"

    "github.com/antti/home-warehouse/go-backend/internal/testutil"
)

func TestAttachmentUploadDownload(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    // Create user and authenticate
    token := ts.CreateUserAndLogin(t, "attach@example.com", "SecurePass123!")
    ts.SetToken(token)

    // Create workspace
    wsID := ts.CreateWorkspace(t, "Attachment Test WS")

    // Create item
    itemID := ts.CreateItem(t, wsID, testutil.ItemInput{
        Name: "Test Item",
        SKU:  "TEST-001",
    })

    t.Run("upload and download file", func(t *testing.T) {
        // Upload file
        fileContent := []byte("test file content")
        resp := ts.UploadAttachment(
            fmt.Sprintf("/workspaces/%s/items/%s/attachments", wsID, itemID),
            "test.pdf",
            fileContent,
        )
        require.Equal(t, http.StatusCreated, resp.StatusCode)

        var attachment testutil.AttachmentResponse
        ts.ParseResponse(resp, &attachment)

        // Verify attachment metadata
        assert.Equal(t, "test.pdf", attachment.Filename)
        assert.Equal(t, "application/pdf", attachment.MimeType)
        assert.Greater(t, attachment.FileSize, int64(0))

        // Download file
        downloadResp := ts.Get(fmt.Sprintf("/workspaces/%s/attachments/%s/download",
            wsID, attachment.ID))
        require.Equal(t, http.StatusOK, downloadResp.StatusCode)

        body := ts.ReadBody(downloadResp)
        assert.Equal(t, fileContent, body)
    })

    t.Run("list attachments for item", func(t *testing.T) {
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/items/%s/attachments", wsID, itemID))
        require.Equal(t, http.StatusOK, resp.StatusCode)

        var attachments []testutil.AttachmentResponse
        ts.ParseResponse(resp, &attachments)
        assert.Greater(t, len(attachments), 0)
    })

    t.Run("delete attachment", func(t *testing.T) {
        // Upload another file
        resp := ts.UploadAttachment(
            fmt.Sprintf("/workspaces/%s/items/%s/attachments", wsID, itemID),
            "delete-me.txt",
            []byte("content"),
        )
        var attachment testutil.AttachmentResponse
        ts.ParseResponse(resp, &attachment)

        // Delete it
        deleteResp := ts.Delete(fmt.Sprintf("/workspaces/%s/attachments/%s",
            wsID, attachment.ID))
        assert.Equal(t, http.StatusNoContent, deleteResp.StatusCode)

        // Verify it's gone
        getResp := ts.Get(fmt.Sprintf("/workspaces/%s/attachments/%s",
            wsID, attachment.ID))
        assert.Equal(t, http.StatusNotFound, getResp.StatusCode)
    })
}
```

## Activity Flow Tests

```go
func TestActivityTracking(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    token := ts.CreateUserAndLogin(t, "activity@example.com", "SecurePass123!")
    ts.SetToken(token)
    wsID := ts.CreateWorkspace(t, "Activity Test WS")

    t.Run("tracks item creation activity", func(t *testing.T) {
        itemID := ts.CreateItem(t, wsID, testutil.ItemInput{
            Name: "Tracked Item",
        })

        // Get activities
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/activities", wsID))
        require.Equal(t, http.StatusOK, resp.StatusCode)

        var activities []testutil.ActivityResponse
        ts.ParseResponse(resp, &activities)

        // Should have activity for item creation
        found := false
        for _, act := range activities {
            if act.EntityType == "item" && act.EntityID == itemID && act.Action == "created" {
                found = true
                break
            }
        }
        assert.True(t, found, "Activity for item creation not found")
    })

    t.Run("tracks item update activity", func(t *testing.T) {
        itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "Original"})

        // Update item
        ts.UpdateItem(t, wsID, itemID, testutil.ItemInput{Name: "Updated"})

        // Check activities
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/items/%s/activities", wsID, itemID))
        var activities []testutil.ActivityResponse
        ts.ParseResponse(resp, &activities)

        // Should have both created and updated activities
        actions := make(map[string]bool)
        for _, act := range activities {
            actions[act.Action] = true
        }
        assert.True(t, actions["created"])
        assert.True(t, actions["updated"])
    })
}
```

## Movement Tracking Tests

```go
func TestInventoryMovementTracking(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    token := ts.CreateUserAndLogin(t, "movement@example.com", "SecurePass123!")
    ts.SetToken(token)
    wsID := ts.CreateWorkspace(t, "Movement Test WS")

    itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "Movable Item"})
    loc1ID := ts.CreateLocation(t, wsID, testutil.LocationInput{Name: "Location 1"})
    loc2ID := ts.CreateLocation(t, wsID, testutil.LocationInput{Name: "Location 2"})

    t.Run("tracks inventory movement between locations", func(t *testing.T) {
        // Create inventory at location 1
        invID := ts.CreateInventory(t, wsID, testutil.InventoryInput{
            ItemID:     itemID,
            LocationID: &loc1ID,
            Quantity:   5,
        })

        // Move to location 2
        ts.UpdateInventory(t, wsID, invID, testutil.InventoryInput{
            LocationID: &loc2ID,
        })

        // Check movement history
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/inventory/%s/movements", wsID, invID))
        var movements []testutil.MovementResponse
        ts.ParseResponse(resp, &movements)

        assert.Len(t, movements, 1)
        assert.Equal(t, loc1ID, movements[0].FromLocationID)
        assert.Equal(t, loc2ID, movements[0].ToLocationID)
    })
}
```

## Permission Flow Tests

```go
func TestRoleBasedAccessControl(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    // Create owner
    ownerToken := ts.CreateUserAndLogin(t, "owner@example.com", "Pass123!")
    ts.SetToken(ownerToken)
    wsID := ts.CreateWorkspace(t, "Permission Test WS")

    // Create member user
    memberToken := ts.CreateUserAndLogin(t, "member@example.com", "Pass123!")

    // Add member to workspace with viewer role
    ts.SetToken(ownerToken)
    ts.AddMember(t, wsID, "member@example.com", "viewer")

    t.Run("viewer can read but not write", func(t *testing.T) {
        ts.SetToken(ownerToken)
        itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "Test Item"})

        // Switch to member
        ts.SetToken(memberToken)

        // Can read
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/items/%s", wsID, itemID))
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        // Cannot update
        updateResp := ts.Patch(fmt.Sprintf("/workspaces/%s/items/%s", wsID, itemID),
            `{"name":"Updated"}`)
        assert.Equal(t, http.StatusForbidden, updateResp.StatusCode)

        // Cannot delete
        deleteResp := ts.Delete(fmt.Sprintf("/workspaces/%s/items/%s", wsID, itemID))
        assert.Equal(t, http.StatusForbidden, deleteResp.StatusCode)
    })

    t.Run("admin can manage items but not members", func(t *testing.T) {
        // Upgrade member to admin
        ts.SetToken(ownerToken)
        ts.UpdateMemberRole(t, wsID, "member@example.com", "admin")

        ts.SetToken(memberToken)

        // Can create items
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/items", wsID),
            `{"name":"Admin Item"}`)
        assert.Equal(t, http.StatusCreated, resp.StatusCode)

        // Cannot add members
        addMemberResp := ts.Post(fmt.Sprintf("/workspaces/%s/members", wsID),
            `{"email":"new@example.com","role":"member"}`)
        assert.Equal(t, http.StatusForbidden, addMemberResp.StatusCode)
    })
}
```

## Concurrent Operations Tests

```go
func TestConcurrentOperations(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    token := ts.CreateUserAndLogin(t, "concurrent@example.com", "Pass123!")
    ts.SetToken(token)
    wsID := ts.CreateWorkspace(t, "Concurrent Test WS")
    itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "Concurrent Item"})

    t.Run("handles concurrent updates gracefully", func(t *testing.T) {
        // Launch concurrent updates
        results := make(chan int, 10)
        for i := 0; i < 10; i++ {
            go func(n int) {
                resp := ts.Patch(fmt.Sprintf("/workspaces/%s/items/%s", wsID, itemID),
                    fmt.Sprintf(`{"description":"Update %d"}`, n))
                results <- resp.StatusCode
            }(i)
        }

        // Collect results
        successCount := 0
        for i := 0; i < 10; i++ {
            status := <-results
            if status == http.StatusOK {
                successCount++
            }
        }

        // At least some should succeed
        assert.Greater(t, successCount, 0)
    })
}
```

## Files to Create

- `tests/integration/attachment_flow_test.go`
- `tests/integration/company_flow_test.go`
- `tests/integration/label_flow_test.go`
- `tests/integration/favorite_flow_test.go`
- `tests/integration/activity_flow_test.go`
- `tests/integration/movement_flow_test.go`
- `tests/integration/deleted_flow_test.go`
- `tests/integration/permission_flow_test.go`
- `tests/integration/concurrent_flow_test.go`
- `tests/integration/pagination_flow_test.go`

## Estimated Effort

- **Time**: 15-20 hours
- **Tests to add**: 50-70

## Success Criteria

- [ ] Complex workflows are tested end-to-end
- [ ] File upload/download operations work correctly
- [ ] Activity tracking captures all operations
- [ ] Movement history is accurate
- [ ] Permission checks work across operations
- [ ] Concurrent operations are handled safely
- [ ] All tests run against real database
- [ ] Tests are isolated and can run in parallel

## Running Tests

```bash
# Run integration tests
TEST_DATABASE_URL="postgresql://wh:wh@localhost:5432/warehouse_test?sslmode=disable" \
go test ./tests/integration -v -tags=integration

# Run specific test
go test ./tests/integration -v -tags=integration -run TestAttachmentUploadDownload

# Run with coverage
go test ./tests/integration -v -tags=integration -coverprofile=integration-coverage.out
```

## Next Steps

After completing E2E integration tests, proceed to [4.2 Negative Integration Tests](4.2-negative-integration-tests.md).
