# Phase 4.2: Add Negative Integration Tests

**Objective**: Test permission violations, constraint failures, and error recovery scenarios

## Overview

Negative integration tests verify that the system correctly handles error conditions, security violations, and constraint failures in realistic scenarios with a real database.

## Test Categories

### 1. Permission Denial Tests
### 2. Constraint Violation Tests
### 3. Invalid State Transition Tests
### 4. Cross-Workspace Isolation Tests
### 5. Resource Cleanup Tests

## Permission Denial Integration Tests

```go
//go:build integration
// +build integration

package integration_test

import (
    "fmt"
    "net/http"
    "testing"

    "github.com/stretchr/testify/assert"

    "github.com/antti/home-warehouse/go-backend/internal/testutil"
)

func TestPermissionDenied(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    // User 1 creates workspace
    user1Token := ts.CreateUserAndLogin(t, "user1@example.com", "Pass123!")
    ts.SetToken(user1Token)
    wsID := ts.CreateWorkspace(t, "User 1 Workspace")
    itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "User 1 Item"})

    // User 2 tries to access User 1's workspace
    user2Token := ts.CreateUserAndLogin(t, "user2@example.com", "Pass123!")
    ts.SetToken(user2Token)

    t.Run("cannot list items in other user's workspace", func(t *testing.T) {
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/items", wsID))
        assert.Equal(t, http.StatusForbidden, resp.StatusCode)
    })

    t.Run("cannot get item from other user's workspace", func(t *testing.T) {
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/items/%s", wsID, itemID))
        assert.Equal(t, http.StatusForbidden, resp.StatusCode)
    })

    t.Run("cannot create item in other user's workspace", func(t *testing.T) {
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/items", wsID),
            `{"name":"Unauthorized Item"}`)
        assert.Equal(t, http.StatusForbidden, resp.StatusCode)
    })

    t.Run("cannot update item in other user's workspace", func(t *testing.T) {
        resp := ts.Patch(fmt.Sprintf("/workspaces/%s/items/%s", wsID, itemID),
            `{"name":"Hacked"}`)
        assert.Equal(t, http.StatusForbidden, resp.StatusCode)
    })

    t.Run("cannot delete item in other user's workspace", func(t *testing.T) {
        resp := ts.Delete(fmt.Sprintf("/workspaces/%s/items/%s", wsID, itemID))
        assert.Equal(t, http.StatusForbidden, resp.StatusCode)
    })
}

func TestRoleRestrictions(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    // Setup: owner creates workspace and adds viewer
    ownerToken := ts.CreateUserAndLogin(t, "owner@example.com", "Pass123!")
    ts.SetToken(ownerToken)
    wsID := ts.CreateWorkspace(t, "Test Workspace")

    viewerToken := ts.CreateUserAndLogin(t, "viewer@example.com", "Pass123!")
    ts.AddMember(t, wsID, "viewer@example.com", "viewer")

    // Viewer attempts write operations
    ts.SetToken(viewerToken)

    t.Run("viewer cannot create items", func(t *testing.T) {
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/items", wsID),
            `{"name":"Viewer Item"}`)
        assert.Equal(t, http.StatusForbidden, resp.StatusCode)
    })

    t.Run("viewer cannot update workspace settings", func(t *testing.T) {
        resp := ts.Patch(fmt.Sprintf("/workspaces/%s", wsID),
            `{"name":"Hacked Name"}`)
        assert.Equal(t, http.StatusForbidden, resp.StatusCode)
    })

    t.Run("viewer cannot add members", func(t *testing.T) {
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/members", wsID),
            `{"email":"newuser@example.com","role":"member"}`)
        assert.Equal(t, http.StatusForbidden, resp.StatusCode)
    })

    t.Run("member cannot remove other members", func(t *testing.T) {
        // Add member user
        memberToken := ts.CreateUserAndLogin(t, "member@example.com", "Pass123!")
        ts.SetToken(ownerToken)
        ts.AddMember(t, wsID, "member@example.com", "member")

        // Member tries to remove viewer
        ts.SetToken(memberToken)
        resp := ts.Delete(fmt.Sprintf("/workspaces/%s/members/viewer@example.com", wsID))
        assert.Equal(t, http.StatusForbidden, resp.StatusCode)
    })
}
```

## Constraint Violation Tests

```go
func TestConstraintViolations(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    token := ts.CreateUserAndLogin(t, "constraint@example.com", "Pass123!")
    ts.SetToken(token)
    wsID := ts.CreateWorkspace(t, "Constraint Test WS")

    t.Run("cannot create item with duplicate SKU", func(t *testing.T) {
        // Create first item
        ts.CreateItem(t, wsID, testutil.ItemInput{
            Name: "Item 1",
            SKU:  "DUPLICATE-SKU",
        })

        // Try to create second item with same SKU
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/items", wsID),
            `{"name":"Item 2","sku":"DUPLICATE-SKU"}`)
        assert.Equal(t, http.StatusConflict, resp.StatusCode)
    })

    t.Run("cannot create user with duplicate email", func(t *testing.T) {
        // First user already created in test setup
        resp := ts.Post("/auth/register",
            `{"email":"constraint@example.com","password":"Pass123!"}`)
        assert.Equal(t, http.StatusConflict, resp.StatusCode)
    })

    t.Run("cannot assign invalid category to item", func(t *testing.T) {
        fakeCategory := ts.GenerateUUID()
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/items", wsID),
            fmt.Sprintf(`{"name":"Item","category_id":"%s"}`, fakeCategory))
        assert.Equal(t, http.StatusBadRequest, resp.StatusCode)
    })

    t.Run("cannot create inventory with invalid item", func(t *testing.T) {
        fakeItem := ts.GenerateUUID()
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/inventory", wsID),
            fmt.Sprintf(`{"item_id":"%s","quantity":5}`, fakeItem))
        assert.Equal(t, http.StatusBadRequest, resp.StatusCode)
    })

    t.Run("cannot delete category with items", func(t *testing.T) {
        catID := ts.CreateCategory(t, wsID, testutil.CategoryInput{Name: "Protected"})
        ts.CreateItem(t, wsID, testutil.ItemInput{
            Name:       "Item",
            CategoryID: &catID,
        })

        resp := ts.Delete(fmt.Sprintf("/workspaces/%s/categories/%s", wsID, catID))
        assert.Equal(t, http.StatusConflict, resp.StatusCode)
    })
}
```

## Invalid State Transition Tests

```go
func TestInvalidStateTransitions(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    token := ts.CreateUserAndLogin(t, "state@example.com", "Pass123!")
    ts.SetToken(token)
    wsID := ts.CreateWorkspace(t, "State Test WS")

    t.Run("cannot return loan that's already returned", func(t *testing.T) {
        itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "Loanable Item"})
        invID := ts.CreateInventory(t, wsID, testutil.InventoryInput{
            ItemID:   itemID,
            Quantity: 1,
        })
        borrowerID := ts.CreateBorrower(t, wsID, testutil.BorrowerInput{
            Name: "John Doe",
        })

        // Create and return loan
        loanID := ts.CreateLoan(t, wsID, testutil.LoanInput{
            InventoryID: invID,
            BorrowerID:  borrowerID,
        })
        ts.ReturnLoan(t, wsID, loanID)

        // Try to return again
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/loans/%s/return", wsID, loanID), "")
        assert.Equal(t, http.StatusBadRequest, resp.StatusCode)
    })

    t.Run("cannot loan inventory that's already on loan", func(t *testing.T) {
        itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "Item"})
        invID := ts.CreateInventory(t, wsID, testutil.InventoryInput{
            ItemID:   itemID,
            Quantity: 1,
        })
        borrower1 := ts.CreateBorrower(t, wsID, testutil.BorrowerInput{Name: "Borrower 1"})
        borrower2 := ts.CreateBorrower(t, wsID, testutil.BorrowerInput{Name: "Borrower 2"})

        // First loan
        ts.CreateLoan(t, wsID, testutil.LoanInput{
            InventoryID: invID,
            BorrowerID:  borrower1,
        })

        // Try second loan
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/loans", wsID),
            fmt.Sprintf(`{"inventory_id":"%s","borrower_id":"%s"}`, invID, borrower2))
        assert.Equal(t, http.StatusConflict, resp.StatusCode)
    })

    t.Run("cannot set due date in the past", func(t *testing.T) {
        itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "Item"})
        invID := ts.CreateInventory(t, wsID, testutil.InventoryInput{
            ItemID:   itemID,
            Quantity: 1,
        })
        borrowerID := ts.CreateBorrower(t, wsID, testutil.BorrowerInput{Name: "Borrower"})

        resp := ts.Post(fmt.Sprintf("/workspaces/%s/loans", wsID),
            fmt.Sprintf(`{"inventory_id":"%s","borrower_id":"%s","due_date":"2020-01-01"}`,
                invID, borrowerID))
        assert.Equal(t, http.StatusBadRequest, resp.StatusCode)
    })
}
```

## Cross-Workspace Isolation Tests

```go
func TestCrossWorkspaceIsolation(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    token := ts.CreateUserAndLogin(t, "isolation@example.com", "Pass123!")
    ts.SetToken(token)

    ws1ID := ts.CreateWorkspace(t, "Workspace 1")
    ws2ID := ts.CreateWorkspace(t, "Workspace 2")

    t.Run("items in one workspace not visible in another", func(t *testing.T) {
        // Create item in workspace 1
        item1ID := ts.CreateItem(t, ws1ID, testutil.ItemInput{Name: "WS1 Item"})

        // List items in workspace 2
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/items", ws2ID))
        var items []testutil.ItemResponse
        ts.ParseResponse(resp, &items)

        // Should not include item from workspace 1
        for _, item := range items {
            assert.NotEqual(t, item1ID, item.ID)
        }
    })

    t.Run("cannot reference category from different workspace", func(t *testing.T) {
        // Create category in workspace 1
        cat1ID := ts.CreateCategory(t, ws1ID, testutil.CategoryInput{Name: "WS1 Category"})

        // Try to create item in workspace 2 with category from workspace 1
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/items", ws2ID),
            fmt.Sprintf(`{"name":"Item","category_id":"%s"}`, cat1ID))
        assert.Equal(t, http.StatusBadRequest, resp.StatusCode)
    })

    t.Run("search does not leak across workspaces", func(t *testing.T) {
        // Create item in workspace 1
        ts.CreateItem(t, ws1ID, testutil.ItemInput{Name: "Secret Item"})

        // Search in workspace 2
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/items/search?q=secret", ws2ID))
        var results testutil.SearchResponse
        ts.ParseResponse(resp, &results)

        assert.Equal(t, 0, results.Total)
    })
}
```

## Resource Cleanup Tests

```go
func TestResourceCleanup(t *testing.T) {
    ts := testutil.NewTestServer(t)
    defer ts.Cleanup()

    token := ts.CreateUserAndLogin(t, "cleanup@example.com", "Pass123!")
    ts.SetToken(token)
    wsID := ts.CreateWorkspace(t, "Cleanup Test WS")

    t.Run("soft deleted items are not returned in normal queries", func(t *testing.T) {
        itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "To Delete"})

        // Delete item
        ts.DeleteItem(t, wsID, itemID)

        // Should not appear in list
        resp := ts.Get(fmt.Sprintf("/workspaces/%s/items", wsID))
        var items []testutil.ItemResponse
        ts.ParseResponse(resp, &items)

        for _, item := range items {
            assert.NotEqual(t, itemID, item.ID)
        }

        // Should not be accessible by ID
        getResp := ts.Get(fmt.Sprintf("/workspaces/%s/items/%s", wsID, itemID))
        assert.Equal(t, http.StatusNotFound, getResp.StatusCode)
    })

    t.Run("can restore soft deleted items", func(t *testing.T) {
        itemID := ts.CreateItem(t, wsID, testutil.ItemInput{Name: "Restore Me"})
        ts.DeleteItem(t, wsID, itemID)

        // Restore
        resp := ts.Post(fmt.Sprintf("/workspaces/%s/deleted/items/%s/restore", wsID, itemID), "")
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        // Should be accessible again
        getResp := ts.Get(fmt.Sprintf("/workspaces/%s/items/%s", wsID, itemID))
        assert.Equal(t, http.StatusOK, getResp.StatusCode)
    })
}
```

## Files to Create/Extend

Add tests to existing integration files or create new ones:
- `tests/integration/permission_test.go` (new)
- `tests/integration/constraints_test.go` (new)
- `tests/integration/state_transitions_test.go` (new)
- `tests/integration/isolation_test.go` (new)

## Estimated Effort

- **Time**: 10-12 hours
- **Tests to add**: 30-40

## Success Criteria

- [ ] Permission violations return 403 Forbidden
- [ ] Constraint violations return appropriate errors
- [ ] Invalid state transitions are prevented
- [ ] Cross-workspace isolation is enforced
- [ ] Soft delete/restore works correctly
- [ ] All tests run against real database
- [ ] Tests verify security boundaries

## Running Tests

```bash
# Run negative integration tests
TEST_DATABASE_URL="postgresql://wh:wh@localhost:5432/warehouse_test?sslmode=disable" \
go test ./tests/integration -v -tags=integration -run TestPermission

go test ./tests/integration -v -tags=integration -run TestConstraint

# Run all integration tests
go test ./tests/integration -v -tags=integration
```

## Next Steps

After completing Phase 4, you should have:
- ✅ E2E integration tests for complex workflows
- ✅ Negative tests for security and constraints
- ✅ Cross-workspace isolation verified

**Total Phase 4 Impact**: +5% overall coverage (86.9% → 91.9%)

Proceed to [Phase 5: Remaining Gaps & Polish](../phase-5/).
