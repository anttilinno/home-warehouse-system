# Phase 1.3: Complete Job Testing

**Current Coverage**: 15.4% | **Target Coverage**: 40%

**Package**: `internal/jobs`

## Objective

Add unit tests for job configuration, payload construction, and time calculations. Full integration tests require Redis and are handled separately in the integration test suite.

## Components to Test

### 1. Scheduler Configuration (`scheduler.go`)

Test scenarios:
- Constructor initialization
- Config validation
- Redis connection setup
- Default configuration values
- Client retrieval

### 2. Loan Reminder Jobs (`loan_reminders.go`)

Test scenarios:
- Payload construction
- Overdue calculation
- Time calculations for reminders
- Due date formatting
- Payload serialization

### 3. Cleanup Jobs (`cleanup.go`)

Test scenarios:
- Cutoff date calculations
- Retention period handling
- Time-based filtering logic

## Test Examples

### Scheduler Configuration Tests

```go
package jobs_test

import (
    "testing"

    "github.com/stretchr/testify/assert"

    "github.com/antti/home-warehouse/go-backend/internal/jobs"
)

func TestDefaultSchedulerConfig(t *testing.T) {
    config := jobs.DefaultSchedulerConfig("localhost:6379")

    assert.NotNil(t, config)
    assert.Equal(t, "localhost:6379", config.RedisAddr)
    assert.Greater(t, config.Concurrency, 0)
    assert.NotEmpty(t, config.Queues)
}

func TestNewScheduler(t *testing.T) {
    config := jobs.DefaultSchedulerConfig("localhost:6379")

    // Note: This creates a scheduler without actually connecting to Redis
    // Full integration tests will verify Redis connectivity
    sched := jobs.NewScheduler(nil, config)

    assert.NotNil(t, sched)
    assert.NotNil(t, sched.Client())
}

func TestSchedulerConfig_Validation(t *testing.T) {
    tests := []struct {
        name    string
        config  jobs.SchedulerConfig
        wantErr bool
    }{
        {
            name: "valid config",
            config: jobs.SchedulerConfig{
                RedisAddr:   "localhost:6379",
                Concurrency: 10,
                Queues: map[string]int{
                    "critical": 6,
                    "default":  3,
                    "low":      1,
                },
            },
            wantErr: false,
        },
        {
            name: "missing redis address",
            config: jobs.SchedulerConfig{
                RedisAddr:   "",
                Concurrency: 10,
            },
            wantErr: true,
        },
        {
            name: "invalid concurrency",
            config: jobs.SchedulerConfig{
                RedisAddr:   "localhost:6379",
                Concurrency: 0,
            },
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.config.Validate()
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
            }
        })
    }
}
```

### Loan Reminder Payload Tests

```go
func TestLoanReminderPayload_Construction(t *testing.T) {
    loanID := uuid.New()
    borrowerName := "John Doe"
    itemName := "Laptop"
    dueDate := time.Now().Add(24 * time.Hour)

    payload := jobs.LoanReminderPayload{
        LoanID:       loanID,
        BorrowerName: borrowerName,
        ItemName:     itemName,
        DueDate:      dueDate,
    }

    assert.Equal(t, loanID, payload.LoanID)
    assert.Equal(t, borrowerName, payload.BorrowerName)
    assert.Equal(t, itemName, payload.ItemName)
    assert.Equal(t, dueDate, payload.DueDate)
}

func TestLoanReminderPayload_IsOverdue(t *testing.T) {
    now := time.Now()

    tests := []struct {
        name     string
        dueDate  time.Time
        expected bool
    }{
        {
            name:     "overdue by 1 day",
            dueDate:  now.Add(-24 * time.Hour),
            expected: true,
        },
        {
            name:     "due today",
            dueDate:  now,
            expected: false, // Depends on business logic
        },
        {
            name:     "due tomorrow",
            dueDate:  now.Add(24 * time.Hour),
            expected: false,
        },
        {
            name:     "overdue by 1 week",
            dueDate:  now.Add(-7 * 24 * time.Hour),
            expected: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            payload := jobs.LoanReminderPayload{
                DueDate: tt.dueDate,
            }

            isOverdue := payload.DueDate.Before(now)
            assert.Equal(t, tt.expected, isOverdue)
        })
    }
}

func TestLoanReminderPayload_DaysUntilDue(t *testing.T) {
    now := time.Now()

    tests := []struct {
        name     string
        dueDate  time.Time
        expected int
    }{
        {
            name:     "due in 7 days",
            dueDate:  now.Add(7 * 24 * time.Hour),
            expected: 7,
        },
        {
            name:     "due in 1 day",
            dueDate:  now.Add(24 * time.Hour),
            expected: 1,
        },
        {
            name:     "overdue by 3 days",
            dueDate:  now.Add(-3 * 24 * time.Hour),
            expected: -3,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            payload := jobs.LoanReminderPayload{
                DueDate: tt.dueDate,
            }

            days := int(payload.DueDate.Sub(now).Hours() / 24)
            assert.Equal(t, tt.expected, days)
        })
    }
}

func TestLoanReminderPayload_Serialization(t *testing.T) {
    payload := jobs.LoanReminderPayload{
        LoanID:       uuid.New(),
        BorrowerName: "John Doe",
        ItemName:     "Laptop",
        DueDate:      time.Now().Add(24 * time.Hour),
    }

    // Test JSON serialization/deserialization
    data, err := json.Marshal(payload)
    assert.NoError(t, err)

    var decoded jobs.LoanReminderPayload
    err = json.Unmarshal(data, &decoded)
    assert.NoError(t, err)

    assert.Equal(t, payload.LoanID, decoded.LoanID)
    assert.Equal(t, payload.BorrowerName, decoded.BorrowerName)
    assert.Equal(t, payload.ItemName, decoded.ItemName)
}
```

### Cleanup Job Tests

```go
func TestCleanupPayload_CutoffDateCalculation(t *testing.T) {
    now := time.Now()

    tests := []struct {
        name           string
        retentionDays  int
        expectedCutoff time.Time
    }{
        {
            name:           "30 days retention",
            retentionDays:  30,
            expectedCutoff: now.Add(-30 * 24 * time.Hour),
        },
        {
            name:           "90 days retention",
            retentionDays:  90,
            expectedCutoff: now.Add(-90 * 24 * time.Hour),
        },
        {
            name:           "1 year retention",
            retentionDays:  365,
            expectedCutoff: now.Add(-365 * 24 * time.Hour),
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            cutoff := jobs.CalculateCutoffDate(now, tt.retentionDays)

            // Allow small time difference due to test execution time
            diff := cutoff.Sub(tt.expectedCutoff)
            assert.Less(t, diff.Abs().Seconds(), 1.0)
        })
    }
}

func TestCleanupPayload_Construction(t *testing.T) {
    entityType := "activity_logs"
    retentionDays := 90

    payload := jobs.CleanupPayload{
        EntityType:    entityType,
        RetentionDays: retentionDays,
    }

    assert.Equal(t, entityType, payload.EntityType)
    assert.Equal(t, retentionDays, payload.RetentionDays)
}

func TestCleanupPayload_Validation(t *testing.T) {
    tests := []struct {
        name    string
        payload jobs.CleanupPayload
        wantErr bool
    }{
        {
            name: "valid payload",
            payload: jobs.CleanupPayload{
                EntityType:    "activity_logs",
                RetentionDays: 90,
            },
            wantErr: false,
        },
        {
            name: "missing entity type",
            payload: jobs.CleanupPayload{
                EntityType:    "",
                RetentionDays: 90,
            },
            wantErr: true,
        },
        {
            name: "invalid retention days",
            payload: jobs.CleanupPayload{
                EntityType:    "activity_logs",
                RetentionDays: -1,
            },
            wantErr: true,
        },
        {
            name: "zero retention days",
            payload: jobs.CleanupPayload{
                EntityType:    "activity_logs",
                RetentionDays: 0,
            },
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.payload.Validate()
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
            }
        })
    }
}
```

## Integration Test Note

Full integration tests that actually enqueue and process jobs require Redis. These are in the separate integration test suite with the `//go:build integration` tag:

```go
//go:build integration
// +build integration

func TestLoanReminderJob_Integration(t *testing.T) {
    // This test requires Redis and is in the integration suite
    // Tests actual job enqueueing, processing, and completion
}
```

## Files to Create/Extend

- `internal/jobs/scheduler_test.go` (extend existing)
- `internal/jobs/loan_reminders_test.go` (create)
- `internal/jobs/cleanup_test.go` (create)

## Estimated Effort

- **Time**: 3-4 hours
- **Tests to add**: 20-30

## Success Criteria

- [ ] Scheduler configuration is validated
- [ ] Payload construction tests exist for all job types
- [ ] Time calculations are tested (overdue, cutoff dates)
- [ ] Payload serialization/deserialization works correctly
- [ ] Input validation is tested
- [ ] Unit tests run without Redis dependency
- [ ] Coverage for `internal/jobs` reaches 40%+ (unit tests only)

## Running Tests

```bash
# Test jobs package (unit tests only, no Redis needed)
go test ./internal/jobs -v -cover -short

# Expected output
ok      github.com/antti/home-warehouse/go-backend/internal/jobs    0.012s  coverage: 42.1% of statements
```

## Next Steps

After completing Phase 1, you should have:
- ✅ Middleware testing complete (95% coverage)
- ✅ Entity validation tests complete (90% coverage)
- ✅ Job unit tests complete (40% coverage)

**Total Phase 1 Impact**: +15% overall coverage (38.9% → 53.9%)

Proceed to [Phase 2: Handler Test Suite](../phase-2/).
