# Phase 1.2: Add Entity Validation Tests

**Current Coverage**: 4% (only category) | **Target Coverage**: 90%

## Objective

Add comprehensive validation tests for all domain entities, covering creation, validation, and update operations.

## Entities Needing Tests

### Warehouse Domain Entities

1. **Item** (`warehouse/item/entity.go`)
   - Item creation with required/optional fields
   - SKU validation and uniqueness
   - Search vector generation
   - Short code generation
   - Item updates (name, description, category, etc.)

2. **Location** (`warehouse/location/entity.go`)
   - Location hierarchy validation
   - Parent location validation
   - Zone/shelf/bin validation
   - Short code generation
   - Path calculation

3. **Container** (`warehouse/container/entity.go`)
   - Container creation and validation
   - Short code generation
   - Location assignment
   - Container updates

4. **Inventory** (`warehouse/inventory/entity.go`)
   - Inventory creation with item and location
   - Condition validation (NEW, EXCELLENT, GOOD, FAIR, POOR, DAMAGED, FOR_REPAIR)
   - Status validation (AVAILABLE, IN_USE, RESERVED, ON_LOAN, IN_TRANSIT, DISPOSED, MISSING)
   - State transitions
   - Pricing validation (purchase_price, current_value)

5. **Loan** (`warehouse/loan/entity.go`)
   - Loan creation with inventory and borrower
   - Date validation (borrowed_at, due_date, returned_at)
   - State validation
   - Return operation
   - Overdue calculation

6. **Borrower** (`warehouse/borrower/entity.go`)
   - Borrower creation
   - Contact information validation
   - Name validation

### Auth Domain Entities

7. **User** (`auth/user/entity.go`)
   - User creation with email and password
   - Email validation
   - Password hashing
   - Password verification
   - Full name validation
   - Superuser flag

8. **Workspace** (`auth/workspace/entity.go`)
   - Workspace creation
   - Name and slug validation
   - Slug generation
   - Description validation

9. **Member** (`auth/member/entity.go`)
   - Member creation with user and workspace
   - Role validation (owner, admin, member, viewer)
   - Role updates

## Test Pattern

Replicate the successful pattern from `category_test.go`:

```go
package item_test

import (
    "testing"

    "github.com/google/uuid"
    "github.com/stretchr/testify/assert"

    "github.com/antti/home-warehouse/go-backend/internal/domain/warehouse/item"
)

func TestNewItem(t *testing.T) {
    workspaceID := uuid.New()

    tests := []struct {
        name    string
        input   item.CreateInput
        wantErr bool
        errMsg  string
    }{
        {
            name: "valid item with all fields",
            input: item.CreateInput{
                Name:        "Laptop",
                SKU:         "LAP-001",
                Description: "MacBook Pro 16-inch",
                Brand:       "Apple",
                Model:       "MacBook Pro 16",
            },
            wantErr: false,
        },
        {
            name: "valid item with minimal fields",
            input: item.CreateInput{
                Name: "Laptop",
            },
            wantErr: false,
        },
        {
            name: "missing required name",
            input: item.CreateInput{
                SKU: "LAP-001",
            },
            wantErr: true,
            errMsg:  "name is required",
        },
        {
            name: "empty name",
            input: item.CreateInput{
                Name: "",
            },
            wantErr: true,
            errMsg:  "name cannot be empty",
        },
        {
            name: "name too long",
            input: item.CreateInput{
                Name: string(make([]byte, 256)), // 256 chars
            },
            wantErr: true,
            errMsg:  "name exceeds maximum length",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            item, err := item.NewItem(workspaceID, tt.input)

            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, item)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, item)
                assert.Equal(t, workspaceID, item.WorkspaceID)
                assert.Equal(t, tt.input.Name, item.Name)
                assert.NotEqual(t, uuid.Nil, item.ID)
                // Verify short code was generated
                assert.NotEmpty(t, item.ShortCode)
            }
        })
    }
}

func TestItem_Update(t *testing.T) {
    workspaceID := uuid.New()
    item, _ := item.NewItem(workspaceID, item.CreateInput{
        Name: "Original Name",
        SKU:  "ORIG-001",
    })

    tests := []struct {
        name    string
        update  item.UpdateInput
        wantErr bool
        errMsg  string
    }{
        {
            name: "update name",
            update: item.UpdateInput{
                Name: strPtr("Updated Name"),
            },
            wantErr: false,
        },
        {
            name: "update SKU",
            update: item.UpdateInput{
                SKU: strPtr("UPD-001"),
            },
            wantErr: false,
        },
        {
            name: "update to empty name",
            update: item.UpdateInput{
                Name: strPtr(""),
            },
            wantErr: true,
            errMsg:  "name cannot be empty",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := item.Update(tt.update)

            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
            } else {
                assert.NoError(t, err)
                if tt.update.Name != nil {
                    assert.Equal(t, *tt.update.Name, item.Name)
                }
            }
        })
    }
}

func TestItem_SearchVectorGeneration(t *testing.T) {
    workspaceID := uuid.New()
    item, err := item.NewItem(workspaceID, item.CreateInput{
        Name:        "Laptop",
        Description: "MacBook Pro",
        Brand:       "Apple",
        Model:       "MacBook Pro 16",
        SKU:         "LAP-001",
    })

    assert.NoError(t, err)
    assert.NotEmpty(t, item.SearchVector)
    // Verify search vector contains key terms
    assert.Contains(t, item.SearchVector, "laptop")
    assert.Contains(t, item.SearchVector, "macbook")
    assert.Contains(t, item.SearchVector, "apple")
}

// Helper function
func strPtr(s string) *string {
    return &s
}
```

## Inventory Entity Test Examples

```go
func TestNewInventory(t *testing.T) {
    workspaceID := uuid.New()
    itemID := uuid.New()
    locationID := uuid.New()

    tests := []struct {
        name    string
        input   inventory.CreateInput
        wantErr bool
        errMsg  string
    }{
        {
            name: "valid inventory with all fields",
            input: inventory.CreateInput{
                ItemID:        itemID,
                LocationID:    &locationID,
                Quantity:      5,
                Condition:     inventory.ConditionExcellent,
                Status:        inventory.StatusAvailable,
                PurchasePrice: decimalPtr(999.99),
                CurrentValue:  decimalPtr(899.99),
            },
            wantErr: false,
        },
        {
            name: "invalid condition",
            input: inventory.CreateInput{
                ItemID:    itemID,
                Quantity:  1,
                Condition: "INVALID",
                Status:    inventory.StatusAvailable,
            },
            wantErr: true,
            errMsg:  "invalid condition",
        },
        {
            name: "invalid status",
            input: inventory.CreateInput{
                ItemID:    itemID,
                Quantity:  1,
                Condition: inventory.ConditionNew,
                Status:    "INVALID",
            },
            wantErr: true,
            errMsg:  "invalid status",
        },
        {
            name: "negative quantity",
            input: inventory.CreateInput{
                ItemID:    itemID,
                Quantity:  -1,
                Condition: inventory.ConditionNew,
                Status:    inventory.StatusAvailable,
            },
            wantErr: true,
            errMsg:  "quantity must be positive",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            inv, err := inventory.NewInventory(workspaceID, tt.input)

            if tt.wantErr {
                assert.Error(t, err)
                assert.Contains(t, err.Error(), tt.errMsg)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, inv)
                assert.Equal(t, tt.input.Condition, inv.Condition)
                assert.Equal(t, tt.input.Status, inv.Status)
            }
        })
    }
}

func TestInventory_StateTransitions(t *testing.T) {
    workspaceID := uuid.New()
    inv, _ := inventory.NewInventory(workspaceID, inventory.CreateInput{
        ItemID:    uuid.New(),
        Quantity:  1,
        Condition: inventory.ConditionNew,
        Status:    inventory.StatusAvailable,
    })

    t.Run("transition to on loan", func(t *testing.T) {
        err := inv.SetStatus(inventory.StatusOnLoan)
        assert.NoError(t, err)
        assert.Equal(t, inventory.StatusOnLoan, inv.Status)
    })

    t.Run("invalid transition", func(t *testing.T) {
        // Test any business rules for invalid state transitions
    })
}
```

## User Entity Test Examples

```go
func TestNewUser(t *testing.T) {
    tests := []struct {
        name    string
        input   user.CreateInput
        wantErr bool
        errMsg  string
    }{
        {
            name: "valid user",
            input: user.CreateInput{
                Email:    "test@example.com",
                Password: "SecurePass123!",
                FullName: "John Doe",
            },
            wantErr: false,
        },
        {
            name: "invalid email format",
            input: user.CreateInput{
                Email:    "invalid-email",
                Password: "SecurePass123!",
            },
            wantErr: true,
            errMsg:  "invalid email format",
        },
        {
            name: "password too short",
            input: user.CreateInput{
                Email:    "test@example.com",
                Password: "short",
            },
            wantErr: true,
            errMsg:  "password must be at least 8 characters",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            user, err := user.NewUser(tt.input)

            if tt.wantErr {
                assert.Error(t, err)
                assert.Contains(t, err.Error(), tt.errMsg)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, user)
                assert.Equal(t, tt.input.Email, user.Email)
                // Verify password was hashed
                assert.NotEqual(t, tt.input.Password, user.PasswordHash)
            }
        })
    }
}

func TestUser_VerifyPassword(t *testing.T) {
    user, _ := user.NewUser(user.CreateInput{
        Email:    "test@example.com",
        Password: "SecurePass123!",
    })

    t.Run("correct password", func(t *testing.T) {
        valid := user.VerifyPassword("SecurePass123!")
        assert.True(t, valid)
    })

    t.Run("incorrect password", func(t *testing.T) {
        valid := user.VerifyPassword("WrongPassword")
        assert.False(t, valid)
    })
}
```

## Files to Create

Create `*_entity_test.go` for each domain:

### Warehouse Domain
- `internal/domain/warehouse/item/entity_test.go`
- `internal/domain/warehouse/location/entity_test.go`
- `internal/domain/warehouse/container/entity_test.go`
- `internal/domain/warehouse/inventory/entity_test.go`
- `internal/domain/warehouse/loan/entity_test.go`
- `internal/domain/warehouse/borrower/entity_test.go`

### Auth Domain
- `internal/domain/auth/user/entity_test.go`
- `internal/domain/auth/workspace/entity_test.go`
- `internal/domain/auth/member/entity_test.go`

## Estimated Effort

- **Time**: 8-10 hours
- **Tests to add**: 100-150

## Success Criteria

- [ ] All domain entities have entity test files
- [ ] Creation with valid inputs passes
- [ ] Validation errors are tested
- [ ] Edge cases (empty strings, max lengths, invalid formats) are covered
- [ ] Update operations are tested
- [ ] Business logic (state transitions, calculations) is tested
- [ ] Entity test coverage reaches 90%+

## Running Tests

```bash
# Test all entity files
go test ./internal/domain/warehouse/item -v -cover
go test ./internal/domain/warehouse/location -v -cover
go test ./internal/domain/auth/user -v -cover

# Test all entities in warehouse domain
go test ./internal/domain/warehouse/... -run TestNew -v

# Expected output per package
coverage: 90%+ of statements
```

## Next Steps

After completing entity tests, proceed to [1.3 Job Testing](1.3-job-testing.md).
