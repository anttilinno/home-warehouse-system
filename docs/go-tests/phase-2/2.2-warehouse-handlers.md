# Phase 2.2: Warehouse Domain Handlers

**Objective**: Add comprehensive HTTP handler tests for all 13 warehouse domain handlers

## Overview

Test all warehouse domain HTTP handlers following the pattern established in `category/handler_test.go`. Each handler should have tests for success paths, validation errors, not found scenarios, and edge cases.

## Handlers to Test

| Domain | File | Coverage Target | Priority | Test Count |
|--------|------|----------------|----------|------------|
| item | `item/handler_test.go` | 85% | HIGH | 15-20 |
| location | `location/handler_test.go` | 85% | HIGH | 15-20 |
| container | `container/handler_test.go` | 85% | HIGH | 15-20 |
| inventory | `inventory/handler_test.go` | 85% | HIGH | 15-20 |
| loan | `loan/handler_test.go` | 85% | HIGH | 20-25 |
| borrower | `borrower/handler_test.go` | 80% | MEDIUM | 12-15 |
| label | `label/handler_test.go` | 80% | MEDIUM | 10-12 |
| company | `company/handler_test.go` | 75% | MEDIUM | 10-12 |
| activity | `activity/handler_test.go` | 75% | MEDIUM | 8-10 |
| attachment | `attachment/handler_test.go` | 75% | MEDIUM | 12-15 |
| deleted | `deleted/handler_test.go` | 70% | LOW | 8-10 |
| favorite | `favorite/handler_test.go` | 70% | LOW | 8-10 |
| movement | `movement/handler_test.go` | 70% | LOW | 8-10 |

## Test Template

Use this template for each handler test file:

```go
package item_test

import (
    "context"
    "fmt"
    "net/http"
    "testing"

    "github.com/google/uuid"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"

    "github.com/antti/home-warehouse/go-backend/internal/domain/warehouse/item"
    "github.com/antti/home-warehouse/go-backend/internal/testutil"
)

// MockItemService implements item.Service interface
type MockItemService struct {
    mock.Mock
}

func (m *MockItemService) Create(ctx context.Context, workspaceID uuid.UUID, input item.CreateInput) (*item.Item, error) {
    args := m.Called(ctx, workspaceID, input)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*item.Item), args.Error(1)
}

func (m *MockItemService) GetByID(ctx context.Context, id, workspaceID uuid.UUID) (*item.Item, error) {
    args := m.Called(ctx, id, workspaceID)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*item.Item), args.Error(1)
}

func (m *MockItemService) List(ctx context.Context, workspaceID uuid.UUID, offset, limit int) ([]*item.Item, int, error) {
    args := m.Called(ctx, workspaceID, offset, limit)
    return args.Get(0).([]*item.Item), args.Int(1), args.Error(2)
}

func (m *MockItemService) Update(ctx context.Context, id, workspaceID uuid.UUID, input item.UpdateInput) (*item.Item, error) {
    args := m.Called(ctx, id, workspaceID, input)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*item.Item), args.Error(1)
}

func (m *MockItemService) Delete(ctx context.Context, id, workspaceID uuid.UUID) error {
    args := m.Called(ctx, id, workspaceID)
    return args.Error(0)
}

func (m *MockItemService) Search(ctx context.Context, workspaceID uuid.UUID, query string, offset, limit int) ([]*item.Item, int, error) {
    args := m.Called(ctx, workspaceID, query, offset, limit)
    return args.Get(0).([]*item.Item), args.Int(1), args.Error(2)
}

// Tests

func TestItemHandler_Create(t *testing.T) {
    setup := testutil.NewHandlerTestSetup()
    mockSvc := new(MockItemService)
    item.RegisterRoutes(setup.API, mockSvc)

    t.Run("creates item successfully", func(t *testing.T) {
        testItem := &item.Item{
            ID:          uuid.New(),
            WorkspaceID: setup.WorkspaceID,
            Name:        "Laptop",
            SKU:         "LAP-001",
        }

        mockSvc.On("Create", mock.Anything, setup.WorkspaceID, mock.MatchedBy(func(input item.CreateInput) bool {
            return input.Name == "Laptop" && input.SKU == "LAP-001"
        })).Return(testItem, nil)

        body := `{"name":"Laptop","sku":"LAP-001"}`
        rec := setup.Post(fmt.Sprintf("/workspaces/%s/items", setup.WorkspaceID), body)

        testutil.AssertStatus(t, rec, http.StatusCreated)
        response := testutil.ParseJSONResponse[item.Item](t, rec)
        assert.Equal(t, "Laptop", response.Name)
        mockSvc.AssertExpectations(t)
    })

    t.Run("returns 400 for invalid input", func(t *testing.T) {
        body := `{"name":""}` // Empty name
        rec := setup.Post(fmt.Sprintf("/workspaces/%s/items", setup.WorkspaceID), body)

        testutil.AssertErrorResponse(t, rec, http.StatusBadRequest, "name")
    })

    t.Run("returns 409 for duplicate SKU", func(t *testing.T) {
        mockSvc.On("Create", mock.Anything, setup.WorkspaceID, mock.Anything).
            Return(nil, item.ErrDuplicateSKU)

        body := `{"name":"Laptop","sku":"LAP-001"}`
        rec := setup.Post(fmt.Sprintf("/workspaces/%s/items", setup.WorkspaceID), body)

        testutil.AssertStatus(t, rec, http.StatusConflict)
    })
}

func TestItemHandler_List(t *testing.T) {
    setup := testutil.NewHandlerTestSetup()
    mockSvc := new(MockItemService)
    item.RegisterRoutes(setup.API, mockSvc)

    t.Run("lists items successfully", func(t *testing.T) {
        items := []*item.Item{
            {ID: uuid.New(), Name: "Item 1"},
            {ID: uuid.New(), Name: "Item 2"},
        }

        mockSvc.On("List", mock.Anything, setup.WorkspaceID, 0, 20).
            Return(items, 2, nil)

        rec := setup.Get(fmt.Sprintf("/workspaces/%s/items", setup.WorkspaceID))

        testutil.AssertStatus(t, rec, http.StatusOK)
        response := testutil.ParseJSONResponse[struct {
            Items []*item.Item `json:"items"`
            Total int          `json:"total"`
        }](t, rec)
        assert.Len(t, response.Items, 2)
        assert.Equal(t, 2, response.Total)
    })

    t.Run("handles pagination", func(t *testing.T) {
        mockSvc.On("List", mock.Anything, setup.WorkspaceID, 20, 10).
            Return([]*item.Item{}, 50, nil)

        rec := setup.Get(fmt.Sprintf("/workspaces/%s/items?offset=20&limit=10", setup.WorkspaceID))

        testutil.AssertStatus(t, rec, http.StatusOK)
    })
}

func TestItemHandler_Get(t *testing.T) {
    setup := testutil.NewHandlerTestSetup()
    mockSvc := new(MockItemService)
    item.RegisterRoutes(setup.API, mockSvc)

    t.Run("gets item by ID", func(t *testing.T) {
        itemID := uuid.New()
        testItem := &item.Item{
            ID:   itemID,
            Name: "Laptop",
        }

        mockSvc.On("GetByID", mock.Anything, itemID, setup.WorkspaceID).
            Return(testItem, nil)

        rec := setup.Get(fmt.Sprintf("/workspaces/%s/items/%s", setup.WorkspaceID, itemID))

        testutil.AssertStatus(t, rec, http.StatusOK)
        response := testutil.ParseJSONResponse[item.Item](t, rec)
        assert.Equal(t, itemID, response.ID)
    })

    t.Run("returns 404 when not found", func(t *testing.T) {
        itemID := uuid.New()

        mockSvc.On("GetByID", mock.Anything, itemID, setup.WorkspaceID).
            Return(nil, item.ErrNotFound)

        rec := setup.Get(fmt.Sprintf("/workspaces/%s/items/%s", setup.WorkspaceID, itemID))

        testutil.AssertStatus(t, rec, http.StatusNotFound)
    })
}

func TestItemHandler_Update(t *testing.T) {
    setup := testutil.NewHandlerTestSetup()
    mockSvc := new(MockItemService)
    item.RegisterRoutes(setup.API, mockSvc)

    t.Run("updates item successfully", func(t *testing.T) {
        itemID := uuid.New()
        updatedItem := &item.Item{
            ID:   itemID,
            Name: "Updated Laptop",
        }

        mockSvc.On("Update", mock.Anything, itemID, setup.WorkspaceID, mock.Anything).
            Return(updatedItem, nil)

        body := `{"name":"Updated Laptop"}`
        rec := setup.Patch(fmt.Sprintf("/workspaces/%s/items/%s", setup.WorkspaceID, itemID), body)

        testutil.AssertStatus(t, rec, http.StatusOK)
        response := testutil.ParseJSONResponse[item.Item](t, rec)
        assert.Equal(t, "Updated Laptop", response.Name)
    })

    t.Run("returns 404 when item not found", func(t *testing.T) {
        itemID := uuid.New()

        mockSvc.On("Update", mock.Anything, itemID, setup.WorkspaceID, mock.Anything).
            Return(nil, item.ErrNotFound)

        body := `{"name":"Updated"}`
        rec := setup.Patch(fmt.Sprintf("/workspaces/%s/items/%s", setup.WorkspaceID, itemID), body)

        testutil.AssertStatus(t, rec, http.StatusNotFound)
    })
}

func TestItemHandler_Delete(t *testing.T) {
    setup := testutil.NewHandlerTestSetup()
    mockSvc := new(MockItemService)
    item.RegisterRoutes(setup.API, mockSvc)

    t.Run("deletes item successfully", func(t *testing.T) {
        itemID := uuid.New()

        mockSvc.On("Delete", mock.Anything, itemID, setup.WorkspaceID).
            Return(nil)

        rec := setup.Delete(fmt.Sprintf("/workspaces/%s/items/%s", setup.WorkspaceID, itemID))

        testutil.AssertStatus(t, rec, http.StatusNoContent)
    })

    t.Run("returns 404 when item not found", func(t *testing.T) {
        itemID := uuid.New()

        mockSvc.On("Delete", mock.Anything, itemID, setup.WorkspaceID).
            Return(item.ErrNotFound)

        rec := setup.Delete(fmt.Sprintf("/workspaces/%s/items/%s", setup.WorkspaceID, itemID))

        testutil.AssertStatus(t, rec, http.StatusNotFound)
    })
}

func TestItemHandler_Search(t *testing.T) {
    setup := testutil.NewHandlerTestSetup()
    mockSvc := new(MockItemService)
    item.RegisterRoutes(setup.API, mockSvc)

    t.Run("searches items successfully", func(t *testing.T) {
        items := []*item.Item{
            {ID: uuid.New(), Name: "Laptop"},
        }

        mockSvc.On("Search", mock.Anything, setup.WorkspaceID, "laptop", 0, 20).
            Return(items, 1, nil)

        rec := setup.Get(fmt.Sprintf("/workspaces/%s/items/search?q=laptop", setup.WorkspaceID))

        testutil.AssertStatus(t, rec, http.StatusOK)
        response := testutil.ParseJSONResponse[struct {
            Items []*item.Item `json:"items"`
            Total int          `json:"total"`
        }](t, rec)
        assert.Len(t, response.Items, 1)
    })

    t.Run("handles empty search query", func(t *testing.T) {
        rec := setup.Get(fmt.Sprintf("/workspaces/%s/items/search?q=", setup.WorkspaceID))

        testutil.AssertErrorResponse(t, rec, http.StatusBadRequest, "query")
    })
}
```

## Handler-Specific Test Considerations

### Loan Handler
Additional test scenarios:
- Return loan operation
- Overdue loan filtering
- Due date validation
- State transitions

### Inventory Handler
Additional test scenarios:
- Condition enum validation
- Status enum validation
- Stock level updates
- Location/container assignment

### Location Handler
Additional test scenarios:
- Hierarchy validation
- Parent location references
- Path calculation
- Circular reference prevention

### Container Handler
Additional test scenarios:
- Container-location association
- Tag assignment (RFID/NFC/QR)
- Container capacity

### Attachment Handler
Additional test scenarios:
- File upload handling
- File download
- MIME type validation
- File size limits

## Files to Create

Create `*_handler_test.go` in each warehouse domain package:

- `internal/domain/warehouse/item/handler_test.go`
- `internal/domain/warehouse/location/handler_test.go`
- `internal/domain/warehouse/container/handler_test.go`
- `internal/domain/warehouse/inventory/handler_test.go`
- `internal/domain/warehouse/loan/handler_test.go`
- `internal/domain/warehouse/borrower/handler_test.go`
- `internal/domain/warehouse/label/handler_test.go`
- `internal/domain/warehouse/company/handler_test.go`
- `internal/domain/warehouse/activity/handler_test.go`
- `internal/domain/warehouse/attachment/handler_test.go`
- `internal/domain/warehouse/deleted/handler_test.go`
- `internal/domain/warehouse/favorite/handler_test.go`
- `internal/domain/warehouse/movement/handler_test.go`

## Estimated Effort

- **Time**: 25-30 hours
- **Tests to add**: 130-160

## Success Criteria

- [ ] All 13 warehouse handlers have comprehensive tests
- [ ] CRUD operations (Create, List, Get, Update, Delete) are tested
- [ ] Search/filter endpoints are tested where applicable
- [ ] Validation errors return correct status codes
- [ ] Not found scenarios return 404
- [ ] Mock services are used for all tests
- [ ] Coverage for handlers reaches 85%+

## Running Tests

```bash
# Test all warehouse handlers
go test ./internal/domain/warehouse/.../handler_test.go -v -cover

# Test specific handler
go test ./internal/domain/warehouse/item -run TestItemHandler -v -cover

# Expected output per domain
coverage: 85%+ of statements
```

## Next Steps

After completing warehouse handlers, proceed to [2.3 Auth Domain Handlers](2.3-auth-handlers.md).
