# Phase 2.1: Create Handler Test Infrastructure

**Objective**: Build shared test utilities for handler testing across all domains

## Overview

Before implementing handler tests for 22 handlers, we need to create reusable test infrastructure that simplifies HTTP testing with Huma and Chi.

## Shared Test Utilities

Create `internal/testutil/handler.go` with common handler test helpers:

```go
package testutil

import (
    "context"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"

    "github.com/danielgtaylor/huma/v2"
    "github.com/danielgtaylor/huma/v2/adapters/humachi"
    "github.com/go-chi/chi/v5"
    "github.com/google/uuid"
    "github.com/stretchr/testify/assert"

    appMiddleware "github.com/antti/home-warehouse/go-backend/internal/api/middleware"
)

// HandlerTestSetup provides common test infrastructure for handler tests
type HandlerTestSetup struct {
    Router      *chi.Mux
    API         huma.API
    WorkspaceID uuid.UUID
    UserID      uuid.UUID
}

// NewHandlerTestSetup creates a new test setup with injected workspace context
func NewHandlerTestSetup() *HandlerTestSetup {
    r := chi.NewRouter()
    workspaceID := uuid.MustParse("00000000-0000-0000-0000-000000000001")
    userID := uuid.MustParse("00000000-0000-0000-0000-000000000002")

    // Inject workspace and user context middleware for testing
    r.Use(func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
            ctx := req.Context()
            ctx = context.WithValue(ctx, appMiddleware.WorkspaceContextKey, workspaceID)
            ctx = context.WithValue(ctx, appMiddleware.UserContextKey, userID)
            next.ServeHTTP(w, req.WithContext(ctx))
        })
    })

    config := huma.DefaultConfig("Test API", "1.0.0")
    api := humachi.New(r, config)

    return &HandlerTestSetup{
        Router:      r,
        API:         api,
        WorkspaceID: workspaceID,
        UserID:      userID,
    }
}

// Request makes an HTTP request with JSON body
func (h *HandlerTestSetup) Request(method, path, body string) *httptest.ResponseRecorder {
    req := httptest.NewRequest(method, path, strings.NewReader(body))
    req.Header.Set("Content-Type", "application/json")
    rec := httptest.NewRecorder()
    h.Router.ServeHTTP(rec, req)
    return rec
}

// Get makes a GET request
func (h *HandlerTestSetup) Get(path string) *httptest.ResponseRecorder {
    return h.Request("GET", path, "")
}

// Post makes a POST request with JSON body
func (h *HandlerTestSetup) Post(path, body string) *httptest.ResponseRecorder {
    return h.Request("POST", path, body)
}

// Put makes a PUT request with JSON body
func (h *HandlerTestSetup) Put(path, body string) *httptest.ResponseRecorder {
    return h.Request("PUT", path, body)
}

// Patch makes a PATCH request with JSON body
func (h *HandlerTestSetup) Patch(path, body string) *httptest.ResponseRecorder {
    return h.Request("PATCH", path, body)
}

// Delete makes a DELETE request
func (h *HandlerTestSetup) Delete(path string) *httptest.ResponseRecorder {
    return h.Request("DELETE", path, "")
}

// ParseJSONResponse parses the response body as JSON into the given type
func ParseJSONResponse[T any](t *testing.T, rec *httptest.ResponseRecorder) T {
    var result T
    err := json.Unmarshal(rec.Body.Bytes(), &result)
    assert.NoError(t, err, "Failed to parse response body")
    return result
}

// AssertStatus asserts the response status code
func AssertStatus(t *testing.T, rec *httptest.ResponseRecorder, expected int) {
    assert.Equal(t, expected, rec.Code, "Response body: %s", rec.Body.String())
}

// AssertJSON asserts that the response contains the expected JSON (partial match)
func AssertJSON(t *testing.T, rec *httptest.ResponseRecorder, expected map[string]interface{}) {
    var actual map[string]interface{}
    err := json.Unmarshal(rec.Body.Bytes(), &actual)
    assert.NoError(t, err)

    for key, expectedValue := range expected {
        actualValue, exists := actual[key]
        assert.True(t, exists, "Expected key %s not found in response", key)
        assert.Equal(t, expectedValue, actualValue, "Value mismatch for key %s", key)
    }
}

// AssertErrorResponse asserts that the response is an error with the expected message
func AssertErrorResponse(t *testing.T, rec *httptest.ResponseRecorder, expectedStatus int, expectedMsg string) {
    AssertStatus(t, rec, expectedStatus)

    var errResp struct {
        Error   string `json:"error"`
        Message string `json:"message"`
    }
    err := json.Unmarshal(rec.Body.Bytes(), &errResp)
    assert.NoError(t, err)

    if expectedMsg != "" {
        assert.Contains(t, errResp.Message, expectedMsg)
    }
}
```

## Usage Example

```go
package item_test

import (
    "fmt"
    "net/http"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"

    "github.com/antti/home-warehouse/go-backend/internal/domain/warehouse/item"
    "github.com/antti/home-warehouse/go-backend/internal/testutil"
)

func TestItemHandler_Create(t *testing.T) {
    setup := testutil.NewHandlerTestSetup()
    mockSvc := new(MockItemService)

    // Register routes with mock service
    item.RegisterRoutes(setup.API, mockSvc)

    t.Run("creates item successfully", func(t *testing.T) {
        testItem := &item.Item{
            ID:          uuid.New(),
            WorkspaceID: setup.WorkspaceID,
            Name:        "Laptop",
            SKU:         "LAP-001",
        }

        mockSvc.On("Create", mock.Anything, mock.Anything).Return(testItem, nil)

        body := `{"name":"Laptop","sku":"LAP-001"}`
        rec := setup.Post("/items", body)

        testutil.AssertStatus(t, rec, http.StatusCreated)

        response := testutil.ParseJSONResponse[item.Item](t, rec)
        assert.Equal(t, "Laptop", response.Name)
        assert.Equal(t, "LAP-001", response.SKU)

        mockSvc.AssertExpectations(t)
    })

    t.Run("returns 400 for invalid input", func(t *testing.T) {
        body := `{"name":""}`  // Invalid: empty name
        rec := setup.Post("/items", body)

        testutil.AssertErrorResponse(t, rec, http.StatusBadRequest, "name is required")
    })
}
```

## Mock Service Helper

Create a base mock helper in `internal/testutil/mock.go`:

```go
package testutil

import (
    "github.com/stretchr/testify/mock"
)

// BaseMockService provides common mock functionality
type BaseMockService struct {
    mock.Mock
}

// Reset clears all mock expectations
func (m *BaseMockService) Reset() {
    m.ExpectedCalls = nil
    m.Calls = nil
}
```

## Files to Create

- `internal/testutil/handler.go` (new) - Handler test utilities
- `internal/testutil/mock.go` (new) - Mock service helpers

## Benefits

1. **Consistency**: All handler tests follow the same pattern
2. **Simplicity**: Reduces boilerplate in each handler test
3. **Maintainability**: Changes to test setup only need to be made once
4. **Type Safety**: Generic `ParseJSONResponse` provides type-safe parsing
5. **Better Assertions**: Helper functions provide clear, readable assertions

## Estimated Effort

- **Time**: 2 hours
- **Lines of code**: ~200

## Success Criteria

- [ ] `HandlerTestSetup` provides easy HTTP request testing
- [ ] Workspace and user context are automatically injected
- [ ] JSON parsing and assertions are type-safe
- [ ] Error response assertions are simple and clear
- [ ] Mock service patterns are established

## Next Steps

After creating test infrastructure:
1. [2.2 Warehouse Domain Handlers](2.2-warehouse-handlers.md) (13 handlers)
2. [2.3 Auth Domain Handlers](2.3-auth-handlers.md) (4 handlers)
3. [2.4 Top-Level Domain Handlers](2.4-toplevel-handlers.md) (5 handlers)
