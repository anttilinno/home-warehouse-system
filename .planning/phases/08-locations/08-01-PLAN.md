---
phase: 08-locations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/sync/sync-manager.ts
  - frontend/app/[locale]/(dashboard)/dashboard/locations/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a location while offline and see it appear immediately with pending badge"
    - "User can update location details while offline and see changes immediately"
    - "User can create a child location under a pending parent while offline"
    - "Pending location rows show parent name context (e.g., Pending... under Garage)"
    - "Pending location mutations sync in correct parent-before-child order"
  artifacts:
    - path: "frontend/lib/sync/sync-manager.ts"
      provides: "topologicalSortLocations function and processQueue integration"
      contains: "topologicalSortLocations"
    - path: "frontend/app/[locale]/(dashboard)/dashboard/locations/page.tsx"
      provides: "Offline mutation hooks, optimistic UI, pending indicators"
      contains: "useOfflineMutation"
  key_links:
    - from: "locations/page.tsx"
      to: "sync-manager.ts"
      via: "syncManager.subscribe for MUTATION_SYNCED events"
      pattern: "syncManager\\.subscribe"
    - from: "locations/page.tsx handleSave"
      to: "useOfflineMutation"
      via: "createLocationOffline with dependsOn"
      pattern: "createLocationOffline.*dependsOn"
    - from: "sync-manager.ts processQueue"
      to: "topologicalSortLocations"
      via: "entityType === 'locations' condition"
      pattern: "entityType === 'locations'"
---

<objective>
Add offline mutation support for locations with parent-child hierarchy handling

Purpose: Enable users to create and update locations while offline, with correct sync ordering for hierarchical relationships using topological sort

Output: Locations page with optimistic UI for offline creates/updates, pending badges with parent context, and topological sort for locations sync ordering
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-locations/08-RESEARCH.md
@.planning/phases/07-categories/07-01-SUMMARY.md
@frontend/lib/sync/sync-manager.ts
@frontend/app/[locale]/(dashboard)/dashboard/locations/page.tsx
@frontend/app/[locale]/(dashboard)/dashboard/categories/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add topologicalSortLocations to sync-manager</name>
  <files>frontend/lib/sync/sync-manager.ts</files>
  <action>
Add `topologicalSortLocations` function directly below the existing `topologicalSortCategories` function. This is a copy of the categories function with one change: use `parent_location` field instead of `parent_category_id`.

```typescript
export function topologicalSortLocations(mutations: MutationQueueEntry[]): MutationQueueEntry[] {
  // Only sort create operations (updates don't create new IDs)
  const creates = mutations.filter(m => m.operation === 'create');
  const updates = mutations.filter(m => m.operation === 'update');

  if (creates.length <= 1) return [...creates, ...updates];

  // Build dependency graph from parent_location references
  const indegree = new Map<string, number>();
  const children = new Map<string, string[]>();

  // Initialize
  for (const m of creates) {
    indegree.set(m.idempotencyKey, 0);
    children.set(m.idempotencyKey, []);
  }

  // Build edges from parent references where parent is also a pending create
  const keySet = new Set(creates.map(m => m.idempotencyKey));
  for (const m of creates) {
    const parentId = m.payload.parent_location as string | null;
    if (parentId && keySet.has(parentId)) {
      indegree.set(m.idempotencyKey, (indegree.get(m.idempotencyKey) || 0) + 1);
      children.get(parentId)!.push(m.idempotencyKey);
    }
  }

  // Kahn's algorithm: start with nodes with indegree 0
  const queue = creates.filter(m => indegree.get(m.idempotencyKey) === 0);
  const sorted: MutationQueueEntry[] = [];

  while (queue.length > 0) {
    const m = queue.shift()!;
    sorted.push(m);
    for (const childKey of children.get(m.idempotencyKey) || []) {
      const newDegree = (indegree.get(childKey) || 1) - 1;
      indegree.set(childKey, newDegree);
      if (newDegree === 0) {
        const child = creates.find(c => c.idempotencyKey === childKey);
        if (child) queue.push(child);
      }
    }
  }

  return [...sorted, ...updates];
}
```

Then update the `processQueue` method's entity processing loop to apply topological sort for locations:

Find the section that checks `if (entityType === 'categories')` and add an `else if` for locations:

```typescript
// Apply topological sort for hierarchical entities
let sortedMutations: MutationQueueEntry[];
if (entityType === 'categories') {
  sortedMutations = topologicalSortCategories(mutations);
} else if (entityType === 'locations') {
  sortedMutations = topologicalSortLocations(mutations);
} else {
  sortedMutations = mutations;
}
```
  </action>
  <verify>
Run `cd frontend && bun run typecheck` - should pass with no errors related to sync-manager.ts
  </verify>
  <done>
topologicalSortLocations function exists and processQueue applies it for locations entity type
  </done>
</task>

<task type="auto">
  <name>Task 2: Add offline mutation support to locations page</name>
  <files>frontend/app/[locale]/(dashboard)/dashboard/locations/page.tsx</files>
  <action>
Follow the exact pattern from categories/page.tsx to add offline mutation support. Make these changes:

**1. Add imports:**
```typescript
import { Cloud } from "lucide-react";  // Add to existing lucide imports
import { useOfflineMutation } from "@/lib/hooks/use-offline-mutation";
import { syncManager } from "@/lib/sync/sync-manager";
import type { SyncEvent } from "@/lib/sync/sync-manager";
```

**2. Extend LocationTreeItem interface:**
```typescript
interface LocationTreeItem extends Location {
  children: LocationTreeItem[];
  expanded?: boolean;
  _pending?: boolean;  // Add this
}
```

**3. Add optimistic state (after existing state declarations, around line 305):**
```typescript
// Optimistic locations for offline mutations
const [optimisticLocations, setOptimisticLocations] = useState<(Location & { _pending?: boolean })[]>([]);
```

**4. Add offline mutation hooks (after optimisticLocations state):**
```typescript
// Offline mutation hooks
const { mutate: createLocationOffline } = useOfflineMutation<Record<string, unknown>>({
  entity: 'locations',
  operation: 'create',
  onMutate: (payload, tempId, dependsOn) => {
    const optimisticLocation: Location & { _pending: boolean } = {
      id: tempId,
      workspace_id: workspaceId!,
      name: (payload.name as string) || '',
      description: (payload.description as string) || null,
      parent_location: (payload.parent_location as string) || null,
      short_code: (payload.short_code as string) || null,
      zone: null,
      shelf: null,
      bin: null,
      is_archived: false,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      _pending: true,
    };
    setOptimisticLocations(prev => [...prev, optimisticLocation]);
  },
});

const { mutate: updateLocationOffline } = useOfflineMutation<Record<string, unknown>>({
  entity: 'locations',
  operation: 'update',
  onMutate: (payload, _tempId) => {
    const entityId = payload._entityId as string;
    if (entityId) {
      setOptimisticLocations(prev => {
        const existing = prev.find(l => l.id === entityId);
        if (existing) {
          return prev.map(l => l.id === entityId ? { ...l, ...payload, _pending: true } : l);
        }
        const fromFetched = locations.find(l => l.id === entityId);
        if (fromFetched) {
          return [...prev, { ...fromFetched, ...payload, _pending: true }];
        }
        return prev;
      });
    }
  },
});
```

**5. Add mergedLocations useMemo (BEFORE the tree useMemo):**
```typescript
// Merge fetched locations with optimistic locations
const mergedLocations = useMemo(() => {
  const fetchedIds = new Set(locations.map(l => l.id));
  const merged = locations.map(l => {
    const optimistic = optimisticLocations.find(o => o.id === l.id);
    if (optimistic) return { ...l, ...optimistic, _pending: true };
    return l;
  });
  const newOptimistic = optimisticLocations.filter(o => !fetchedIds.has(o.id));
  return [...merged, ...newOptimistic];
}, [locations, optimisticLocations]);
```

**6. Update tree useMemo to use mergedLocations:**
Change `if (locations.length === 0)` to `if (mergedLocations.length === 0)`
Change `buildLocationTree(locations)` to `buildLocationTree(mergedLocations)`

**7. Add sync event subscription useEffect (after loadLocations useEffect):**
```typescript
// Subscribe to sync events for offline mutation completion
useEffect(() => {
  if (!syncManager) return;

  const handleSyncEvent = (event: SyncEvent) => {
    if (event.type === 'MUTATION_SYNCED' && event.payload?.mutation?.entity === 'locations') {
      const syncedKey = event.payload.mutation.idempotencyKey;
      const entityId = event.payload.mutation.entityId;
      setOptimisticLocations(prev => prev.filter(l => l.id !== syncedKey && l.id !== entityId));
      loadLocations();
    }
    if (event.type === 'MUTATION_FAILED' && event.payload?.mutation?.entity === 'locations') {
      toast.error('Failed to sync location', {
        description: event.payload.mutation.lastError || 'Please try again',
      });
    }
  };

  return syncManager.subscribe(handleSyncEvent);
}, [loadLocations]);
```

**8. Update handleSave function to use offline mutations:**
Replace the try block content with:
```typescript
if (editingLocation) {
  // Update existing location - use offline mutation
  const updatePayload: Record<string, unknown> = {
    name: formName.trim(),
    description: formDescription.trim() || null,
    parent_location: formParentId || null,
    _entityId: editingLocation.id,
  };
  await updateLocationOffline(updatePayload, editingLocation.id);
  toast.success(navigator.onLine ? "Location updated" : "Location update queued");
} else {
  // Create new location - use offline mutation
  // Check if parent is a pending optimistic location
  const parentIsPending = formParentId && optimisticLocations.some(
    l => l.id === formParentId && l._pending
  );
  const dependsOn = parentIsPending ? [formParentId] : undefined;

  const createPayload: Record<string, unknown> = {
    name: formName.trim(),
    description: formDescription.trim() || null,
    parent_location: formParentId || null,
    short_code: formShortCode || undefined,
  };
  await createLocationOffline(createPayload, undefined, dependsOn);
  toast.success(navigator.onLine ? "Location created" : "Location queued for sync");
}

setDialogOpen(false);
// Remove loadLocations() call - sync event will trigger reload
```
Remove the existing `loadLocations()` call after setDialogOpen since sync events handle this.

**9. Update getAvailableParents to include optimistic locations:**
Replace the function with:
```typescript
const getAvailableParents = (): (Location & { _pending?: boolean })[] => {
  const allLocations = [...locations, ...optimisticLocations.filter(o => !locations.some(l => l.id === o.id))];

  if (!editingLocation) return allLocations.filter(loc => !loc.is_archived);

  const descendantIds = new Set<string>();
  const findDescendants = (parentId: string) => {
    descendantIds.add(parentId);
    allLocations
      .filter((loc) => loc.parent_location === parentId)
      .forEach((loc) => findDescendants(loc.id));
  };
  findDescendants(editingLocation.id);

  return allLocations.filter(
    (loc) => !descendantIds.has(loc.id) && !loc.is_archived
  );
};
```

**10. Update parent dropdown in dialog to show "(pending)" suffix:**
Change the SelectItem for parent locations from:
```typescript
{getAvailableParents().map((loc) => (
  <SelectItem key={loc.id} value={loc.id}>
    {loc.name}
  </SelectItem>
))}
```
To:
```typescript
{getAvailableParents().map((loc) => (
  <SelectItem key={loc.id} value={loc.id}>
    {loc.name}{'_pending' in loc && loc._pending ? ' (pending)' : ''}
  </SelectItem>
))}
```

**11. Update LocationRow component to accept allLocations prop and show pending badge:**

Add to LocationRow props:
```typescript
allLocations: (Location & { _pending?: boolean })[];
```

Add getParentName helper inside LocationRow:
```typescript
const getParentName = (parentId: string | null): string | null => {
  if (!parentId) return null;
  const parent = allLocations.find(l => l.id === parentId);
  return parent?.name || null;
};
```

Add pending styling to the row div className:
```typescript
className={cn(
  "flex items-center gap-2 py-2 px-3 hover:bg-muted/50 rounded-lg group",
  location.is_archived && "opacity-60",
  location._pending && "bg-amber-50"  // Add this
)}
```

Add pending badge after the name in the flex-1 div, inside the flex items-center gap-2 div:
```typescript
<div className="flex items-center gap-2">
  <div className="font-medium truncate">{location.name}</div>
  {location.short_code && (
    <Badge variant="outline" className="text-xs font-mono">
      {location.short_code}
    </Badge>
  )}
  {location._pending && (
    <Badge variant="outline" className="text-xs text-amber-600 border-amber-300 shrink-0">
      <Cloud className="w-3 h-3 mr-1 animate-pulse" />
      {(() => {
        if (!location.parent_location) return 'Pending';
        const parentName = getParentName(location.parent_location);
        return parentName ? `Pending... under ${parentName}` : 'Pending';
      })()}
    </Badge>
  )}
  {location.is_archived && (
    <Badge variant="secondary" className="text-xs">
      Archived
    </Badge>
  )}
</div>
```

Wrap DropdownMenu in conditional to hide for pending locations:
```typescript
{!location._pending && (
  <DropdownMenu>
    {/* existing dropdown content */}
  </DropdownMenu>
)}
```

**12. Pass allLocations to LocationRow in both render locations:**
Update the LocationRow usages in the main render and in the recursive children render:
```typescript
allLocations={mergedLocations}
```

For the recursive children render inside LocationRow, pass allLocations through:
```typescript
<LocationRow
  key={child.id}
  location={child}
  level={level + 1}
  onEdit={onEdit}
  onDelete={onDelete}
  onArchive={onArchive}
  onToggle={onToggle}
  onAddSublocation={onAddSublocation}
  allLocations={allLocations}
/>
```

**13. Update filteredTree useMemo to use mergedLocations:**
The tree is already built from mergedLocations (step 6), so filteredTree should work correctly. But ensure the location type in the filter function accepts `_pending`.
  </action>
  <verify>
Run `cd frontend && bun run typecheck` - should pass with no TypeScript errors

Run `cd frontend && bun run lint` - should pass or only have unrelated warnings
  </verify>
  <done>
Locations page has offline mutation support with optimistic UI, pending badges showing parent context, and hidden dropdown menu for pending locations
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd frontend && bun run typecheck`
2. Lint passes: `cd frontend && bun run lint`
3. Manual verification (if dev server running):
   - Go offline (DevTools Network tab)
   - Create a location - should appear immediately with "Pending" badge
   - Create a child location under pending parent - should show "Pending... under [ParentName]"
   - The dropdown menu should not appear for pending locations
   - Go online - pending badges should disappear after sync
</verification>

<success_criteria>
- topologicalSortLocations function exists in sync-manager.ts
- processQueue applies topological sort for locations entity type
- Locations page creates/updates locations using offline mutation hooks
- Pending locations show amber background and Cloud badge with context text
- Parent dropdown shows "(pending)" suffix for optimistic locations
- Dropdown menu (edit, archive, delete) is hidden for pending locations
- Sync events trigger cleanup of optimistic state and reload
</success_criteria>

<output>
After completion, create `.planning/phases/08-locations/08-01-SUMMARY.md`
</output>
