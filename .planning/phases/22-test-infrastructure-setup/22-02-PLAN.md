---
phase: 22-test-infrastructure-setup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/vitest.config.ts
  - frontend/lib/test-utils/index.ts
  - frontend/lib/test-utils/factories.ts
  - frontend/lib/test-utils/offline-mock.ts
  - frontend/lib/test-utils/sync-mock.ts
  - frontend/lib/test-utils/render.tsx
  - frontend/vitest.setup.ts
autonomous: true

must_haves:
  truths:
    - "Running bun run test:unit produces coverage report"
    - "Coverage shows line, branch, function, and statement percentages"
    - "Tests can mock offline state with provided utility"
    - "Tests can mock pending mutations with provided utility"
    - "Entity factories create valid typed test data"
  artifacts:
    - path: "frontend/vitest.config.ts"
      provides: "Vitest configuration with V8 coverage"
      contains: "provider: \"v8\""
    - path: "frontend/lib/test-utils/factories.ts"
      provides: "Entity factory functions"
      exports: ["createItem", "createLocation", "createContainer", "createBorrower", "createCategory"]
    - path: "frontend/lib/test-utils/offline-mock.ts"
      provides: "Offline state mocking utilities"
      exports: ["mockOfflineState", "mockOnline", "mockOffline", "resetOfflineMocks"]
    - path: "frontend/lib/test-utils/sync-mock.ts"
      provides: "Sync/mutation mocking utilities"
      exports: ["mockPendingMutations", "mockSyncManager", "resetSyncMocks"]
    - path: "frontend/package.json"
      provides: "Dev dependencies for coverage"
      contains: "@vitest/coverage-v8"
  key_links:
    - from: "frontend/vitest.config.ts"
      to: "@vitest/coverage-v8"
      via: "coverage provider configuration"
      pattern: "coverage.*provider.*v8"
    - from: "frontend/lib/test-utils/offline-mock.ts"
      to: "frontend/lib/db/offline-db.ts"
      via: "vi.mock for offline-db"
      pattern: "vi\\.mock.*offline-db"
    - from: "frontend/lib/test-utils/sync-mock.ts"
      to: "frontend/lib/sync/mutation-queue.ts"
      via: "vi.mock for mutation-queue"
      pattern: "vi\\.mock.*mutation-queue"
---

<objective>
Install @vitest/coverage-v8 and create reusable test utilities for frontend unit testing, including entity factories and offline/sync mocking utilities.

Purpose: Enable Phase 25 frontend tests to mock offline state and sync behavior without boilerplate. Provides coverage reporting to track progress toward 80% target. Extracts patterns from existing `offline-search.test.ts` into reusable utilities.

Output: Coverage-enabled vitest config, `frontend/lib/test-utils/` with factories and mocking utilities, and `bun run test:unit` command that produces coverage.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-test-infrastructure-setup/22-RESEARCH.md

# Existing test patterns to extract from
@frontend/lib/search/__tests__/offline-search.test.ts
@frontend/vitest.config.ts
@frontend/lib/db/offline-db.ts
@frontend/lib/sync/mutation-queue.ts
@frontend/lib/types/items.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @vitest/coverage-v8 and configure coverage</name>
  <files>
    frontend/package.json
    frontend/vitest.config.ts
    frontend/vitest.setup.ts
  </files>
  <action>
1. Install coverage provider:
   ```bash
   cd frontend && bun add -D @vitest/coverage-v8
   ```

2. Update `frontend/vitest.config.ts` to add coverage configuration:

```typescript
import { defineConfig } from "vitest/config";
import path from "path";

export default defineConfig({
  test: {
    globals: true,
    environment: "jsdom",
    include: ["lib/**/__tests__/**/*.test.ts", "components/**/__tests__/**/*.test.tsx"],
    exclude: ["node_modules", "e2e"],
    setupFiles: ["./vitest.setup.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "html", "json", "lcov"],
      reportsDirectory: "./coverage",
      include: [
        "lib/**/*.ts",
        "lib/**/*.tsx",
        "components/**/*.tsx",
        "hooks/**/*.ts",
      ],
      exclude: [
        "**/*.d.ts",
        "**/types/**",
        "**/__tests__/**",
        "**/node_modules/**",
        "lib/test-utils/**",
      ],
      // Thresholds will be enforced after Phase 25 reaches targets
      // thresholds: { lines: 80, functions: 80, branches: 80, statements: 80 },
    },
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "."),
    },
  },
});
```

3. Create `frontend/vitest.setup.ts` (or update if exists):

```typescript
import { beforeEach, afterEach, vi } from "vitest";

// Reset all mocks between tests
beforeEach(() => {
  vi.clearAllMocks();
});

afterEach(() => {
  vi.resetAllMocks();
});
```

4. Add npm scripts to `package.json`:
   - `"test:unit": "vitest run"`
   - `"test:unit:watch": "vitest"`
   - `"test:unit:coverage": "vitest run --coverage"`
  </action>
  <verify>
    ```bash
    cd frontend && bun run test:unit:coverage 2>&1 | head -50
    ```
    Should show coverage percentages for each file.
  </verify>
  <done>Coverage report generates showing line/branch/function/statement percentages for lib/ and components/</done>
</task>

<task type="auto">
  <name>Task 2: Create entity factory utilities</name>
  <files>
    frontend/lib/test-utils/index.ts
    frontend/lib/test-utils/factories.ts
  </files>
  <action>
Create `frontend/lib/test-utils/` directory with factory functions.

1. Create `frontend/lib/test-utils/factories.ts`:

Extract and generalize factory patterns from `offline-search.test.ts`:

```typescript
import type { Item } from "@/lib/types/items";
import type { Location } from "@/lib/types/locations";
import type { Container } from "@/lib/types/containers";
import type { Borrower } from "@/lib/types/borrowers";
import type { Category } from "@/lib/api/categories";
import type { MutationQueueEntry } from "@/lib/db/types";

let idCounter = 0;

export function resetFactoryCounters() {
  idCounter = 0;
}

export function createItem(partial: Partial<Item> = {}): Item {
  const id = `item-${++idCounter}`;
  return {
    id,
    workspace_id: "ws-test",
    sku: partial.sku ?? `SKU-${idCounter}`,
    name: partial.name ?? `Test Item ${idCounter}`,
    min_stock_level: 0,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    ...partial,
  };
}

export function createLocation(partial: Partial<Location> = {}): Location {
  const id = `location-${++idCounter}`;
  return {
    id,
    workspace_id: "ws-test",
    name: partial.name ?? `Test Location ${idCounter}`,
    is_archived: false,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    ...partial,
  };
}

export function createContainer(partial: Partial<Container> = {}): Container {
  const id = `container-${++idCounter}`;
  return {
    id,
    workspace_id: "ws-test",
    name: partial.name ?? `Test Container ${idCounter}`,
    location_id: partial.location_id ?? "location-1",
    is_archived: false,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    ...partial,
  };
}

export function createBorrower(partial: Partial<Borrower> = {}): Borrower {
  const id = `borrower-${++idCounter}`;
  return {
    id,
    workspace_id: "ws-test",
    name: partial.name ?? `Test Borrower ${idCounter}`,
    is_archived: false,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    ...partial,
  };
}

export function createCategory(partial: Partial<Category> = {}): Category {
  const id = `category-${++idCounter}`;
  return {
    id,
    name: partial.name ?? `Test Category ${idCounter}`,
    parent_category_id: null,
    description: null,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    ...partial,
  };
}

export function createMutationEntry(
  partial: Partial<MutationQueueEntry> = {}
): MutationQueueEntry {
  return {
    id: partial.id ?? ++idCounter,
    idempotencyKey: partial.idempotencyKey ?? `key-${idCounter}`,
    operation: partial.operation ?? "create",
    entity: partial.entity ?? "items",
    entityId: partial.entityId,
    payload: partial.payload ?? {},
    timestamp: partial.timestamp ?? Date.now(),
    retries: 0,
    status: "pending",
    ...partial,
  };
}
```

2. Create `frontend/lib/test-utils/index.ts`:

```typescript
export * from "./factories";
export * from "./offline-mock";
export * from "./sync-mock";
```
  </action>
  <verify>
    ```bash
    cd frontend && npx tsc --noEmit lib/test-utils/factories.ts
    ```
  </verify>
  <done>Factory functions type-check and create valid typed entities</done>
</task>

<task type="auto">
  <name>Task 3: Create offline and sync mocking utilities</name>
  <files>
    frontend/lib/test-utils/offline-mock.ts
    frontend/lib/test-utils/sync-mock.ts
  </files>
  <action>
1. Create `frontend/lib/test-utils/offline-mock.ts`:

```typescript
import { vi } from "vitest";
import type { Item } from "@/lib/types/items";
import type { Location } from "@/lib/types/locations";
import type { Container } from "@/lib/types/containers";
import type { Borrower } from "@/lib/types/borrowers";
import type { Category } from "@/lib/api/categories";

// Store for mock data
let mockData: {
  items: Item[];
  locations: Location[];
  containers: Container[];
  borrowers: Borrower[];
  categories: Category[];
} = {
  items: [],
  locations: [],
  containers: [],
  borrowers: [],
  categories: [],
};

/**
 * Mock offline-db.getAll to return specified data
 * Must be called BEFORE importing modules that use offline-db
 */
export function mockOfflineState(data: {
  items?: Item[];
  locations?: Location[];
  containers?: Container[];
  borrowers?: Borrower[];
  categories?: Category[];
}) {
  mockData = {
    items: data.items ?? [],
    locations: data.locations ?? [],
    containers: data.containers ?? [],
    borrowers: data.borrowers ?? [],
    categories: data.categories ?? [],
  };
}

/**
 * Get the mock implementation for offline-db.getAll
 * Use with: vi.mocked(offlineDb.getAll).mockImplementation(getOfflineDbMockImpl())
 */
export function getOfflineDbMockImpl() {
  return async (store: string) => {
    switch (store) {
      case "items":
        return mockData.items;
      case "locations":
        return mockData.locations;
      case "containers":
        return mockData.containers;
      case "borrowers":
        return mockData.borrowers;
      case "categories":
        return mockData.categories;
      default:
        return [];
    }
  };
}

/**
 * Mock navigator.onLine to return true
 */
export function mockOnline() {
  Object.defineProperty(navigator, "onLine", {
    value: true,
    writable: true,
    configurable: true,
  });
}

/**
 * Mock navigator.onLine to return false
 */
export function mockOffline() {
  Object.defineProperty(navigator, "onLine", {
    value: false,
    writable: true,
    configurable: true,
  });
}

/**
 * Reset all offline mocks
 */
export function resetOfflineMocks() {
  mockData = {
    items: [],
    locations: [],
    containers: [],
    borrowers: [],
    categories: [],
  };
  // Reset navigator.onLine to true
  Object.defineProperty(navigator, "onLine", {
    value: true,
    writable: true,
    configurable: true,
  });
}
```

2. Create `frontend/lib/test-utils/sync-mock.ts`:

```typescript
import { vi } from "vitest";
import type { MutationQueueEntry } from "@/lib/db/types";

let mockPendingMutations: MutationQueueEntry[] = [];

/**
 * Set up pending mutations for tests
 */
export function mockPendingMutations(mutations: MutationQueueEntry[]) {
  mockPendingMutations = mutations;
}

/**
 * Get the mock implementation for mutation-queue.getPendingMutations
 * Use with: vi.mocked(mutationQueue.getPendingMutations).mockImplementation(getPendingMutationsMockImpl())
 */
export function getPendingMutationsMockImpl() {
  return async () => mockPendingMutations;
}

/**
 * Create a mock sync manager with controllable behavior
 */
export function createMockSyncManager() {
  return {
    sync: vi.fn().mockResolvedValue({ success: true, synced: 0, failed: 0 }),
    getStatus: vi.fn().mockReturnValue({ pending: 0, syncing: false }),
    subscribe: vi.fn().mockReturnValue(() => {}),
    processMutation: vi.fn().mockResolvedValue({ success: true }),
  };
}

/**
 * Reset all sync mocks
 */
export function resetSyncMocks() {
  mockPendingMutations = [];
}
```

These utilities allow tests to:
- Set up IndexedDB state without actual IndexedDB
- Mock online/offline status
- Control pending mutations for sync tests
  </action>
  <verify>
    ```bash
    cd frontend && npx tsc --noEmit lib/test-utils/offline-mock.ts lib/test-utils/sync-mock.ts
    ```
  </verify>
  <done>Offline and sync mocking utilities type-check and export all required functions</done>
</task>

</tasks>

<verification>
1. `cd frontend && bun run test:unit:coverage` produces coverage report with percentages
2. `lib/test-utils/` exports all factory and mock functions
3. Existing tests in `lib/search/__tests__/` still pass
4. Coverage HTML report viewable at `frontend/coverage/index.html`
</verification>

<success_criteria>
1. @vitest/coverage-v8 installed and configured
2. Coverage reports show line/branch/function/statement percentages
3. Factory functions create typed test entities
4. Mock utilities available for offline state and sync behavior
5. `bun run test:unit:coverage` command works
</success_criteria>

<output>
After completion, create `.planning/phases/22-test-infrastructure-setup/22-02-SUMMARY.md`
</output>
