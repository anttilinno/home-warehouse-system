---
phase: 22-test-infrastructure-setup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/internal/testutil/factory/factory.go
  - backend/internal/testutil/factory/item.go
  - backend/internal/testutil/factory/location.go
  - backend/internal/testutil/factory/container.go
  - backend/internal/testutil/factory/inventory.go
  - backend/internal/testutil/factory/user.go
  - backend/internal/testutil/factory/workspace.go
  - backend/internal/testutil/factory/category.go
  - backend/internal/testutil/factory/borrower.go
  - backend/go.mod
autonomous: true

must_haves:
  truths:
    - "Test can create an item with one factory call"
    - "Test can create a location with one factory call"
    - "Test can create a container with one factory call"
    - "Test can create inventory with one factory call"
    - "Factory provides sensible defaults for all required fields"
    - "Factory allows customization via functional options"
  artifacts:
    - path: "backend/internal/testutil/factory/factory.go"
      provides: "Factory struct with workspace/user context"
      contains: "type Factory struct"
    - path: "backend/internal/testutil/factory/item.go"
      provides: "Item factory with options"
      exports: ["Item", "ItemOpt", "WithItemName", "WithItemSKU", "WithItemCategory"]
    - path: "backend/internal/testutil/factory/location.go"
      provides: "Location factory with options"
      exports: ["Location", "LocationOpt", "WithLocationName", "WithLocationParent"]
    - path: "backend/internal/testutil/factory/container.go"
      provides: "Container factory with options"
      exports: ["Container", "ContainerOpt", "WithContainerName", "WithContainerLocation"]
    - path: "backend/internal/testutil/factory/inventory.go"
      provides: "Inventory factory with options"
      exports: ["Inventory", "InventoryOpt", "WithInventoryItem", "WithInventoryLocation"]
  key_links:
    - from: "backend/internal/testutil/factory/*.go"
      to: "backend/internal/domain/*"
      via: "domain entity constructors"
      pattern: "(item|location|container|inventory)\\.(New|Create)"
    - from: "backend/internal/testutil/factory/factory.go"
      to: "github.com/brianvoe/gofakeit/v7"
      via: "import for fake data"
      pattern: "gofakeit"
---

<objective>
Create Go test factories for all common warehouse entities using the builder pattern with functional options.

Purpose: Enable Phase 23-24 tests to create test entities with one factory call, reducing boilerplate and ensuring consistent test data. Factories use gofakeit for realistic fake data and follow patterns established in existing testutil package.

Output: `backend/internal/testutil/factory/` package with factories for Item, Location, Container, Inventory, User, Workspace, Category, and Borrower entities.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-test-infrastructure-setup/22-RESEARCH.md

# Existing test infrastructure
@backend/internal/testutil/handler.go
@backend/internal/domain/warehouse/item/item.go
@backend/internal/domain/warehouse/location/location.go
@backend/internal/domain/warehouse/container/container.go
@backend/internal/domain/warehouse/inventory/inventory.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add gofakeit dependency and create factory base</name>
  <files>
    backend/go.mod
    backend/internal/testutil/factory/factory.go
  </files>
  <action>
1. Add gofakeit dependency:
   ```bash
   cd backend && go get github.com/brianvoe/gofakeit/v7
   ```

2. Create `backend/internal/testutil/factory/factory.go`:
   - Define `Factory` struct holding `workspaceID` and `userID` (uuid.UUID)
   - Default workspace ID: `uuid.MustParse("00000000-0000-0000-0000-000000000001")`
   - Default user ID: `uuid.MustParse("00000000-0000-0000-0000-000000000002")`
   - `func New() *Factory` - creates factory with defaults
   - `func (f *Factory) WithWorkspace(id uuid.UUID) *Factory` - fluent setter
   - `func (f *Factory) WithUser(id uuid.UUID) *Factory` - fluent setter
   - `func (f *Factory) WorkspaceID() uuid.UUID` - getter
   - `func (f *Factory) UserID() uuid.UUID` - getter

Follow builder pattern from research document. Use `gofakeit` for generating realistic test data.
  </action>
  <verify>
    ```bash
    cd backend && go build ./internal/testutil/factory/...
    ```
  </verify>
  <done>Factory base compiles with gofakeit imported and workspace/user context methods available</done>
</task>

<task type="auto">
  <name>Task 2: Create entity factories for core warehouse entities</name>
  <files>
    backend/internal/testutil/factory/user.go
    backend/internal/testutil/factory/workspace.go
    backend/internal/testutil/factory/category.go
    backend/internal/testutil/factory/borrower.go
    backend/internal/testutil/factory/item.go
    backend/internal/testutil/factory/location.go
    backend/internal/testutil/factory/container.go
    backend/internal/testutil/factory/inventory.go
  </files>
  <action>
Create factory files for each entity type. Each file follows this pattern:

```go
package factory

type ItemOpt func(*item.Item)

func (f *Factory) Item(opts ...ItemOpt) *item.Item {
    // Create with gofakeit defaults
    i, err := item.NewItem(f.workspaceID, gofakeit.ProductName(), gofakeit.LetterN(8), 0)
    if err != nil {
        panic(err) // Factory should never fail with valid defaults
    }
    for _, opt := range opts {
        opt(i)
    }
    return i
}

func WithItemName(name string) ItemOpt {
    return func(i *item.Item) { /* apply name */ }
}
```

**Required factories:**

1. `user.go`: User entity with email, full_name, password_hash
   - Options: WithEmail, WithFullName, WithSuperuser

2. `workspace.go`: Workspace entity with name, slug, description
   - Options: WithWorkspaceName, WithSlug, WithDescription

3. `category.go`: Category entity with name, parent_category_id, description
   - Options: WithCategoryName, WithParentCategory, WithCategoryDescription

4. `borrower.go`: Borrower entity with name, email, phone
   - Options: WithBorrowerName, WithBorrowerEmail, WithBorrowerPhone

5. `item.go`: Item entity with name, sku, category_id, brand, model
   - Options: WithItemName, WithItemSKU, WithItemCategory, WithItemBrand, WithItemModel

6. `location.go`: Location entity with name, parent_location_id, zone, short_code
   - Options: WithLocationName, WithLocationParent, WithLocationZone, WithLocationShortCode

7. `container.go`: Container entity with name, location_id, short_code
   - Options: WithContainerName, WithContainerLocation, WithContainerShortCode

8. `inventory.go`: Inventory entity with item_id, location_id, container_id, condition, status
   - Options: WithInventoryItem, WithInventoryLocation, WithInventoryContainer, WithInventoryCondition, WithInventoryStatus

Use domain entity constructors (e.g., `item.NewItem()`) - do NOT construct raw structs. Use gofakeit for realistic defaults: `gofakeit.ProductName()`, `gofakeit.LetterN(8)`, `gofakeit.Email()`, `gofakeit.PhoneFormatted()`, etc.
  </action>
  <verify>
    ```bash
    cd backend && go build ./internal/testutil/factory/... && go vet ./internal/testutil/factory/...
    ```
  </verify>
  <done>All 8 entity factories compile and use domain constructors with gofakeit data generation</done>
</task>

<task type="auto">
  <name>Task 3: Add factory unit tests and verify usage pattern</name>
  <files>
    backend/internal/testutil/factory/factory_test.go
  </files>
  <action>
Create `backend/internal/testutil/factory/factory_test.go` with tests demonstrating the factory usage pattern:

```go
package factory_test

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/antti/home-warehouse/go-backend/internal/testutil/factory"
)

func TestFactory_Item(t *testing.T) {
    f := factory.New()

    // Default item has valid name, SKU, workspace
    item := f.Item()
    assert.NotEmpty(t, item.Name())
    assert.NotEmpty(t, item.SKU())
    assert.Equal(t, f.WorkspaceID(), item.WorkspaceID())
}

func TestFactory_ItemWithOptions(t *testing.T) {
    f := factory.New()

    item := f.Item(
        factory.WithItemName("Power Drill"),
        factory.WithItemSKU("PD-001"),
    )
    assert.Equal(t, "Power Drill", item.Name())
    assert.Equal(t, "PD-001", item.SKU())
}
```

Test each entity factory:
1. Creates valid entity with defaults
2. Options override specific fields
3. Custom workspace/user context propagates

Include at least 3 tests per entity type to ensure coverage.
  </action>
  <verify>
    ```bash
    cd backend && go test -v ./internal/testutil/factory/...
    ```
  </verify>
  <done>All factory tests pass, demonstrating one-call entity creation with customizable options</done>
</task>

</tasks>

<verification>
1. `cd backend && go test -v ./internal/testutil/factory/...` passes all tests
2. Each entity can be created with `f.Item()`, `f.Location()`, etc. - no additional setup required
3. Options like `WithItemName()` allow field customization
4. Factories use domain constructors, not raw struct initialization
</verification>

<success_criteria>
1. Go test can create any entity with one factory call
2. Factories generate realistic fake data via gofakeit
3. All factories compile and tests pass
4. Code follows existing testutil patterns
</success_criteria>

<output>
After completion, create `.planning/phases/22-test-infrastructure-setup/22-01-SUMMARY.md`
</output>
