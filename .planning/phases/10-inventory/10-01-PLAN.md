---
phase: 10-inventory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can create inventory record while offline and see it appear immediately with pending badge"
    - "User can update inventory details while offline and see changes immediately"
    - "Pending inventory rows show item + location context (e.g., 'Pending... Drill at Garage')"
    - "Global sync status indicator includes inventory pending count"
  artifacts:
    - path: "frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx"
      provides: "Offline mutation support for inventory with multi-entity dependency tracking"
      contains: "useOfflineMutation"
  key_links:
    - from: "frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx"
      to: "frontend/lib/hooks/use-offline-mutation.ts"
      via: "useOfflineMutation hook import"
      pattern: "useOfflineMutation.*entity.*inventory"
    - from: "inventory page optimistic state"
      to: "sync-manager"
      via: "syncManager.subscribe for MUTATION_SYNCED events"
      pattern: "syncManager\\.subscribe"
---

<objective>
Add offline mutation support to inventory page with multi-entity dependency tracking

Purpose: Enable users to create/update inventory records while offline with optimistic UI and automatic sync. Inventory has the most complex dependency structure (item, location, optional container) requiring triple-entity tracking.

Output: Updated inventory page with offline create/update mutations, pending indicators showing item + location context, and proper dependsOn chains for all three reference entities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-containers/09-01-SUMMARY.md
@frontend/app/[locale]/(dashboard)/dashboard/containers/page.tsx (pattern reference)
@frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx (target file)
@frontend/lib/hooks/use-offline-mutation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add offline mutation infrastructure to inventory page</name>
  <files>frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx</files>
  <action>
Add offline mutation infrastructure following the containers page pattern:

1. **Add imports:**
   - `Cloud` icon from lucide-react
   - `useOfflineMutation`, `getPendingMutationsForEntity` from "@/lib/hooks/use-offline-mutation"
   - `syncManager` and `SyncEvent` from "@/lib/sync/sync-manager"
   - `cn` from "@/lib/utils" (if not already imported)

2. **Add optimistic state arrays** (after existing useState declarations around line 432-467):
   ```typescript
   // Optimistic state for offline mutations
   const [optimisticInventory, setOptimisticInventory] = useState<(Inventory & { _pending?: boolean })[]>([]);
   const [optimisticItems, setOptimisticItems] = useState<(Item & { _pending?: boolean })[]>([]);
   const [optimisticLocations, setOptimisticLocations] = useState<(Location & { _pending?: boolean })[]>([]);
   const [optimisticContainers, setOptimisticContainers] = useState<(Container & { _pending?: boolean })[]>([]);
   ```

3. **Add offline mutation hooks** (after optimistic state):
   ```typescript
   // Offline mutation hooks
   const { mutate: createInventoryOffline } = useOfflineMutation<Record<string, unknown>>({
     entity: 'inventory',
     operation: 'create',
     onMutate: (payload, tempId) => {
       const optimisticInv: Inventory & { _pending: boolean } = {
         id: tempId,
         workspace_id: workspaceId!,
         item_id: (payload.item_id as string) || '',
         location_id: (payload.location_id as string) || '',
         container_id: (payload.container_id as string) || null,
         quantity: (payload.quantity as number) || 1,
         condition: (payload.condition as InventoryCondition) || 'GOOD',
         status: (payload.status as InventoryStatus) || 'AVAILABLE',
         notes: (payload.notes as string) || null,
         is_archived: false,
         created_at: new Date().toISOString(),
         updated_at: new Date().toISOString(),
         _pending: true,
       };
       setOptimisticInventory(prev => [...prev, optimisticInv]);
     },
   });

   const { mutate: updateInventoryOffline } = useOfflineMutation<Record<string, unknown>>({
     entity: 'inventory',
     operation: 'update',
     onMutate: (payload, _tempId) => {
       const entityId = payload._entityId as string;
       if (entityId) {
         setOptimisticInventory(prev => {
           const existing = prev.find(i => i.id === entityId);
           if (existing) {
             return prev.map(i => i.id === entityId ? { ...i, ...payload, _pending: true } : i);
           }
           const fromFetched = inventories.find(i => i.id === entityId);
           if (fromFetched) {
             return [...prev, { ...fromFetched, ...payload, _pending: true }];
           }
           return prev;
         });
       }
     },
   });
   ```

4. **Add sync event subscription** (add useEffect for sync events):
   ```typescript
   // Subscribe to sync events for offline mutation completion
   useEffect(() => {
     if (!syncManager) return;

     const handleSyncEvent = (event: SyncEvent) => {
       if (event.type === 'MUTATION_SYNCED' && event.payload?.mutation?.entity === 'inventory') {
         const syncedKey = event.payload.mutation.idempotencyKey;
         const entityId = event.payload.mutation.entityId;
         setOptimisticInventory(prev => prev.filter(i => i.id !== syncedKey && i.id !== entityId));
         refetch();
       }
       // Also handle items, locations, containers syncing
       if (event.type === 'MUTATION_SYNCED' && event.payload?.mutation?.entity === 'items') {
         const syncedKey = event.payload.mutation.idempotencyKey;
         const entityId = event.payload.mutation.entityId;
         setOptimisticItems(prev => prev.filter(i => i.id !== syncedKey && i.id !== entityId));
       }
       if (event.type === 'MUTATION_SYNCED' && event.payload?.mutation?.entity === 'locations') {
         const syncedKey = event.payload.mutation.idempotencyKey;
         const entityId = event.payload.mutation.entityId;
         setOptimisticLocations(prev => prev.filter(l => l.id !== syncedKey && l.id !== entityId));
       }
       if (event.type === 'MUTATION_SYNCED' && event.payload?.mutation?.entity === 'containers') {
         const syncedKey = event.payload.mutation.idempotencyKey;
         const entityId = event.payload.mutation.entityId;
         setOptimisticContainers(prev => prev.filter(c => c.id !== syncedKey && c.id !== entityId));
       }
       if (event.type === 'MUTATION_FAILED' && event.payload?.mutation?.entity === 'inventory') {
         toast.error('Failed to sync inventory', {
           description: event.payload.mutation.lastError || 'Please try again',
         });
       }
     };

     return syncManager.subscribe(handleSyncEvent);
   }, [refetch]);
   ```

5. **Load pending mutations on mount** for all reference entities:
   ```typescript
   // Load pending creates for items, locations, containers on mount
   useEffect(() => {
     async function loadPendingEntities() {
       const [pendingItemMutations, pendingLocationMutations, pendingContainerMutations] = await Promise.all([
         getPendingMutationsForEntity('items'),
         getPendingMutationsForEntity('locations'),
         getPendingMutationsForEntity('containers'),
       ]);

       // Process pending items
       const pendingItems = pendingItemMutations
         .filter(m => m.operation === 'create')
         .map(m => ({
           id: m.idempotencyKey,
           workspace_id: workspaceId || '',
           sku: (m.payload.sku as string) || '',
           name: (m.payload.name as string) || '',
           description: (m.payload.description as string) || null,
           category_id: (m.payload.category_id as string) || null,
           brand: (m.payload.brand as string) || null,
           model: (m.payload.model as string) || null,
           min_stock_level: 0,
           created_at: new Date().toISOString(),
           updated_at: new Date().toISOString(),
           _pending: true,
         } as Item & { _pending: boolean }));
       setOptimisticItems(pendingItems);

       // Process pending locations
       const pendingLocations = pendingLocationMutations
         .filter(m => m.operation === 'create')
         .map(m => ({
           id: m.idempotencyKey,
           workspace_id: workspaceId || '',
           name: (m.payload.name as string) || '',
           description: (m.payload.description as string) || null,
           parent_location: (m.payload.parent_location as string) || null,
           short_code: (m.payload.short_code as string) || null,
           zone: null,
           shelf: null,
           bin: null,
           is_archived: false,
           created_at: new Date().toISOString(),
           updated_at: new Date().toISOString(),
           _pending: true,
         } as Location & { _pending: boolean }));
       setOptimisticLocations(pendingLocations);

       // Process pending containers
       const pendingContainers = pendingContainerMutations
         .filter(m => m.operation === 'create')
         .map(m => ({
           id: m.idempotencyKey,
           workspace_id: workspaceId || '',
           name: (m.payload.name as string) || '',
           description: (m.payload.description as string) || null,
           location_id: (m.payload.location_id as string) || '',
           capacity: (m.payload.capacity as string) || null,
           short_code: (m.payload.short_code as string) || null,
           is_archived: false,
           created_at: new Date().toISOString(),
           updated_at: new Date().toISOString(),
           _pending: true,
         } as Container & { _pending: boolean }));
       setOptimisticContainers(pendingContainers);
     }
     loadPendingEntities();
   }, [workspaceId]);
   ```

6. **Create merged data arrays** (add useMemo for merging):
   ```typescript
   // Merge fetched data with optimistic data
   const allItems = useMemo(() => {
     const fetchedIds = new Set(items.map(i => i.id));
     return [...items, ...optimisticItems.filter(o => !fetchedIds.has(o.id))];
   }, [items, optimisticItems]);

   const allLocations = useMemo(() => {
     const fetchedIds = new Set(locations.map(l => l.id));
     return [...locations, ...optimisticLocations.filter(o => !fetchedIds.has(o.id))];
   }, [locations, optimisticLocations]);

   const allContainers = useMemo(() => {
     const fetchedIds = new Set(containers.map(c => c.id));
     return [...containers, ...optimisticContainers.filter(o => !fetchedIds.has(o.id))];
   }, [containers, optimisticContainers]);

   // Merge fetched inventory with optimistic inventory
   const mergedInventories = useMemo(() => {
     const fetchedIds = new Set(inventories.map(i => i.id));
     const merged = inventories.map(inv => {
       const optimistic = optimisticInventory.find(o => o.id === inv.id);
       if (optimistic) return { ...inv, ...optimistic, _pending: true };
       return inv;
     });
     const newOptimistic = optimisticInventory.filter(o => !fetchedIds.has(o.id));
     return [...merged, ...newOptimistic];
   }, [inventories, optimisticInventory]);
   ```

7. **Update getItemName, getLocationName, getContainerName** to use merged arrays:
   - Change `items.find` to `allItems.find`
   - Change `locations.find` to `allLocations.find`
   - Change `containers.find` to `allContainers.find`

8. **Update filteredInventories** useMemo to use `mergedInventories` instead of `inventories`.

9. **Update handleSave function** to use offline mutations:
   ```typescript
   const handleSave = async () => {
     if (!workspaceId) return;

     if (!formItemId || !formLocationId || formQuantity < 1) {
       toast.error("Please fill in required fields", {
         description: "Item, Location, and Quantity (>=1) are required",
       });
       return;
     }

     try {
       setIsSaving(true);

       // Collect dependsOn for pending entities
       const dependsOn: string[] = [];
       const itemIsPending = optimisticItems.some(i => i.id === formItemId && i._pending);
       const locationIsPending = optimisticLocations.some(l => l.id === formLocationId && l._pending);
       const containerIsPending = formContainerId && optimisticContainers.some(c => c.id === formContainerId && c._pending);

       if (itemIsPending) dependsOn.push(formItemId);
       if (locationIsPending) dependsOn.push(formLocationId);
       if (containerIsPending) dependsOn.push(formContainerId!);

       const createPayload: Record<string, unknown> = {
         item_id: formItemId,
         location_id: formLocationId,
         container_id: formContainerId || undefined,
         quantity: formQuantity,
         condition: formCondition,
         status: formStatus,
         notes: formNotes || undefined,
       };
       await createInventoryOffline(createPayload, undefined, dependsOn.length > 0 ? dependsOn : undefined);
       toast.success(navigator.onLine ? "Inventory created" : "Inventory queued for sync");

       setDialogOpen(false);
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : "Failed to save inventory";
       toast.error("Failed to save inventory", {
         description: errorMessage,
       });
     } finally {
       setIsSaving(false);
     }
   };
   ```

Note: For inline edit handlers (handleUpdateQuantity, handleUpdateCondition, handleUpdateStatus), these should also use offline mutations, but they require the existing entityId. Use the updateInventoryOffline hook with the inventory id.
  </action>
  <verify>
    TypeScript compilation: `cd frontend && npx tsc --noEmit` passes without errors
    File contains useOfflineMutation imports and calls
    File contains optimisticInventory, optimisticItems, optimisticLocations, optimisticContainers state
  </verify>
  <done>
    Offline mutation hooks integrated
    Optimistic state arrays created for inventory and all three reference entities
    Sync event subscription handles inventory and reference entity mutations
    Pending entity loading on mount for items, locations, containers
    Merged data arrays created for all entities
    handleSave uses createInventoryOffline with proper dependsOn chains
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pending indicator UI and conditional rendering</name>
  <files>frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx</files>
  <action>
Add pending indicator UI following the containers pattern:

1. **Update item dropdown in dialog** to show pending items:
   Change the items.map to allItems:
   ```typescript
   {allItems.map((item) => (
     <SelectItem key={item.id} value={item.id}>
       {item.name} ({item.sku}){'_pending' in item && item._pending ? ' (pending)' : ''}
     </SelectItem>
   ))}
   ```

2. **Update location dropdown in dialog** to show pending locations:
   Change the locations.map to allLocations:
   ```typescript
   {allLocations.map((loc) => (
     <SelectItem key={loc.id} value={loc.id}>
       {loc.name}{'_pending' in loc && loc._pending ? ' (pending)' : ''}
     </SelectItem>
   ))}
   ```

3. **Update container dropdown in dialog** to show pending containers:
   Change the containers filtering to use allContainers:
   ```typescript
   {allContainers
     .filter(c => !formLocationId || c.location_id === formLocationId)
     .map((container) => (
       <SelectItem key={container.id} value={container.id}>
         {container.name}{'_pending' in container && container._pending ? ' (pending)' : ''}
       </SelectItem>
     ))}
   ```

4. **Add pending badge in table rows** (in the virtual scrolling TableRow):
   In the item name cell, after the item name div, add:
   ```typescript
   {'_pending' in inventory && inventory._pending && (
     <Badge variant="outline" className="text-xs text-amber-600 border-amber-300 shrink-0 ml-2">
       <Cloud className="w-3 h-3 mr-1 animate-pulse" />
       {(() => {
         const itemName = getItemName(inventory.item_id);
         const locationName = getLocationName(inventory.location_id);
         const containerName = inventory.container_id ? getContainerName(inventory.container_id) : null;
         const locationContext = containerName ? `${locationName} / ${containerName}` : locationName;
         return `Pending... ${itemName} at ${locationContext}`;
       })()}
     </Badge>
   )}
   ```

5. **Add amber background for pending rows**:
   Update the TableRow className to include conditional amber background:
   ```typescript
   <TableRow
     key={inventory.id}
     className={cn('_pending' in inventory && inventory._pending && "bg-amber-50")}
     style={{...}}
   >
   ```

6. **Disable checkbox for pending rows**:
   Add disabled prop to the checkbox in table rows:
   ```typescript
   <Checkbox
     checked={isSelected(inventory.id)}
     onCheckedChange={() => toggleSelection(inventory.id)}
     disabled={'_pending' in inventory && inventory._pending}
     aria-label={`Select ${getItemName(inventory.item_id)}`}
   />
   ```

7. **Hide dropdown menu for pending rows**:
   Wrap the DropdownMenu in the actions column with conditional rendering:
   ```typescript
   {!('_pending' in inventory && inventory._pending) && (
     <DropdownMenu>
       ...existing dropdown content...
     </DropdownMenu>
   )}
   ```

8. **Update the select all checkbox** to exclude pending items:
   In the header checkbox onCheckedChange:
   ```typescript
   selectAll(sortedInventories.filter(i => !('_pending' in i && i._pending)).map((i) => i.id))
   ```

9. **Disable inline editing for pending rows**:
   For InlineEditCell and InlineEditSelect components in pending rows, either:
   - Wrap them in conditional rendering showing static text for pending
   - Or add a disabled prop if supported

   For quantity InlineEditCell:
   ```typescript
   {'_pending' in inventory && inventory._pending ? (
     <span className="font-medium">{inventory.quantity}</span>
   ) : (
     <InlineEditCell ... />
   )}
   ```

   Same pattern for condition and status InlineEditSelect components.

10. **Update the flattenedInventories** useMemo to include _pending flag:
    ```typescript
    const flattenedInventories = useMemo(() => {
      return filteredInventories.map(inv => ({
        ...inv,
        item_name: getItemName(inv.item_id),
        item_sku: getItemSKU(inv.item_id),
        location_name: getLocationName(inv.location_id),
        container_name: getContainerName(inv.container_id) || '',
        _pending: '_pending' in inv ? (inv._pending as boolean | undefined) : undefined,
      }));
    }, [filteredInventories, allItems, allLocations, allContainers]);
    ```
  </action>
  <verify>
    Dev server starts without errors: `cd frontend && bun run dev`
    Manual test: Go offline, create inventory, see pending badge with item + location context
    Manual test: Pending inventory rows have amber background
    Manual test: Pending inventory rows have no dropdown menu
    Manual test: Item/location/container dropdowns show pending entities with "(pending)" suffix
  </verify>
  <done>
    Pending badge shows "Pending... [ItemName] at [LocationName] / [ContainerName]" format
    Amber background on pending inventory rows
    Dropdown menu hidden for pending inventory
    Bulk selection checkbox disabled for pending inventory
    Inline editing disabled for pending rows
    All three dropdowns (item, location, container) show pending entities with "(pending)" suffix
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Dev server starts successfully
3. Offline create: Go offline, create inventory record, see pending badge with full context
4. Offline update: Go offline, edit inventory (quantity/condition/status), see pending state
5. Pending UI: Amber background, no dropdown menu, disabled checkbox for pending rows
6. Dropdowns: Show pending items/locations/containers with "(pending)" suffix
7. Online sync: Go back online, pending indicator disappears, inventory persists
</verification>

<success_criteria>
- User can create inventory while offline with immediate optimistic display
- User can see "Pending... [ItemName] at [LocationName]" badge on pending inventory
- Pending inventory shows context with container when assigned (e.g., "Pending... Drill at Garage / Shelf A")
- Pending rows have amber-50 background
- Pending rows have no dropdown menu
- Pending rows have disabled bulk selection
- Item/location/container dropdowns show pending entities with "(pending)" suffix
- Inventory syncs when online returns
</success_criteria>

<output>
After completion, create `.planning/phases/10-inventory/10-01-SUMMARY.md`
</output>
