---
phase: 21-mobile-form-improvements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/components/ui/collapsible.tsx
  - frontend/lib/db/offline-db.ts
  - frontend/lib/db/types.ts
  - frontend/lib/hooks/use-form-draft.ts
  - frontend/lib/hooks/use-smart-defaults.ts
  - frontend/lib/hooks/use-ios-keyboard.ts
autonomous: true

must_haves:
  truths:
    - "Form drafts persist to IndexedDB and can be recovered"
    - "Smart defaults remember last 5 selections per field"
    - "iOS keyboard detection works via Visual Viewport API"
    - "Collapsible component is available for progressive disclosure"
  artifacts:
    - path: "frontend/components/ui/collapsible.tsx"
      provides: "Radix UI Collapsible wrapper"
      contains: "CollapsibleTrigger"
    - path: "frontend/lib/db/offline-db.ts"
      provides: "formDrafts store in DB_VERSION 4"
      contains: "formDrafts"
    - path: "frontend/lib/hooks/use-form-draft.ts"
      provides: "Draft persistence hook"
      exports: ["useFormDraft"]
    - path: "frontend/lib/hooks/use-smart-defaults.ts"
      provides: "Recent selection memory"
      exports: ["useSmartDefaults"]
    - path: "frontend/lib/hooks/use-ios-keyboard.ts"
      provides: "Visual Viewport keyboard detection"
      exports: ["useIOSKeyboard"]
  key_links:
    - from: "frontend/lib/hooks/use-form-draft.ts"
      to: "frontend/lib/db/offline-db.ts"
      via: "getDB import"
      pattern: "import.*getDB.*from.*offline-db"
---

<objective>
Create mobile form infrastructure: IndexedDB draft persistence, smart defaults, iOS keyboard handling, and Collapsible UI component.

Purpose: Establish the foundational hooks and database schema that all mobile form improvements depend on. This enables FORM-07 (draft recovery) and provides infrastructure for FORM-01 (progressive disclosure).

Output: Four new hooks (useFormDraft, useSmartDefaults, useIOSKeyboard) and the Collapsible UI component, plus IndexedDB schema upgrade to DB_VERSION 4.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-mobile-form-improvements/21-RESEARCH.md

@frontend/lib/db/offline-db.ts
@frontend/lib/db/types.ts
@frontend/lib/hooks/use-haptic.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Collapsible UI component and IndexedDB formDrafts store</name>
  <files>
    frontend/components/ui/collapsible.tsx
    frontend/lib/db/offline-db.ts
    frontend/lib/db/types.ts
  </files>
  <action>
1. Install @radix-ui/react-collapsible via bun:
   `cd frontend && bun add @radix-ui/react-collapsible`

2. Create collapsible.tsx using shadcn pattern:
   - Export Collapsible, CollapsibleTrigger, CollapsibleContent from @radix-ui/react-collapsible
   - Follow same pattern as existing Radix UI components in the project

3. Update types.ts to add FormDraft interface:
   ```typescript
   export interface FormDraft {
     id: string;
     formType: string;
     data: Record<string, unknown>;
     savedAt: number;
   }
   ```

4. Add formDrafts to OfflineDBSchema:
   ```typescript
   formDrafts: {
     key: string;
     value: FormDraft;
   };
   ```

5. Update offline-db.ts:
   - Bump DB_VERSION from 3 to 4
   - Add migration for formDrafts store in upgrade handler:
   ```typescript
   if (oldVersion < 4) {
     if (!db.objectStoreNames.contains("formDrafts")) {
       db.createObjectStore("formDrafts", { keyPath: "id" });
     }
   }
   ```
  </action>
  <verify>
    - `bun run build` in frontend succeeds
    - TypeScript compilation passes with new types
  </verify>
  <done>
    - Collapsible component exists with Radix UI exports
    - FormDraft interface defined in types.ts
    - formDrafts store added to OfflineDBSchema
    - DB_VERSION is 4 with migration for formDrafts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useFormDraft hook for IndexedDB draft persistence</name>
  <files>frontend/lib/hooks/use-form-draft.ts</files>
  <action>
Create use-form-draft.ts hook following research Pattern 4:

```typescript
"use client";

import { useEffect, useCallback, useRef } from "react";
import { getDB } from "@/lib/db/offline-db";
import type { FormDraft } from "@/lib/db/types";

const DEBOUNCE_MS = 1000;

export function useFormDraft<T extends Record<string, unknown>>(
  formType: string,
  draftId: string
) {
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Load draft from IndexedDB
  const loadDraft = useCallback(async (): Promise<T | null> => {
    try {
      const db = await getDB();
      const draft = await db.get("formDrafts", draftId);
      if (draft && draft.formType === formType) {
        return draft.data as T;
      }
      return null;
    } catch (error) {
      console.warn("[FormDraft] Failed to load:", error);
      return null;
    }
  }, [draftId, formType]);

  // Save draft with debounce
  const saveDraft = useCallback(
    (data: Partial<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(async () => {
        try {
          const db = await getDB();
          const draft: FormDraft = {
            id: draftId,
            formType,
            data: data as Record<string, unknown>,
            savedAt: Date.now(),
          };
          await db.put("formDrafts", draft);
        } catch (error) {
          console.warn("[FormDraft] Failed to save:", error);
        }
      }, DEBOUNCE_MS);
    },
    [draftId, formType]
  );

  // Clear draft on successful submit
  const clearDraft = useCallback(async () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    try {
      const db = await getDB();
      await db.delete("formDrafts", draftId);
    } catch (error) {
      console.warn("[FormDraft] Failed to clear:", error);
    }
  }, [draftId]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return { loadDraft, saveDraft, clearDraft };
}
```

Key features:
- 1-second debounce on saves to prevent IndexedDB thrashing
- Graceful error handling (console.warn, don't throw)
- formType validation on load to prevent loading wrong form's data
- Cleanup of pending timeout on unmount
  </action>
  <verify>
    - TypeScript compilation passes
    - Hook exports { loadDraft, saveDraft, clearDraft }
  </verify>
  <done>useFormDraft hook exists with load, save, clear functions and 1s debounce</done>
</task>

<task type="auto">
  <name>Task 3: Create useSmartDefaults and useIOSKeyboard hooks</name>
  <files>
    frontend/lib/hooks/use-smart-defaults.ts
    frontend/lib/hooks/use-ios-keyboard.ts
  </files>
  <action>
1. Create use-smart-defaults.ts for remembering recent selections:

```typescript
"use client";

import { useCallback } from "react";

const STORAGE_KEY_PREFIX = "hws-smart-defaults-";
const MAX_RECENT = 5;

interface RecentSelection {
  value: string;
  label?: string;
  usedAt: number;
}

export function useSmartDefaults(fieldKey: string) {
  const storageKey = `${STORAGE_KEY_PREFIX}${fieldKey}`;

  // Get recent selections for a field
  const getRecent = useCallback((): RecentSelection[] => {
    if (typeof localStorage === "undefined") return [];
    try {
      const stored = localStorage.getItem(storageKey);
      if (!stored) return [];
      return JSON.parse(stored) as RecentSelection[];
    } catch {
      return [];
    }
  }, [storageKey]);

  // Get the most recent selection (for default value)
  const getDefault = useCallback((): string | null => {
    const recent = getRecent();
    return recent.length > 0 ? recent[0].value : null;
  }, [getRecent]);

  // Record a selection
  const recordSelection = useCallback(
    (value: string, label?: string) => {
      if (typeof localStorage === "undefined") return;
      try {
        const recent = getRecent().filter((r) => r.value !== value);
        recent.unshift({ value, label, usedAt: Date.now() });
        const trimmed = recent.slice(0, MAX_RECENT);
        localStorage.setItem(storageKey, JSON.stringify(trimmed));
      } catch {
        // Ignore localStorage errors
      }
    },
    [storageKey, getRecent]
  );

  // Clear history for this field
  const clearHistory = useCallback(() => {
    if (typeof localStorage === "undefined") return;
    try {
      localStorage.removeItem(storageKey);
    } catch {
      // Ignore
    }
  }, [storageKey]);

  return { getRecent, getDefault, recordSelection, clearHistory };
}
```

2. Create use-ios-keyboard.ts following research Pattern 5:

```typescript
"use client";

import { useState, useEffect, useCallback } from "react";

interface ViewportOffset {
  top: number;
  height: number;
  keyboardHeight: number;
}

export function useIOSKeyboard() {
  const [offset, setOffset] = useState<ViewportOffset>({
    top: 0,
    height: typeof window !== "undefined" ? window.innerHeight : 0,
    keyboardHeight: 0,
  });
  const [isKeyboardOpen, setIsKeyboardOpen] = useState(false);

  useEffect(() => {
    // Only run on iOS Safari in browser
    if (typeof window === "undefined") return;

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    if (!isIOS || typeof visualViewport === "undefined") {
      return;
    }

    const handleResize = () => {
      const vv = visualViewport!;
      const windowHeight = window.innerHeight;
      const keyboardHeight = windowHeight - vv.height;

      setOffset({
        top: vv.offsetTop,
        height: vv.height,
        keyboardHeight: Math.max(0, keyboardHeight),
      });
      setIsKeyboardOpen(keyboardHeight > 100);
    };

    // Known iOS 26 bug workaround: also listen for blur events
    const handleBlur = (e: FocusEvent) => {
      if (
        e.target instanceof HTMLInputElement ||
        e.target instanceof HTMLTextAreaElement
      ) {
        // Small delay to let keyboard animation complete
        setTimeout(() => {
          if (!document.activeElement ||
              !(document.activeElement instanceof HTMLInputElement) &&
              !(document.activeElement instanceof HTMLTextAreaElement)) {
            setOffset({
              top: 0,
              height: window.innerHeight,
              keyboardHeight: 0,
            });
            setIsKeyboardOpen(false);
          }
        }, 100);
      }
    };

    visualViewport.addEventListener("resize", handleResize);
    visualViewport.addEventListener("scroll", handleResize);
    document.addEventListener("blur", handleBlur, true);

    // Initial check
    handleResize();

    return () => {
      visualViewport?.removeEventListener("resize", handleResize);
      visualViewport?.removeEventListener("scroll", handleResize);
      document.removeEventListener("blur", handleBlur, true);
    };
  }, []);

  // Style generator for fixed bottom elements
  const getFixedBottomStyle = useCallback((): React.CSSProperties => {
    if (!isKeyboardOpen) {
      return { position: "fixed", bottom: 0 };
    }
    return {
      position: "fixed",
      bottom: offset.keyboardHeight,
      transition: "bottom 0.1s ease-out",
    };
  }, [isKeyboardOpen, offset.keyboardHeight]);

  return { offset, isKeyboardOpen, getFixedBottomStyle };
}
```
  </action>
  <verify>
    - TypeScript compilation passes
    - Both hooks export properly typed functions
  </verify>
  <done>
    - useSmartDefaults stores last 5 selections per field in localStorage
    - useIOSKeyboard detects keyboard via Visual Viewport API with iOS 26 bug workaround
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && bun run build` completes without errors
2. `cd frontend && bun run lint` passes
3. All new files exist:
   - frontend/components/ui/collapsible.tsx
   - frontend/lib/hooks/use-form-draft.ts
   - frontend/lib/hooks/use-smart-defaults.ts
   - frontend/lib/hooks/use-ios-keyboard.ts
4. DB_VERSION in offline-db.ts is 4
5. formDrafts store is added to OfflineDBSchema in types.ts
</verification>

<success_criteria>
- Collapsible UI component available for progressive disclosure
- useFormDraft can persist/restore form data to IndexedDB with debounce
- useSmartDefaults remembers up to 5 recent selections per field
- useIOSKeyboard detects iOS keyboard and provides positioning helpers
- IndexedDB schema migrates cleanly to version 4
</success_criteria>

<output>
After completion, create `.planning/phases/21-mobile-form-improvements/21-01-SUMMARY.md`
</output>
