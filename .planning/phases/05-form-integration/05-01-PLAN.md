---
phase: 05-form-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx
  - frontend/e2e/offline/offline-mutations.spec.ts
autonomous: true

must_haves:
  truths:
    - "User creates item offline and it appears in list immediately with pending indicator"
    - "User updates item offline and change is visible immediately"
    - "Pending items display 'Pending' badge until synced"
    - "Changes sync automatically when back online"
    - "Pending indicator disappears after successful sync"
  artifacts:
    - path: "frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx"
      provides: "Offline-capable item form using useOfflineMutation"
      contains: "useOfflineMutation"
    - path: "frontend/e2e/offline/offline-mutations.spec.ts"
      provides: "E2E test for offline item creation/update flow"
      contains: "Offline Item Mutations"
  key_links:
    - from: "frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx"
      to: "frontend/lib/hooks/use-offline-mutation.ts"
      via: "import and hook usage"
      pattern: "useOfflineMutation.*entity.*items"
    - from: "frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx"
      to: "IndexedDB mutationQueue"
      via: "useOfflineMutation queues to IDB"
      pattern: "_pending.*true"
---

<objective>
Migrate the Items page inline dialog form to use `useOfflineMutation` hook, enabling users to create and update items while offline.

Purpose: Close the gap identified in v1-MILESTONE-AUDIT.md - the offline mutation infrastructure is complete but forms haven't been migrated to use it. This is the "last mile" integration that makes offline mutations user-accessible.

Output:
- Items page form using `useOfflineMutation` for create/update operations
- Pending indicator badge on items awaiting sync
- E2E test validating full offline create flow
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-form-integration/05-RESEARCH.md

# Existing hook to consume
@frontend/lib/hooks/use-offline-mutation.ts

# Target form to migrate
@frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx

# Existing E2E offline test patterns
@frontend/e2e/offline/offline-flows.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate item form to useOfflineMutation</name>
  <files>frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx</files>
  <action>
Migrate the inline item dialog form from direct API calls to useOfflineMutation:

1. **Add imports** at top of file:
   ```typescript
   import { useOfflineMutation, isPendingMutation } from "@/lib/hooks/use-offline-mutation";
   import { Cloud } from "lucide-react";
   ```

2. **Add state for optimistic items** near other state declarations:
   ```typescript
   const [optimisticItems, setOptimisticItems] = useState<(Item & { _pending?: boolean })[]>([]);
   ```

3. **Set up useOfflineMutation hooks** after workspaceId is available:
   ```typescript
   const { mutate: createItemOffline, isPending: isCreatingOffline } = useOfflineMutation<ItemCreate>({
     entity: 'items',
     operation: 'create',
     onMutate: (payload, tempId) => {
       const optimisticItem: Item & { _pending: boolean } = {
         id: tempId,
         workspace_id: workspaceId!,
         sku: payload.sku,
         name: payload.name,
         description: payload.description || null,
         category_id: payload.category_id || null,
         brand: payload.brand || null,
         model: payload.model || null,
         serial_number: payload.serial_number || null,
         manufacturer: payload.manufacturer || null,
         barcode: payload.barcode || null,
         is_insured: payload.is_insured ?? false,
         lifetime_warranty: payload.lifetime_warranty ?? false,
         warranty_details: payload.warranty_details || null,
         min_stock_level: payload.min_stock_level ?? 0,
         short_code: payload.short_code || null,
         is_archived: false,
         created_at: new Date().toISOString(),
         updated_at: new Date().toISOString(),
         _pending: true,
       };
       setOptimisticItems(prev => [...prev, optimisticItem]);
     },
   });

   const { mutate: updateItemOffline, isPending: isUpdatingOffline } = useOfflineMutation<ItemUpdate>({
     entity: 'items',
     operation: 'update',
     onMutate: (payload, _tempId) => {
       // For updates, mark the existing item as pending
       // The actual update will be applied after sync
     },
   });
   ```

4. **Merge optimistic items with fetched items** in filteredItems useMemo:
   ```typescript
   const filteredItems = useMemo(() => {
     // Merge optimistic items with fetched items
     const allItems = [...items, ...optimisticItems.filter(opt =>
       !items.some(item => item.id === opt.id)
     )];

     return allItems.filter((item) => {
       // ... existing filter logic
     });
   }, [items, optimisticItems, showArchived, debouncedSearchQuery, getFilter]);
   ```

5. **Update handleSave** to use offline mutation when appropriate:
   ```typescript
   const handleSave = async () => {
     if (!workspaceId) return;

     if (!formData.sku.trim() || !formData.name.trim()) {
       toast.error("Please fill in required fields", {
         description: "SKU and Name are required",
       });
       return;
     }

     try {
       setIsSaving(true);

       if (editingItem) {
         // Update existing item
         const updateData: ItemUpdate = {
           name: formData.name,
           description: formData.description || undefined,
           category_id: formData.category_id || undefined,
           brand: formData.brand || undefined,
           model: formData.model || undefined,
           serial_number: formData.serial_number || undefined,
           manufacturer: formData.manufacturer || undefined,
           barcode: formData.barcode || undefined,
           is_insured: formData.is_insured,
           lifetime_warranty: formData.lifetime_warranty,
           warranty_details: formData.warranty_details || undefined,
           min_stock_level: formData.min_stock_level,
         };

         // Use offline mutation - works both online and offline
         await updateItemOffline(updateData, editingItem.id);
         toast.success(navigator.onLine ? "Item updated" : "Item update queued for sync");
       } else {
         // Create new item
         const createData: ItemCreate = {
           sku: formData.sku,
           name: formData.name,
           description: formData.description || undefined,
           category_id: formData.category_id || undefined,
           brand: formData.brand || undefined,
           model: formData.model || undefined,
           serial_number: formData.serial_number || undefined,
           manufacturer: formData.manufacturer || undefined,
           barcode: formData.barcode || undefined,
           is_insured: formData.is_insured,
           lifetime_warranty: formData.lifetime_warranty,
           warranty_details: formData.warranty_details || undefined,
           min_stock_level: formData.min_stock_level,
           short_code: formData.short_code || undefined,
         };

         // Use offline mutation - works both online and offline
         await createItemOffline(createData);
         toast.success(navigator.onLine ? "Item created" : "Item queued for sync");
       }

       setDialogOpen(false);

       // Only refetch if online - offline items are handled via optimistic state
       if (navigator.onLine) {
         refetch();
       }
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : "Failed to save item";
       toast.error("Failed to save item", {
         description: errorMessage,
       });
     } finally {
       setIsSaving(false);
     }
   };
   ```

6. **Add SyncManager subscription to clear optimistic items after sync** in useEffect:
   ```typescript
   // Subscribe to sync events to clear optimistic items
   useEffect(() => {
     const { syncManager } = require("@/lib/sync/sync-manager");

     const handleSyncEvent = (event: { type: string; entry?: { entity: string; idempotencyKey: string } }) => {
       if (event.type === 'MUTATION_SYNCED' && event.entry?.entity === 'items') {
         // Remove synced item from optimistic state
         setOptimisticItems(prev =>
           prev.filter(item => item.id !== event.entry?.idempotencyKey)
         );
         // Refetch to get server data
         refetch();
       }
     };

     syncManager?.subscribe(handleSyncEvent);

     return () => {
       syncManager?.unsubscribe(handleSyncEvent);
     };
   }, [refetch]);
   ```

7. **Update isSaving usage** to include offline mutation pending states:
   ```typescript
   // In the Save button disabled state
   disabled={isSaving || isCreatingOffline || isUpdatingOffline}
   ```

**Important - Do NOT:**
- Remove the existing direct API approach entirely (keep as fallback documentation)
- Change the form field structure or validation logic
- Modify the infinite scroll or virtualization code
  </action>
  <verify>
    - `grep -n "useOfflineMutation" frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx` shows import and usage
    - `grep -n "_pending" frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx` shows pending state handling
    - `grep -n "optimisticItems" frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx` shows optimistic state
    - `cd frontend && bun run build` succeeds without TypeScript errors
  </verify>
  <done>
    - Items page imports and uses useOfflineMutation hook for create and update
    - Optimistic items state tracks pending items
    - handleSave uses offline mutation instead of direct API calls
    - SyncManager subscription clears optimistic items after successful sync
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pending indicator to item table rows</name>
  <files>frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx</files>
  <action>
Add visual indicator for items pending sync in the table view:

1. **Add pending indicator in table row** (find the TableRow rendering inside virtualizer map):
   ```typescript
   <TableRow
     key={item.id}
     className={cn(
       "cursor-pointer hover:bg-muted/50",
       isSelected(item.id) && "bg-muted",
       '_pending' in item && item._pending && "bg-amber-50/50 dark:bg-amber-900/10"
     )}
     onClick={() => router.push(`/${locale}/dashboard/items/${item.id}`)}
   >
   ```

2. **Add pending badge next to item name** in the name TableCell:
   ```typescript
   <TableCell className="font-medium">
     <div className="flex items-center gap-2">
       {item.name}
       {'_pending' in item && item._pending && (
         <Badge variant="outline" className="text-xs text-amber-600 border-amber-300">
           <Cloud className="w-3 h-3 mr-1 animate-pulse" />
           Pending
         </Badge>
       )}
     </div>
   </TableCell>
   ```

3. **Disable row click for pending items** (prevent navigation to detail page for temp IDs):
   ```typescript
   onClick={() => {
     if ('_pending' in item && item._pending) {
       toast.info("Item pending sync", {
         description: "This item will be available after syncing"
       });
       return;
     }
     router.push(`/${locale}/dashboard/items/${item.id}`);
   }}
   ```

4. **Disable actions dropdown for pending items**:
   ```typescript
   {!('_pending' in item && item._pending) && (
     <DropdownMenu>
       {/* existing dropdown content */}
     </DropdownMenu>
   )}
   ```

**Style guidance:**
- Use amber colors for pending state (matches existing offline indicator)
- Use Cloud icon with animate-pulse for subtle animation
- Keep the badge small and unobtrusive
  </action>
  <verify>
    - `grep -n "Pending" frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx` shows pending badge
    - `grep -n "amber" frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx` shows styling
    - `grep -n "animate-pulse" frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx` shows animation
  </verify>
  <done>
    - Pending items have amber background tint in table row
    - Pending badge with Cloud icon shows next to item name
    - Clicking pending items shows info toast instead of navigation
    - Actions dropdown hidden for pending items
  </done>
</task>

<task type="auto">
  <name>Task 3: Add E2E test for offline item creation</name>
  <files>frontend/e2e/offline/offline-mutations.spec.ts</files>
  <action>
Create E2E test file for offline item mutations:

```typescript
import { test, expect } from "../fixtures/authenticated";

/**
 * Offline item mutation E2E tests.
 *
 * Tests the full offline create/update flow:
 * - Create item while offline
 * - Optimistic item appears immediately with pending indicator
 * - Item syncs when back online
 * - Pending indicator disappears after sync
 *
 * Chromium only: WebKit and Firefox have inconsistent offline simulation.
 */
test.describe("Offline Item Mutations", () => {
  test.skip(({ browserName }) => browserName !== "chromium", "Chromium only");

  // Run tests serially to avoid auth state conflicts
  test.describe.configure({ mode: "serial" });

  test.beforeEach(async ({ page }) => {
    // Navigate to items page and wait for it to load
    await page.goto("/en/dashboard/items");
    await page.waitForLoadState("domcontentloaded");
    await expect(page.locator("main")).toBeVisible({ timeout: 15000 });

    // Wait for items table to be visible
    await expect(page.getByRole("table")).toBeVisible({ timeout: 10000 });
  });

  test("creates item while offline with pending indicator", async ({ page, context }) => {
    // Generate unique SKU to avoid conflicts
    const uniqueSku = `OFFLINE-TEST-${Date.now()}`;
    const itemName = "Offline Test Item";

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));

    // Verify offline indicator appears
    const offlineIndicator = page.locator('[data-testid="offline-indicator"]');
    await expect(offlineIndicator).toBeVisible({ timeout: 5000 });

    // Click Add Item button
    await page.getByRole("button", { name: /Add Item/i }).click();

    // Wait for dialog to open
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    // Fill the form
    await page.getByLabel(/SKU/i).fill(uniqueSku);
    await page.getByLabel(/^Name$/i).fill(itemName);

    // Submit the form
    await page.getByRole("button", { name: /Create|Save/i }).click();

    // Dialog should close
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify optimistic item appears with pending indicator
    await expect(page.getByText(itemName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText("Pending")).toBeVisible({ timeout: 5000 });

    // Verify the row has pending styling
    const itemRow = page.locator("tr").filter({ hasText: itemName });
    await expect(itemRow).toBeVisible();

    // Go back online
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for sync - pending indicator should disappear
    await expect(page.getByText("Pending")).not.toBeVisible({ timeout: 15000 });

    // Item should still be visible after sync
    await expect(page.getByText(itemName)).toBeVisible();
  });

  test("shows toast when clicking pending item", async ({ page, context }) => {
    // Generate unique SKU
    const uniqueSku = `PENDING-CLICK-${Date.now()}`;
    const itemName = "Pending Click Test";

    // Go offline and create item
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));

    await page.getByRole("button", { name: /Add Item/i }).click();
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    await page.getByLabel(/SKU/i).fill(uniqueSku);
    await page.getByLabel(/^Name$/i).fill(itemName);
    await page.getByRole("button", { name: /Create|Save/i }).click();

    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });
    await expect(page.getByText(itemName)).toBeVisible({ timeout: 5000 });

    // Click the pending item row
    const itemRow = page.locator("tr").filter({ hasText: itemName });
    await itemRow.click();

    // Should show info toast, not navigate
    await expect(page.getByText(/pending sync/i)).toBeVisible({ timeout: 5000 });

    // URL should not change (still on items page)
    await expect(page).toHaveURL(/\/dashboard\/items$/);

    // Cleanup: go online to sync
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));
  });

  test("pending item count reflected in sync status", async ({ page, context }) => {
    const uniqueSku = `QUEUE-COUNT-${Date.now()}`;

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));

    // Create item offline
    await page.getByRole("button", { name: /Add Item/i }).click();
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    await page.getByLabel(/SKU/i).fill(uniqueSku);
    await page.getByLabel(/^Name$/i).fill("Queue Count Test");
    await page.getByRole("button", { name: /Create|Save/i }).click();

    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify pending changes count is shown in sync status
    // The SyncStatusIndicator shows pending count when queue is not empty
    const pendingBadge = page.locator('[data-testid="pending-count"]');
    // May or may not be visible depending on implementation
    // Just verify the item appears as pending
    await expect(page.getByText("Pending")).toBeVisible({ timeout: 5000 });

    // Go online to sync
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for sync
    await expect(page.getByText("Pending")).not.toBeVisible({ timeout: 15000 });
  });
});
```

**Test patterns from existing offline tests:**
- Use `context.setOffline(true/false)` for network simulation
- Dispatch `window.dispatchEvent(new Event("offline/online"))` to trigger React hooks
- Use generous timeouts (5000-15000ms) for async operations
- Skip non-Chromium browsers
- Run in serial mode to avoid auth conflicts
  </action>
  <verify>
    - `test -f frontend/e2e/offline/offline-mutations.spec.ts` file exists
    - `cd frontend && bun run test:e2e --grep "Offline Item Mutations" --headed` tests run (may skip due to offline - at least file loads)
    - `grep -c "test\\(" frontend/e2e/offline/offline-mutations.spec.ts` shows 3+ test cases
  </verify>
  <done>
    - E2E test file exists at frontend/e2e/offline/offline-mutations.spec.ts
    - Tests cover: offline create with pending indicator, click behavior, sync completion
    - Tests follow existing patterns from offline-flows.spec.ts
    - Tests are Chromium-only and run serially
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   cd frontend && bun run build
   ```
   Must complete without errors.

2. **Type checking:**
   ```bash
   cd frontend && bun run typecheck
   ```
   No TypeScript errors.

3. **Manual verification flow:**
   - Open Items page in browser
   - Open DevTools Network tab
   - Set network to Offline mode
   - Click "Add Item"
   - Fill SKU and Name, submit
   - Verify: Item appears immediately with "Pending" badge
   - Set network back Online
   - Verify: "Pending" badge disappears within ~5 seconds
   - Item persists in list

4. **E2E test execution:**
   ```bash
   cd frontend && bun run test:e2e --grep "Offline Item Mutations"
   ```
   Tests should pass (Chromium only).
</verification>

<success_criteria>
- [ ] useOfflineMutation hook imported and used in Items page
- [ ] Create form uses offline mutation (works online and offline)
- [ ] Update form uses offline mutation (works online and offline)
- [ ] Optimistic items appear immediately in list with _pending: true
- [ ] Pending badge (Cloud icon + "Pending") visible on unsync'd items
- [ ] Pending items have amber background tint
- [ ] Clicking pending item shows toast instead of navigation
- [ ] SyncManager subscription clears optimistic state after sync
- [ ] E2E test validates full offline create flow
- [ ] Build and typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-form-integration/05-01-SUMMARY.md`
</output>
