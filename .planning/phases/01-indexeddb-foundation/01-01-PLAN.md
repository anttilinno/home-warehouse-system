---
phase: 01-indexeddb-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/db/offline-db.ts
  - frontend/lib/db/types.ts
  - frontend/package.json
  - frontend/bun.lock
autonomous: true

must_haves:
  truths:
    - "IndexedDB database opens without error on app load"
    - "All 8 object stores exist (items, inventory, locations, containers, categories, borrowers, loans, syncMeta)"
    - "CRUD operations work for all entity stores"
    - "Persistent storage is requested on first database open"
  artifacts:
    - path: "frontend/lib/db/offline-db.ts"
      provides: "IndexedDB schema, database instance, CRUD operations"
      exports: ["openDB", "getAll", "getById", "putAll", "put", "deleteById", "clearStore", "getSyncMeta", "setSyncMeta"]
      min_lines: 100
    - path: "frontend/lib/db/types.ts"
      provides: "TypeScript types for offline database entities"
      exports: ["OfflineItem", "OfflineInventory", "OfflineLocation", "OfflineContainer", "OfflineCategory", "OfflineBorrower", "OfflineLoan", "SyncMeta", "OfflineDBSchema"]
      min_lines: 40
  key_links:
    - from: "frontend/lib/db/offline-db.ts"
      to: "idb"
      via: "import { openDB } from 'idb'"
      pattern: "import.*from.*idb"
    - from: "frontend/lib/db/offline-db.ts"
      to: "navigator.storage.persist()"
      via: "persistent storage request"
      pattern: "navigator\\.storage\\.persist"
---

<objective>
Create the IndexedDB foundation using the `idb` wrapper library. This establishes the local database schema that all offline functionality builds upon.

Purpose: Phase 1 requires offline data storage. This plan creates the database layer that Plans 02 and 03 depend on.

Output:
- `frontend/lib/db/offline-db.ts` - Database operations module
- `frontend/lib/db/types.ts` - TypeScript interfaces for offline entities
- `idb` dependency installed
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/research/SUMMARY.md

@frontend/lib/types/items.ts
@frontend/lib/types/inventory.ts
@frontend/lib/types/locations.ts
@frontend/lib/types/containers.ts
@frontend/lib/types/borrowers.ts
@frontend/lib/types/loans.ts
@frontend/lib/api/categories.ts
@frontend/lib/contexts/offline-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install idb and create offline database types</name>
  <files>
    frontend/package.json
    frontend/lib/db/types.ts
  </files>
  <action>
Install `idb` v8.0.3 (1.19kB lightweight IndexedDB wrapper):
```bash
cd frontend && bun add idb@8.0.3
```

Create `frontend/lib/db/types.ts` with TypeScript interfaces:

1. Create "Offline" versions of each entity type that mirror the API types but are optimized for IndexedDB storage:
   - `OfflineItem` - same as Item from `@/lib/types/items`
   - `OfflineInventory` - same as Inventory from `@/lib/types/inventory`
   - `OfflineLocation` - same as Location from `@/lib/types/locations`
   - `OfflineContainer` - same as Container from `@/lib/types/containers`
   - `OfflineCategory` - mirrors Category from categories API (id, name, parent_category_id, description, created_at, updated_at)
   - `OfflineBorrower` - same as Borrower from `@/lib/types/borrowers`
   - `OfflineLoan` - same as Loan from `@/lib/types/loans`

2. Create `SyncMeta` interface:
   ```typescript
   interface SyncMeta {
     key: string;  // e.g., "lastSync", "workspaceId"
     value: string | number | boolean;
     updatedAt: number;  // timestamp
   }
   ```

3. Create `OfflineDBSchema` interface for idb's DBSchema type that defines all object stores:
   ```typescript
   interface OfflineDBSchema extends DBSchema {
     items: { key: string; value: OfflineItem };
     inventory: { key: string; value: OfflineInventory };
     locations: { key: string; value: OfflineLocation };
     containers: { key: string; value: OfflineContainer };
     categories: { key: string; value: OfflineCategory };
     borrowers: { key: string; value: OfflineBorrower };
     loans: { key: string; value: OfflineLoan };
     syncMeta: { key: string; value: SyncMeta };
   }
   ```

Re-export the existing types where possible to avoid duplication. The Offline types exist primarily to provide the DBSchema mapping.
  </action>
  <verify>
Run `cd frontend && bun install` to verify lockfile.
Check `frontend/node_modules/idb` exists.
Check `frontend/lib/db/types.ts` exports the required interfaces.
  </verify>
  <done>
idb dependency installed, types.ts file exports all 8 entity types plus SyncMeta and OfflineDBSchema.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IndexedDB database module with CRUD operations</name>
  <files>
    frontend/lib/db/offline-db.ts
  </files>
  <action>
Create `frontend/lib/db/offline-db.ts` using the `idb` library.

**Database configuration:**
- Database name: `hws-offline-v1`
- Version: 1
- Use `openDB` from idb with typed schema

**Object stores (all use `keyPath: 'id'`):**
- items
- inventory
- locations
- containers
- categories
- borrowers
- loans
- syncMeta (uses `keyPath: 'key'` instead of 'id')

**Implement these exported functions:**

1. `openDB(): Promise<IDBPDatabase<OfflineDBSchema>>` - Opens/creates the database. On first open:
   - Create all object stores in `upgrade` callback
   - Request persistent storage via `navigator.storage.persist()` (Safari eviction prevention)
   - Log persistent storage result to console

2. Generic CRUD operations (use TypeScript generics):
   - `getAll<T>(storeName: StoreNames<OfflineDBSchema>): Promise<T[]>` - Get all records
   - `getById<T>(storeName: StoreNames<OfflineDBSchema>, id: string): Promise<T | undefined>` - Get single record
   - `putAll<T>(storeName: StoreNames<OfflineDBSchema>, items: T[]): Promise<void>` - Put multiple records (transaction)
   - `put<T>(storeName: StoreNames<OfflineDBSchema>, item: T): Promise<void>` - Put single record
   - `deleteById(storeName: StoreNames<OfflineDBSchema>, id: string): Promise<void>` - Delete single record
   - `clearStore(storeName: StoreNames<OfflineDBSchema>): Promise<void>` - Clear all records in store

3. Sync metadata operations:
   - `getSyncMeta(key: string): Promise<SyncMeta | undefined>` - Get sync metadata by key
   - `setSyncMeta(key: string, value: string | number | boolean): Promise<void>` - Set sync metadata

**Implementation notes:**
- Use singleton pattern for database instance (cache the promise)
- Handle browser environments only (check `typeof indexedDB !== 'undefined'`)
- For `putAll`, use a transaction to batch all puts for performance
- The persistent storage request should be non-blocking (don't await in critical path)

Example structure:
```typescript
import { openDB as idbOpen, type IDBPDatabase, type StoreNames } from 'idb';
import type { OfflineDBSchema, SyncMeta } from './types';

const DB_NAME = 'hws-offline-v1';
const DB_VERSION = 1;

let dbPromise: Promise<IDBPDatabase<OfflineDBSchema>> | null = null;

async function getDB(): Promise<IDBPDatabase<OfflineDBSchema>> {
  if (!dbPromise) {
    dbPromise = idbOpen<OfflineDBSchema>(DB_NAME, DB_VERSION, {
      upgrade(db) {
        // Create stores...
      },
    });
    // Request persistent storage (non-blocking)
    requestPersistentStorage();
  }
  return dbPromise;
}
```
  </action>
  <verify>
Create a simple test by adding temporary code to a component or creating a test file:
```typescript
import { getAll, putAll, getSyncMeta, setSyncMeta } from '@/lib/db/offline-db';

// Test basic operations
const items = await getAll('items');
console.log('Items in offline DB:', items.length);

await setSyncMeta('lastSync', Date.now());
const meta = await getSyncMeta('lastSync');
console.log('Sync meta:', meta);
```

Run `cd frontend && bun run build` to verify TypeScript compilation.
  </verify>
  <done>
offline-db.ts exports all CRUD functions, database opens with all 8 stores, persistent storage is requested on first open.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add database initialization to app startup</name>
  <files>
    frontend/lib/db/offline-db.ts
    frontend/lib/contexts/offline-context.tsx
  </files>
  <action>
1. Add an `initDB()` function to `offline-db.ts` that:
   - Opens the database (ensures stores are created)
   - Returns a boolean indicating if persistent storage was granted
   - This is the public entry point for app initialization

```typescript
export async function initDB(): Promise<{ dbReady: boolean; persistentStorage: boolean }> {
  try {
    await getDB();
    const persisted = await navigator.storage?.persisted?.() ?? false;
    return { dbReady: true, persistentStorage: persisted };
  } catch (error) {
    console.error('Failed to initialize offline database:', error);
    return { dbReady: false, persistentStorage: false };
  }
}
```

2. Update `frontend/lib/contexts/offline-context.tsx` to:
   - Add `dbReady` and `persistentStorage` to context value
   - Call `initDB()` on mount (useEffect)
   - The existing context already handles online/offline status; extend it

Add to OfflineContextValue interface:
```typescript
dbReady: boolean;
persistentStorage: boolean;
```

Add state and effect:
```typescript
const [dbReady, setDbReady] = useState(false);
const [persistentStorage, setPersistentStorage] = useState(false);

useEffect(() => {
  initDB().then(({ dbReady, persistentStorage }) => {
    setDbReady(dbReady);
    setPersistentStorage(persistentStorage);
  });
}, []);
```

Do NOT remove the existing PhotoUploadQueue IndexedDB code - it's separate and should remain.
  </action>
  <verify>
Start the dev server (`cd frontend && bun run dev`).
Open browser DevTools > Application > IndexedDB.
Verify `hws-offline-v1` database exists with all 8 object stores.
Check console for persistent storage request result.
  </verify>
  <done>
Database initializes on app load, context exposes dbReady and persistentStorage states, all 8 object stores created.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript compilation**: `cd frontend && bun run build` succeeds without errors
2. **Database creation**: Browser DevTools > Application > IndexedDB shows `hws-offline-v1` with stores:
   - items, inventory, locations, containers, categories, borrowers, loans, syncMeta
3. **Persistent storage**: Console shows persistent storage request result
4. **Context values**: OfflineProvider exposes `dbReady: true` and `persistentStorage` boolean
5. **No regressions**: Existing PhotoUploadQueue functionality unchanged
</verification>

<success_criteria>
- idb v8.0.3 installed in frontend/package.json
- frontend/lib/db/types.ts exports 8 Offline entity types + SyncMeta + OfflineDBSchema
- frontend/lib/db/offline-db.ts exports initDB, getAll, getById, putAll, put, deleteById, clearStore, getSyncMeta, setSyncMeta
- OfflineContext exposes dbReady and persistentStorage
- Database opens on app load with all stores created
- TypeScript builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-indexeddb-foundation/01-01-SUMMARY.md`
</output>
