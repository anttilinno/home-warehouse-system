---
phase: 01-indexeddb-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - frontend/lib/db/sync-operations.ts
  - frontend/lib/contexts/offline-context.tsx
  - frontend/lib/hooks/use-offline-data.ts
autonomous: true

must_haves:
  truths:
    - "Workspace data is cached to IndexedDB when user loads the app"
    - "All 7 entity types are fetched and stored (items, inventory, locations, containers, categories, borrowers, loans)"
    - "Last sync timestamp is recorded in syncMeta store"
    - "Sync only occurs when online and workspace is selected"
  artifacts:
    - path: "frontend/lib/db/sync-operations.ts"
      provides: "Functions to sync data from API to IndexedDB"
      exports: ["syncWorkspaceData", "syncEntity"]
      min_lines: 80
    - path: "frontend/lib/hooks/use-offline-data.ts"
      provides: "Hook for reading data with offline fallback"
      exports: ["useOfflineData"]
      min_lines: 50
  key_links:
    - from: "frontend/lib/db/sync-operations.ts"
      to: "frontend/lib/api/*"
      via: "API client calls for each entity"
      pattern: "(itemsApi|inventoryApi|locationsApi|containersApi|categoriesApi|borrowersApi|loansApi)"
    - from: "frontend/lib/db/sync-operations.ts"
      to: "frontend/lib/db/offline-db.ts"
      via: "putAll for caching responses"
      pattern: "putAll.*items|inventory|locations"
    - from: "frontend/lib/hooks/use-offline-data.ts"
      to: "frontend/lib/db/offline-db.ts"
      via: "getAll for offline reads"
      pattern: "getAll"
---

<objective>
Implement proactive data caching that syncs workspace data to IndexedDB on app load. This enables offline reads in Plan 03.

Purpose: ODA-1 requires proactive caching of all workspace data. This plan fetches and stores data so users can browse offline.

Output:
- `frontend/lib/db/sync-operations.ts` - Sync functions that fetch from API and store in IndexedDB
- `frontend/lib/hooks/use-offline-data.ts` - Hook implementing stale-while-revalidate pattern
- Updated OfflineContext with sync state
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

@frontend/lib/db/offline-db.ts
@frontend/lib/db/types.ts
@frontend/lib/api/items.ts
@frontend/lib/api/inventory.ts
@frontend/lib/api/locations.ts
@frontend/lib/api/containers.ts
@frontend/lib/api/categories.ts
@frontend/lib/api/borrowers.ts
@frontend/lib/api/loans.ts
@frontend/lib/contexts/offline-context.tsx
@frontend/lib/hooks/use-workspace.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync operations module</name>
  <files>
    frontend/lib/db/sync-operations.ts
  </files>
  <action>
Create `frontend/lib/db/sync-operations.ts` with functions to sync data from API to IndexedDB.

**Import the API modules:**
```typescript
import { itemsApi } from '@/lib/api/items';
import { inventoryApi } from '@/lib/api/inventory';
import { locationsApi } from '@/lib/api/locations';
import { containersApi } from '@/lib/api/containers';
import { categoriesApi } from '@/lib/api/categories';
import { borrowersApi } from '@/lib/api/borrowers';
import { loansApi } from '@/lib/api/loans';
import { putAll, clearStore, setSyncMeta, getSyncMeta } from './offline-db';
```

**Implement `syncEntity` function:**
A generic function that:
1. Fetches all data from an API endpoint (handles pagination)
2. Clears the existing store
3. Stores all fetched data
4. Returns count of items synced

```typescript
type EntityType = 'items' | 'inventory' | 'locations' | 'containers' | 'categories' | 'borrowers' | 'loans';

async function syncEntity(
  workspaceId: string,
  entityType: EntityType,
  fetchFn: () => Promise<unknown[]>
): Promise<number> {
  const data = await fetchFn();
  await clearStore(entityType);
  await putAll(entityType, data);
  return data.length;
}
```

**Implement `syncWorkspaceData` function:**
The main sync function that:
1. Takes workspaceId as parameter
2. Syncs all 7 entity types in parallel using Promise.all
3. Records sync timestamp in syncMeta
4. Records workspaceId in syncMeta (to detect workspace switches)
5. Returns sync result with counts and timestamp

```typescript
interface SyncResult {
  success: boolean;
  timestamp: number;
  counts: Record<EntityType, number>;
  error?: string;
}

export async function syncWorkspaceData(workspaceId: string): Promise<SyncResult> {
  const timestamp = Date.now();

  try {
    // Check if workspace changed - clear all data if so
    const storedWorkspaceId = await getSyncMeta('workspaceId');
    if (storedWorkspaceId?.value !== workspaceId) {
      // Clear all stores when workspace changes
      await Promise.all([
        clearStore('items'),
        clearStore('inventory'),
        clearStore('locations'),
        clearStore('containers'),
        clearStore('categories'),
        clearStore('borrowers'),
        clearStore('loans'),
      ]);
    }

    // Sync all entities in parallel
    const [items, inventory, locations, containers, categories, borrowers, loans] =
      await Promise.all([
        syncEntity(workspaceId, 'items', async () => {
          // Fetch ALL items (handle pagination - fetch with high limit or paginate)
          const response = await itemsApi.list(workspaceId, { limit: 10000 });
          return response.items;
        }),
        syncEntity(workspaceId, 'inventory', async () => {
          const response = await inventoryApi.list(workspaceId, { limit: 10000 });
          return response.items;
        }),
        syncEntity(workspaceId, 'locations', async () => {
          const response = await locationsApi.list(workspaceId, { limit: 10000 });
          return response.items;
        }),
        syncEntity(workspaceId, 'containers', async () => {
          const response = await containersApi.list(workspaceId, { limit: 10000 });
          return response.items;
        }),
        syncEntity(workspaceId, 'categories', () => categoriesApi.list(workspaceId)),
        syncEntity(workspaceId, 'borrowers', async () => {
          const response = await borrowersApi.list(workspaceId, { limit: 10000 });
          return response.items;
        }),
        syncEntity(workspaceId, 'loans', async () => {
          const response = await loansApi.list(workspaceId, { limit: 10000 });
          return response.items;
        }),
      ]);

    // Record sync metadata
    await setSyncMeta('lastSync', timestamp);
    await setSyncMeta('workspaceId', workspaceId);

    return {
      success: true,
      timestamp,
      counts: { items, inventory, locations, containers, categories, borrowers, loans },
    };
  } catch (error) {
    console.error('Failed to sync workspace data:', error);
    return {
      success: false,
      timestamp,
      counts: { items: 0, inventory: 0, locations: 0, containers: 0, categories: 0, borrowers: 0, loans: 0 },
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}
```

**Note on pagination:** The API list endpoints return paginated responses. For the initial implementation, use a high limit (10000) to fetch all at once. This is appropriate for home inventory systems which typically have hundreds to low thousands of items. If this becomes an issue, implement proper pagination later.
  </action>
  <verify>
Run `cd frontend && bun run build` to verify TypeScript compilation.
Verify imports resolve correctly.
  </verify>
  <done>
sync-operations.ts exports syncWorkspaceData and syncEntity functions that fetch from API and store in IndexedDB.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useOfflineData hook with stale-while-revalidate</name>
  <files>
    frontend/lib/hooks/use-offline-data.ts
  </files>
  <action>
Create `frontend/lib/hooks/use-offline-data.ts` implementing stale-while-revalidate pattern.

**Hook behavior:**
1. Returns cached data immediately (stale)
2. Fetches fresh data in background (revalidate)
3. Updates state when fresh data arrives
4. Falls back to cached data if fetch fails (offline resilience)

```typescript
"use client";

import { useState, useEffect, useCallback } from 'react';
import { getAll, putAll, clearStore } from '@/lib/db/offline-db';
import type { StoreNames } from 'idb';
import type { OfflineDBSchema } from '@/lib/db/types';

type EntityStore = Exclude<StoreNames<OfflineDBSchema>, 'syncMeta'>;

interface UseOfflineDataOptions<T> {
  store: EntityStore;
  fetchFn: () => Promise<T[]>;
  enabled?: boolean;  // Control when to fetch (e.g., when workspaceId is available)
}

interface UseOfflineDataResult<T> {
  data: T[];
  isLoading: boolean;
  isStale: boolean;  // True when showing cached data while fetching
  error: Error | null;
  refetch: () => Promise<void>;
}

export function useOfflineData<T extends { id: string }>({
  store,
  fetchFn,
  enabled = true,
}: UseOfflineDataOptions<T>): UseOfflineDataResult<T> {
  const [data, setData] = useState<T[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isStale, setIsStale] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const loadCachedData = useCallback(async () => {
    try {
      const cached = await getAll<T>(store);
      if (cached.length > 0) {
        setData(cached);
        setIsStale(true);  // Mark as stale until fresh data arrives
      }
    } catch (err) {
      console.error(`Failed to load cached ${store}:`, err);
    }
  }, [store]);

  const fetchFreshData = useCallback(async () => {
    try {
      const fresh = await fetchFn();
      await clearStore(store);
      await putAll(store, fresh);
      setData(fresh);
      setIsStale(false);
      setError(null);
    } catch (err) {
      // Keep showing cached data on error
      const error = err instanceof Error ? err : new Error('Fetch failed');
      setError(error);
      // Don't clear stale flag - we're still showing cached data
    }
  }, [store, fetchFn]);

  const refetch = useCallback(async () => {
    setIsLoading(true);
    await fetchFreshData();
    setIsLoading(false);
  }, [fetchFreshData]);

  useEffect(() => {
    if (!enabled) {
      setIsLoading(false);
      return;
    }

    let cancelled = false;

    const load = async () => {
      // 1. Load cached data immediately
      await loadCachedData();

      if (cancelled) return;

      // 2. Fetch fresh data in background (only if online)
      if (navigator.onLine) {
        await fetchFreshData();
      }

      if (cancelled) return;
      setIsLoading(false);
    };

    load();

    return () => {
      cancelled = true;
    };
  }, [enabled, loadCachedData, fetchFreshData]);

  return { data, isLoading, isStale, error, refetch };
}
```

This hook can be used like:
```typescript
const { data: items, isLoading, isStale } = useOfflineData({
  store: 'items',
  fetchFn: () => itemsApi.list(workspaceId, { limit: 10000 }).then(r => r.items),
  enabled: !!workspaceId,
});
```
  </action>
  <verify>
Run `cd frontend && bun run build` to verify TypeScript compilation.
Verify the hook exports correctly.
  </verify>
  <done>
useOfflineData hook exports and implements stale-while-revalidate pattern with offline fallback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate sync into OfflineContext</name>
  <files>
    frontend/lib/contexts/offline-context.tsx
  </files>
  <action>
Update `frontend/lib/contexts/offline-context.tsx` to:
1. Trigger initial sync when workspace is available and online
2. Track sync state (syncing, lastSyncTimestamp, syncError)
3. Provide manual sync trigger
4. Re-sync when coming back online (if workspace available)

**Add to OfflineContextValue interface:**
```typescript
// Sync state
isSyncing: boolean;
lastSyncTimestamp: number | null;
syncError: string | null;
syncCounts: Record<string, number> | null;
triggerSync: () => Promise<void>;
```

**Implementation:**

1. Add state for sync tracking:
```typescript
const [isSyncing, setIsSyncing] = useState(false);
const [lastSyncTimestamp, setLastSyncTimestamp] = useState<number | null>(null);
const [syncError, setSyncError] = useState<string | null>(null);
const [syncCounts, setSyncCounts] = useState<Record<string, number> | null>(null);
```

2. Create sync function:
```typescript
const triggerSync = useCallback(async () => {
  // Get workspace ID from localStorage (same as use-workspace.ts)
  const workspaceId = localStorage.getItem('workspace_id');
  if (!workspaceId || !navigator.onLine) return;

  setIsSyncing(true);
  setSyncError(null);

  try {
    const result = await syncWorkspaceData(workspaceId);
    if (result.success) {
      setLastSyncTimestamp(result.timestamp);
      setSyncCounts(result.counts);
    } else {
      setSyncError(result.error || 'Sync failed');
    }
  } catch (error) {
    setSyncError(error instanceof Error ? error.message : 'Sync failed');
  } finally {
    setIsSyncing(false);
  }
}, []);
```

3. Load last sync timestamp from IndexedDB on mount:
```typescript
useEffect(() => {
  getSyncMeta('lastSync').then((meta) => {
    if (meta?.value && typeof meta.value === 'number') {
      setLastSyncTimestamp(meta.value);
    }
  });
}, [dbReady]);
```

4. Trigger sync on mount (after DB is ready) and when coming back online:
```typescript
// Initial sync when DB is ready
useEffect(() => {
  if (dbReady && navigator.onLine) {
    triggerSync();
  }
}, [dbReady, triggerSync]);

// Sync when coming back online
useEffect(() => {
  if (isOnline && wasOffline && dbReady) {
    triggerSync();
  }
}, [isOnline, wasOffline, dbReady, triggerSync]);
```

**Import the sync function:**
```typescript
import { syncWorkspaceData } from '@/lib/db/sync-operations';
import { getSyncMeta } from '@/lib/db/offline-db';
```

**Keep existing functionality intact** - the PhotoUploadQueue IndexedDB code should remain unchanged.
  </action>
  <verify>
1. Start dev server: `cd frontend && bun run dev`
2. Log in and select a workspace
3. Open DevTools > Application > IndexedDB > hws-offline-v1
4. Verify all 7 entity stores have data
5. Check syncMeta store has lastSync and workspaceId entries
6. Check console for any errors during sync
  </verify>
  <done>
OfflineContext triggers sync on app load, exposes sync state (isSyncing, lastSyncTimestamp, syncError), and provides triggerSync function.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript compilation**: `cd frontend && bun run build` succeeds without errors
2. **Initial sync**: Load app with workspace selected -> all 7 stores populated in IndexedDB
3. **Sync metadata**: syncMeta store contains lastSync timestamp and workspaceId
4. **Stale-while-revalidate**: useOfflineData hook returns cached data immediately, then fresh data
5. **Online trigger**: Go offline then online -> sync re-triggers automatically
6. **Manual sync**: triggerSync function available from useOffline() hook
</verification>

<success_criteria>
- frontend/lib/db/sync-operations.ts exports syncWorkspaceData function
- frontend/lib/hooks/use-offline-data.ts exports useOfflineData hook
- OfflineContext exposes isSyncing, lastSyncTimestamp, syncError, syncCounts, triggerSync
- All 7 entity stores populated on workspace load
- syncMeta contains lastSync and workspaceId
- Re-sync triggers when coming back online
</success_criteria>

<output>
After completion, create `.planning/phases/01-indexeddb-foundation/01-02-SUMMARY.md`
</output>
