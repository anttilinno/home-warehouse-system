---
phase: 02-mutation-queue
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - frontend/lib/hooks/use-offline-mutation.ts
  - frontend/lib/sync/mutation-queue.ts
autonomous: true

must_haves:
  truths:
    - "User can create items offline and see them immediately"
    - "User can update items offline and see changes immediately"
    - "Pending items show visual indicator (opacity, 'Saving...')"
    - "Mutations persist to IndexedDB before optimistic state update"
    - "Pending items remain visible after page refresh until synced"
  artifacts:
    - path: "frontend/lib/hooks/use-offline-mutation.ts"
      provides: "Hook for queuing offline mutations with optimistic updates"
      exports: ["useOfflineMutation", "getPendingMutationsForEntity", "getPendingCreates", "getPendingUpdates"]
      min_lines: 80
  key_links:
    - from: "frontend/lib/hooks/use-offline-mutation.ts"
      to: "frontend/lib/sync/mutation-queue.ts"
      via: "Queue mutations to IndexedDB"
      pattern: "queueMutation"
    - from: "frontend/lib/hooks/use-offline-mutation.ts"
      to: "frontend/lib/db/offline-db.ts"
      via: "Write optimistic data to entity stores"
      pattern: "put.*offline-db"
    - from: "frontend/lib/hooks/use-offline-mutation.ts"
      to: "react"
      via: "useTransition for pending state"
      pattern: "useTransition"
---

<objective>
Create the useOfflineMutation hook for optimistic UI updates with offline mutation support.

Purpose: Enable React components to perform create/update operations that work offline. Changes appear immediately in the UI (optimistic update), are persisted to IndexedDB, and sync when connectivity returns.

Output:
- useOfflineMutation hook with useTransition integration
- Proper error handling and rollback
- Entity-specific type helpers
- Restoration helpers for pending mutations after page refresh
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-mutation-queue/02-RESEARCH.md
@.planning/phases/02-mutation-queue/02-01-PLAN.md
@.planning/phases/02-mutation-queue/02-02-PLAN.md

# Dependencies
@frontend/lib/sync/mutation-queue.ts
@frontend/lib/sync/sync-manager.ts
@frontend/lib/contexts/offline-context.tsx
@frontend/lib/db/offline-db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useOfflineMutation hook</name>
  <files>frontend/lib/hooks/use-offline-mutation.ts</files>
  <action>
Create `frontend/lib/hooks/use-offline-mutation.ts`:

```typescript
"use client";

import { useCallback, useTransition } from 'react';
import { queueMutation, getPendingMutationCount } from '@/lib/sync/mutation-queue';
import { syncManager } from '@/lib/sync/sync-manager';
import type { MutationOperation, MutationEntityType, MutationQueueEntry } from '@/lib/db/types';
import { put } from '@/lib/db/offline-db';

/**
 * Options for useOfflineMutation hook
 */
interface UseOfflineMutationOptions<TPayload> {
  /** Entity type being mutated */
  entity: MutationEntityType;
  /** Operation type */
  operation: MutationOperation;
  /**
   * Online mutation function - called when online.
   * Should return the created/updated entity or throw on error.
   */
  mutationFn?: (payload: TPayload, idempotencyKey: string) => Promise<unknown>;
  /**
   * Called after mutation is queued (both online and offline).
   * Use this for optimistic UI updates.
   */
  onMutate?: (payload: TPayload, tempId: string) => void;
  /**
   * Called when mutation succeeds (online sync completed).
   */
  onSuccess?: (data: unknown, payload: TPayload) => void;
  /**
   * Called when mutation fails permanently (after max retries).
   */
  onError?: (error: Error, payload: TPayload) => void;
}

/**
 * Return type for useOfflineMutation
 */
interface UseOfflineMutationResult<TPayload> {
  /** Queue a mutation. Works online and offline. */
  mutate: (payload: TPayload, entityId?: string) => Promise<string>;
  /** Whether a mutation is currently in progress */
  isPending: boolean;
}

/**
 * Hook for performing offline-capable mutations with optimistic updates.
 *
 * Usage:
 * ```tsx
 * const { mutate, isPending } = useOfflineMutation({
 *   entity: 'items',
 *   operation: 'create',
 *   onMutate: (payload, tempId) => {
 *     addOptimisticItem({ ...payload, id: tempId, pending: true });
 *   },
 * });
 *
 * async function handleCreate(data: ItemInput) {
 *   const tempId = await mutate(data);
 *   // tempId can be used to track the pending item
 * }
 * ```
 */
export function useOfflineMutation<TPayload extends Record<string, unknown>>({
  entity,
  operation,
  mutationFn,
  onMutate,
  onSuccess,
  onError,
}: UseOfflineMutationOptions<TPayload>): UseOfflineMutationResult<TPayload> {
  const [isPending, startTransition] = useTransition();

  const mutate = useCallback(
    async (payload: TPayload, entityId?: string): Promise<string> => {
      // 1. Queue mutation to IndexedDB FIRST (persist before optimistic update)
      const entry = await queueMutation({
        operation,
        entity,
        entityId,
        payload: payload as Record<string, unknown>,
      });

      const tempId = entry.idempotencyKey;

      // 2. Call onMutate for optimistic UI update
      if (onMutate) {
        startTransition(() => {
          onMutate(payload, tempId);
        });
      }

      // 3. Also write to local IndexedDB store for immediate offline access
      if (operation === 'create') {
        // For creates, store the optimistic item in the entity store
        try {
          await put(entity, {
            id: tempId,
            ...payload,
            _pending: true, // Mark as pending
          });
        } catch (error) {
          console.warn(`[useOfflineMutation] Failed to write optimistic ${entity}:`, error);
        }
      } else if (operation === 'update' && entityId) {
        // For updates, update the existing item in entity store
        try {
          await put(entity, {
            id: entityId,
            ...payload,
            _pending: true,
          });
        } catch (error) {
          console.warn(`[useOfflineMutation] Failed to update optimistic ${entity}:`, error);
        }
      }

      // 4. If online, try to sync immediately
      if (navigator.onLine && syncManager) {
        syncManager.processQueue().catch((error) => {
          console.error('[useOfflineMutation] Immediate sync failed:', error);
        });
      }

      // 5. Notify pending count updated
      if (syncManager) {
        getPendingMutationCount().then((count) => {
          // Broadcast queue update
          // This is handled by syncManager internally
        });
      }

      return tempId;
    },
    [entity, operation, onMutate]
  );

  return { mutate, isPending };
}

/**
 * Pending marker interface - can be used to identify optimistic items
 */
export interface PendingMutation {
  _pending?: boolean;
}

/**
 * Helper to check if an item is pending sync
 */
export function isPendingMutation(item: unknown): boolean {
  return typeof item === 'object' && item !== null && '_pending' in item && item._pending === true;
}
```
  </action>
  <verify>
    - `bun run build` succeeds
    - `wc -l frontend/lib/hooks/use-offline-mutation.ts` shows >= 80 lines
    - `grep "useOfflineMutation" frontend/lib/hooks/use-offline-mutation.ts` shows export
    - `grep "queueMutation" frontend/lib/hooks/use-offline-mutation.ts` shows queue integration
    - `grep "put.*from.*offline-db" frontend/lib/hooks/use-offline-mutation.ts` shows correct import
  </verify>
  <done>
    - useOfflineMutation hook created
    - Queues mutation to IndexedDB before optimistic update
    - Writes optimistic data to entity store for offline reads
    - Triggers immediate sync if online
    - Returns tempId for tracking
  </done>
</task>

<task type="auto">
  <name>Task 2: Add broadcast notification when queue changes</name>
  <files>frontend/lib/sync/mutation-queue.ts</files>
  <action>
Update mutation-queue.ts to broadcast queue changes:

1. Add BroadcastChannel at module level (if available):
   ```typescript
   const queueChannel = typeof BroadcastChannel !== 'undefined'
     ? new BroadcastChannel('sync-status')
     : null;

   function broadcastQueueUpdate() {
     if (queueChannel) {
       getPendingMutationCount().then((count) => {
         queueChannel.postMessage({
           type: 'QUEUE_UPDATED',
           payload: { queueLength: count },
         });
       });
     }
   }
   ```

2. Call broadcastQueueUpdate() after:
   - queueMutation() success
   - removeMutation() success
   - updateMutationStatus() when status changes
   - cleanExpiredMutations() when items removed

This ensures OfflineContext always has accurate pending count.
  </action>
  <verify>
    - `bun run build` succeeds
    - `grep "broadcastQueueUpdate" frontend/lib/sync/mutation-queue.ts` shows function
    - `grep "QUEUE_UPDATED" frontend/lib/sync/mutation-queue.ts` shows broadcast
  </verify>
  <done>
    - Queue operations broadcast updates via BroadcastChannel
    - OfflineContext stays in sync with queue state
  </done>
</task>

<task type="auto">
  <name>Task 3: Add helper to restore pending mutations on mount</name>
  <files>frontend/lib/hooks/use-offline-mutation.ts</files>
  <action>
Add helper functions to restore pending mutations from IndexedDB on app mount:

```typescript
import { getMutationQueue } from '@/lib/sync/mutation-queue';

/**
 * Load pending mutations from IndexedDB for a specific entity.
 * Use this on component mount to restore optimistic state after page refresh.
 *
 * Usage:
 * ```tsx
 * useEffect(() => {
 *   async function restorePending() {
 *     const pending = await getPendingMutationsForEntity('items');
 *     pending.forEach((mutation) => {
 *       if (mutation.operation === 'create') {
 *         addOptimisticItem({
 *           ...mutation.payload,
 *           id: mutation.idempotencyKey,
 *           pending: true,
 *         });
 *       }
 *     });
 *   }
 *   restorePending();
 * }, []);
 * ```
 */
export async function getPendingMutationsForEntity(
  entity: MutationEntityType
): Promise<MutationQueueEntry[]> {
  const queue = await getMutationQueue();
  return queue.filter((m) => m.entity === entity && m.status !== 'failed');
}

/**
 * Get all pending creates for an entity type.
 * Returns the payload with tempId for optimistic rendering.
 */
export async function getPendingCreates<T extends Record<string, unknown>>(
  entity: MutationEntityType
): Promise<Array<T & { id: string; _pending: true }>> {
  const pending = await getPendingMutationsForEntity(entity);
  return pending
    .filter((m) => m.operation === 'create')
    .map((m) => ({
      ...(m.payload as T),
      id: m.idempotencyKey,
      _pending: true as const,
    }));
}

/**
 * Get pending updates for an entity type.
 * Returns entity ID with pending payload.
 */
export async function getPendingUpdates<T extends Record<string, unknown>>(
  entity: MutationEntityType
): Promise<Array<{ entityId: string; payload: T }>> {
  const pending = await getPendingMutationsForEntity(entity);
  return pending
    .filter((m) => m.operation === 'update' && m.entityId)
    .map((m) => ({
      entityId: m.entityId!,
      payload: m.payload as T,
    }));
}
```
  </action>
  <verify>
    - `bun run build` succeeds
    - `grep "getPendingMutationsForEntity" frontend/lib/hooks/use-offline-mutation.ts` shows export
    - `grep "getPendingCreates" frontend/lib/hooks/use-offline-mutation.ts` shows export
  </verify>
  <done>
    - getPendingMutationsForEntity helper for filtering by entity
    - getPendingCreates for restoring optimistic creates
    - getPendingUpdates for restoring optimistic updates
    - Enables state restoration after page refresh
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `cd frontend && bun run build` - TypeScript compiles
2. Verify exports: `grep "export" frontend/lib/hooks/use-offline-mutation.ts`
3. Check hook has all expected features: mutate returns tempId, isPending state, onMutate callback
</verification>

<success_criteria>
- [ ] useOfflineMutation hook exported
- [ ] Hook accepts entity, operation, onMutate, onSuccess, onError options
- [ ] mutate() queues to IndexedDB before optimistic update
- [ ] mutate() writes optimistic data to entity store via put() function
- [ ] mutate() returns tempId (idempotency key)
- [ ] isPending state from useTransition
- [ ] Queue broadcasts updates via BroadcastChannel
- [ ] getPendingMutationsForEntity helper for mount restoration
- [ ] getPendingCreates and getPendingUpdates typed helpers
</success_criteria>

<output>
After completion, create `.planning/phases/02-mutation-queue/02-03-SUMMARY.md`
</output>
