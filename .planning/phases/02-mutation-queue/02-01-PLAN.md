---
phase: 02-mutation-queue
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/bun.lock
  - frontend/lib/db/types.ts
  - frontend/lib/db/offline-db.ts
  - frontend/lib/sync/mutation-queue.ts
autonomous: true

must_haves:
  truths:
    - "Mutations can be queued to IndexedDB with idempotency keys"
    - "User's offline changes survive page refresh and sync when online"
    - "Queue entries have status tracking (pending, syncing, failed)"
    - "Expired entries (>7 days) can be identified and removed"
  artifacts:
    - path: "frontend/lib/sync/mutation-queue.ts"
      provides: "Queue CRUD operations and retry logic"
      exports: ["queueMutation", "getMutationQueue", "updateMutationStatus", "removeMutation", "getFailedMutations", "cleanExpiredMutations"]
      min_lines: 100
    - path: "frontend/lib/db/types.ts"
      provides: "MutationQueueEntry type"
      contains: "MutationQueueEntry"
    - path: "frontend/lib/db/offline-db.ts"
      provides: "mutationQueue object store with indexes"
      contains: "mutationQueue"
  key_links:
    - from: "frontend/lib/sync/mutation-queue.ts"
      to: "frontend/lib/db/offline-db.ts"
      via: "getDB for IndexedDB access"
      pattern: "getDB\\(\\)"
    - from: "frontend/lib/sync/mutation-queue.ts"
      to: "uuid"
      via: "UUIDv7 generation for idempotency keys"
      pattern: "v7.*from.*uuid"
---

<objective>
Create the mutation queue infrastructure for offline mutations.

Purpose: Enable offline create/update operations by persisting mutations to IndexedDB with idempotency keys, status tracking, and retry metadata. This is the foundation for optimistic UI and background sync.

Output:
- MutationQueueEntry type definition
- mutationQueue IndexedDB store with proper indexes
- Queue CRUD operations (add, get, update, remove)
- Retry logic helpers (exponential backoff calculation)
- TTL enforcement (7-day expiration)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-mutation-queue/02-RESEARCH.md

# Existing infrastructure from Phase 1
@frontend/lib/db/types.ts
@frontend/lib/db/offline-db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install uuid package and add MutationQueueEntry type</name>
  <files>
    frontend/package.json
    frontend/bun.lock
    frontend/lib/db/types.ts
  </files>
  <action>
1. Install uuid package for UUIDv7 generation:
   ```bash
   cd frontend && bun add uuid && bun add -d @types/uuid
   ```

2. Add MutationQueueEntry interface to types.ts:
   ```typescript
   /**
    * Operation types for offline mutations
    */
   export type MutationOperation = 'create' | 'update';

   /**
    * Status of a queued mutation
    */
   export type MutationStatus = 'pending' | 'syncing' | 'failed';

   /**
    * Entity types that support offline mutations
    */
   export type MutationEntityType = 'items' | 'inventory' | 'locations' | 'containers' | 'categories' | 'borrowers' | 'loans';

   /**
    * Mutation queue entry for offline operations.
    * Persisted to IndexedDB and replayed when online.
    */
   export interface MutationQueueEntry {
     /** Auto-incremented ID (keyPath for IndexedDB) */
     id: number;
     /** UUIDv7 for server-side deduplication */
     idempotencyKey: string;
     /** Type of operation */
     operation: MutationOperation;
     /** Entity type being mutated */
     entity: MutationEntityType;
     /** Entity ID for updates (undefined for creates) */
     entityId?: string;
     /** The mutation payload to send to server */
     payload: Record<string, unknown>;
     /** Timestamp when mutation was queued (ms since epoch) */
     timestamp: number;
     /** Number of retry attempts */
     retries: number;
     /** Last error message if failed */
     lastError?: string;
     /** Current status */
     status: MutationStatus;
   }
   ```

3. Update OfflineDBSchema to include mutationQueue store:
   ```typescript
   export interface OfflineDBSchema extends DBSchema {
     // ... existing stores ...
     mutationQueue: {
       key: number;
       value: MutationQueueEntry;
       indexes: {
         status: MutationStatus;
         entity: MutationEntityType;
         timestamp: number;
         idempotencyKey: string;
       };
     };
   }
   ```
  </action>
  <verify>
    - `bun run build` succeeds in frontend directory
    - `grep -l "uuid" frontend/package.json` shows uuid installed
    - `grep "MutationQueueEntry" frontend/lib/db/types.ts` shows interface defined
    - `grep "mutationQueue" frontend/lib/db/types.ts` shows store in schema
  </verify>
  <done>
    - uuid package installed
    - MutationQueueEntry interface exported from types.ts
    - OfflineDBSchema includes mutationQueue store with indexes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add mutationQueue store to IndexedDB with version upgrade</name>
  <files>frontend/lib/db/offline-db.ts</files>
  <action>
1. Bump DB_VERSION from 1 to 2

2. Add mutationQueue store creation in upgrade handler:
   ```typescript
   // In upgrade function:
   if (!db.objectStoreNames.contains("mutationQueue")) {
     const store = db.createObjectStore("mutationQueue", {
       keyPath: "id",
       autoIncrement: true,
     });
     // Indexes for efficient queries
     store.createIndex("status", "status", { unique: false });
     store.createIndex("entity", "entity", { unique: false });
     store.createIndex("timestamp", "timestamp", { unique: false });
     store.createIndex("idempotencyKey", "idempotencyKey", { unique: true });
   }
   ```

3. Handle version upgrade properly - existing stores should remain, only add new mutationQueue store if upgrading from v1 to v2.

Note: idb handles schema migrations automatically. The upgrade callback receives oldVersion and newVersion. Check `if (oldVersion < 2)` before creating the mutationQueue store to handle upgrades gracefully.
  </action>
  <verify>
    - `bun run build` succeeds
    - `grep "DB_VERSION = 2" frontend/lib/db/offline-db.ts` shows version bump
    - `grep "mutationQueue" frontend/lib/db/offline-db.ts` shows store creation
  </verify>
  <done>
    - DB_VERSION bumped to 2
    - mutationQueue store created with autoIncrement keyPath
    - Indexes created: status, entity, timestamp, idempotencyKey (unique)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create mutation-queue.ts with queue operations and retry logic</name>
  <files>frontend/lib/sync/mutation-queue.ts</files>
  <action>
Create `frontend/lib/sync/mutation-queue.ts` with:

1. Import uuid v7 and database utilities:
   ```typescript
   import { v7 as uuidv7 } from 'uuid';
   import type { MutationQueueEntry, MutationOperation, MutationEntityType, MutationStatus } from '@/lib/db/types';
   ```

2. Export getDB from offline-db.ts (add export if needed) or use the existing pattern to access DB.

3. Implement queue operations:

   ```typescript
   /**
    * Queue a new mutation for offline sync
    */
   export async function queueMutation(params: {
     operation: MutationOperation;
     entity: MutationEntityType;
     entityId?: string;
     payload: Record<string, unknown>;
   }): Promise<MutationQueueEntry>

   /**
    * Get all pending mutations (status = 'pending')
    */
   export async function getPendingMutations(): Promise<MutationQueueEntry[]>

   /**
    * Get all mutations in the queue
    */
   export async function getMutationQueue(): Promise<MutationQueueEntry[]>

   /**
    * Get mutations by status
    */
   export async function getMutationsByStatus(status: MutationStatus): Promise<MutationQueueEntry[]>

   /**
    * Get failed mutations for manual retry
    */
   export async function getFailedMutations(): Promise<MutationQueueEntry[]>

   /**
    * Update mutation status and optionally error message
    */
   export async function updateMutationStatus(
     id: number,
     update: { status: MutationStatus; lastError?: string; retries?: number }
   ): Promise<void>

   /**
    * Remove a mutation from the queue (after successful sync or user cancellation)
    */
   export async function removeMutation(id: number): Promise<void>

   /**
    * Remove mutations by idempotency key (for deduplication)
    */
   export async function removeMutationByIdempotencyKey(key: string): Promise<void>

   /**
    * Get count of pending mutations
    */
   export async function getPendingMutationCount(): Promise<number>

   /**
    * Clean expired mutations (older than 7 days)
    */
   export async function cleanExpiredMutations(): Promise<number>
   ```

4. Implement retry logic helpers:
   ```typescript
   const RETRY_CONFIG = {
     initialDelay: 1000,      // 1 second
     maxDelay: 30000,         // 30 seconds (from OM-7)
     maxRetries: 5,           // from OM-8
     factor: 2,               // exponential factor
     jitter: true,            // prevent thundering herd
   };

   const MUTATION_TTL = 7 * 24 * 60 * 60 * 1000; // 7 days in ms (from OM-9)

   /**
    * Calculate delay for next retry using exponential backoff with jitter
    */
   export function calculateRetryDelay(retryCount: number): number

   /**
    * Determine if a mutation should be retried based on response/error
    */
   export function shouldRetry(error: Error, response?: Response): boolean
   ```

5. Use IndexedDB transactions properly for all operations.

6. The queueMutation function should:
   - Generate UUIDv7 for idempotencyKey
   - Set timestamp to Date.now()
   - Set retries to 0
   - Set status to 'pending'
   - Return the created entry (with generated id)
  </action>
  <verify>
    - `bun run build` succeeds
    - `wc -l frontend/lib/sync/mutation-queue.ts` shows >= 100 lines
    - `grep "queueMutation" frontend/lib/sync/mutation-queue.ts` shows function exported
    - `grep "v7.*uuid" frontend/lib/sync/mutation-queue.ts` shows UUIDv7 import
  </verify>
  <done>
    - mutation-queue.ts created with all queue operations
    - UUIDv7 used for idempotency keys
    - Retry logic with exponential backoff (1s, 2s, 4s, 8s, 16s, capped at 30s)
    - TTL enforcement (7 days)
    - All functions properly typed and exported
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `cd frontend && bun run build` - TypeScript compiles without errors
2. `grep -c "export" frontend/lib/sync/mutation-queue.ts` - Multiple exports
3. Start dev server and open browser console, verify no IndexedDB errors on load
4. Check IndexedDB in browser DevTools: hws-offline-v1 version 2 with mutationQueue store
</verification>

<success_criteria>
- [ ] uuid package installed and types available
- [ ] MutationQueueEntry type exported from types.ts
- [ ] IndexedDB version bumped to 2
- [ ] mutationQueue store has 4 indexes (status, entity, timestamp, idempotencyKey)
- [ ] mutation-queue.ts exports: queueMutation, getMutationQueue, getPendingMutations, updateMutationStatus, removeMutation, getFailedMutations, cleanExpiredMutations, calculateRetryDelay, shouldRetry
- [ ] Retry config matches requirements: max 5 retries, max 30s delay
- [ ] TTL is 7 days
</success_criteria>

<output>
After completion, create `.planning/phases/02-mutation-queue/02-01-SUMMARY.md`
</output>
