---
phase: 02-mutation-queue
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - frontend/lib/sync/sync-manager.ts
  - frontend/lib/contexts/offline-context.tsx
  - frontend/app/sw.ts
autonomous: true

must_haves:
  truths:
    - "Mutations sync automatically when device comes online"
    - "iOS Safari syncs via online event and visibility change"
    - "Service worker communicates sync status to main thread"
    - "Queue processing prevents duplicate concurrent syncs"
  artifacts:
    - path: "frontend/lib/sync/sync-manager.ts"
      provides: "Centralized sync orchestration"
      exports: ["SyncManager", "syncManager"]
      min_lines: 150
    - path: "frontend/lib/contexts/offline-context.tsx"
      provides: "Pending mutation count in context"
      contains: "pendingMutationCount"
  key_links:
    - from: "frontend/lib/sync/sync-manager.ts"
      to: "frontend/lib/sync/mutation-queue.ts"
      via: "Queue access for processing"
      pattern: "getMutationQueue|updateMutationStatus"
    - from: "frontend/lib/sync/sync-manager.ts"
      to: "BroadcastChannel"
      via: "SW to main thread communication"
      pattern: "BroadcastChannel"
    - from: "frontend/lib/contexts/offline-context.tsx"
      to: "frontend/lib/sync/sync-manager.ts"
      via: "SyncManager integration"
      pattern: "syncManager"
---

<objective>
Create the SyncManager class to orchestrate offline mutation processing with iOS fallback support.

Purpose: Ensure queued mutations sync automatically when connectivity returns, with proper handling for browsers without Background Sync API (Safari, Firefox). Communicate sync status between service worker and main thread.

Output:
- SyncManager class with queue processing logic
- Online/visibility event handlers for iOS fallback
- BroadcastChannel for SW-to-main-thread communication
- Integration with OfflineContext for pending count
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-mutation-queue/02-RESEARCH.md
@.planning/phases/02-mutation-queue/02-01-PLAN.md

# Dependencies from 02-01
@frontend/lib/sync/mutation-queue.ts
@frontend/lib/db/types.ts

# Existing infrastructure
@frontend/lib/contexts/offline-context.tsx
@frontend/app/sw.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncManager class with queue processing</name>
  <files>frontend/lib/sync/sync-manager.ts</files>
  <action>
Create `frontend/lib/sync/sync-manager.ts` with:

1. SyncManager class:
   ```typescript
   import {
     getMutationQueue,
     getPendingMutations,
     updateMutationStatus,
     removeMutation,
     calculateRetryDelay,
     shouldRetry,
     getPendingMutationCount,
   } from './mutation-queue';
   import type { MutationQueueEntry, MutationEntityType } from '@/lib/db/types';

   type SyncEventType = 'SYNC_STARTED' | 'SYNC_COMPLETE' | 'SYNC_ERROR' | 'MUTATION_SYNCED' | 'MUTATION_FAILED' | 'QUEUE_UPDATED';

   interface SyncEvent {
     type: SyncEventType;
     payload?: {
       queueLength?: number;
       mutation?: MutationQueueEntry;
       error?: string;
     };
   }

   class SyncManager {
     private isProcessing = false;
     private channel: BroadcastChannel | null = null;
     private listeners: Set<(event: SyncEvent) => void> = new Set();

     constructor() {
       if (typeof BroadcastChannel !== 'undefined') {
         this.channel = new BroadcastChannel('sync-status');
         this.channel.onmessage = (event) => this.handleChannelMessage(event.data);
       }
     }

     // Subscribe to sync events
     subscribe(callback: (event: SyncEvent) => void): () => void

     // Broadcast event to listeners and channel
     private broadcast(event: SyncEvent): void

     // Handle messages from service worker
     private handleChannelMessage(data: SyncEvent): void

     // Process the mutation queue
     async processQueue(): Promise<void>

     // Process a single mutation
     private async processMutation(mutation: MutationQueueEntry): Promise<boolean>

     // Build API URL for mutation
     private buildApiUrl(mutation: MutationQueueEntry): string

     // Get current pending count
     async getPendingCount(): Promise<number>

     // Retry a specific failed mutation
     async retryMutation(id: number): Promise<void>

     // Cancel a pending mutation
     async cancelMutation(id: number): Promise<void>

     // Check if Background Sync API is supported
     supportsBackgroundSync(): boolean

     // Setup iOS fallback event listeners
     setupFallbackListeners(): () => void
   }
   ```

2. Implement processQueue with locking:
   ```typescript
   async processQueue(): Promise<void> {
     if (this.isProcessing) {
       console.log('[SyncManager] Already processing, skipping');
       return;
     }

     if (typeof navigator !== 'undefined' && !navigator.onLine) {
       console.log('[SyncManager] Offline, skipping queue processing');
       return;
     }

     this.isProcessing = true;
     this.broadcast({ type: 'SYNC_STARTED' });

     try {
       const pending = await getPendingMutations();
       console.log(`[SyncManager] Processing ${pending.length} pending mutations`);

       for (const mutation of pending) {
         const success = await this.processMutation(mutation);
         if (!success && mutation.retries >= 5) {
           // Max retries reached, mark as failed
           await updateMutationStatus(mutation.id, { status: 'failed' });
           this.broadcast({ type: 'MUTATION_FAILED', payload: { mutation } });
         }
       }

       const queueLength = await this.getPendingCount();
       this.broadcast({ type: 'SYNC_COMPLETE', payload: { queueLength } });
     } catch (error) {
       console.error('[SyncManager] Queue processing error:', error);
       this.broadcast({ type: 'SYNC_ERROR', payload: { error: String(error) } });
     } finally {
       this.isProcessing = false;
     }
   }
   ```

3. Implement processMutation:
   ```typescript
   private async processMutation(mutation: MutationQueueEntry): Promise<boolean> {
     await updateMutationStatus(mutation.id, { status: 'syncing' });

     try {
       const url = this.buildApiUrl(mutation);
       const method = mutation.operation === 'create' ? 'POST' : 'PATCH';

       const response = await fetch(url, {
         method,
         headers: {
           'Content-Type': 'application/json',
           'Idempotency-Key': mutation.idempotencyKey,
         },
         body: JSON.stringify(mutation.payload),
         credentials: 'include',
       });

       if (response.ok || response.status === 202) {
         // Success or accepted (approval pipeline)
         await removeMutation(mutation.id);
         this.broadcast({ type: 'MUTATION_SYNCED', payload: { mutation } });
         return true;
       }

       if (!shouldRetry(new Error(`HTTP ${response.status}`), response)) {
         // Client error (4xx except 429), don't retry
         await updateMutationStatus(mutation.id, {
           status: 'failed',
           lastError: `HTTP ${response.status}: ${await response.text()}`,
         });
         return false;
       }

       // Retry later
       const delay = calculateRetryDelay(mutation.retries);
       await updateMutationStatus(mutation.id, {
         status: 'pending',
         retries: mutation.retries + 1,
       });
       console.log(`[SyncManager] Will retry mutation ${mutation.id} in ${delay}ms`);
       return false;
     } catch (error) {
       // Network error
       await updateMutationStatus(mutation.id, {
         status: 'pending',
         retries: mutation.retries + 1,
         lastError: String(error),
       });
       return false;
     }
   }
   ```

4. Implement buildApiUrl based on entity type:
   ```typescript
   private buildApiUrl(mutation: MutationQueueEntry): string {
     const workspaceId = typeof localStorage !== 'undefined'
       ? localStorage.getItem('workspace_id')
       : null;

     if (!workspaceId) {
       throw new Error('No workspace ID available');
     }

     const baseUrl = process.env.NEXT_PUBLIC_API_URL || '';
     const entityPath = `${baseUrl}/api/workspaces/${workspaceId}/${mutation.entity}`;

     if (mutation.operation === 'update' && mutation.entityId) {
       return `${entityPath}/${mutation.entityId}`;
     }
     return entityPath;
   }
   ```

5. Implement supportsBackgroundSync and setupFallbackListeners:
   ```typescript
   supportsBackgroundSync(): boolean {
     return typeof navigator !== 'undefined' &&
       'serviceWorker' in navigator &&
       'SyncManager' in window;
   }

   setupFallbackListeners(): () => void {
     const handleOnline = () => {
       console.log('[SyncManager] Online event - processing queue');
       this.processQueue();
     };

     const handleVisibilityChange = () => {
       if (document.visibilityState === 'visible' && navigator.onLine) {
         console.log('[SyncManager] Visibility change - processing queue');
         this.processQueue();
       }
     };

     window.addEventListener('online', handleOnline);
     document.addEventListener('visibilitychange', handleVisibilityChange);

     return () => {
       window.removeEventListener('online', handleOnline);
       document.removeEventListener('visibilitychange', handleVisibilityChange);
     };
   }
   ```

6. Export singleton instance:
   ```typescript
   export const syncManager = typeof window !== 'undefined' ? new SyncManager() : null;
   export { SyncManager };
   ```
  </action>
  <verify>
    - `bun run build` succeeds
    - `wc -l frontend/lib/sync/sync-manager.ts` shows >= 150 lines
    - `grep "BroadcastChannel" frontend/lib/sync/sync-manager.ts` shows channel setup
    - `grep "visibilitychange" frontend/lib/sync/sync-manager.ts` shows iOS fallback
  </verify>
  <done>
    - SyncManager class with queue processing and locking
    - BroadcastChannel for SW communication
    - iOS fallback with online + visibilitychange events
    - Retry logic with exponential backoff integrated
    - Singleton export for app-wide use
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate SyncManager into OfflineContext</name>
  <files>frontend/lib/contexts/offline-context.tsx</files>
  <action>
Update OfflineContext to:

1. Import SyncManager:
   ```typescript
   import { syncManager } from '@/lib/sync/sync-manager';
   import { getPendingMutationCount } from '@/lib/sync/mutation-queue';
   ```

2. Add pendingMutationCount to context value:
   ```typescript
   interface OfflineContextValue {
     // ... existing fields ...
     /** Count of pending offline mutations */
     pendingMutationCount: number;
     /** Whether mutations are currently syncing */
     isMutationSyncing: boolean;
     /** Manually trigger mutation queue processing */
     processMutationQueue: () => Promise<void>;
   }
   ```

3. Add state for pending mutations:
   ```typescript
   const [pendingMutationCount, setPendingMutationCount] = useState(0);
   const [isMutationSyncing, setIsMutationSyncing] = useState(false);
   ```

4. Setup SyncManager listeners in useEffect:
   ```typescript
   useEffect(() => {
     if (!syncManager) return;

     // Initial count
     getPendingMutationCount().then(setPendingMutationCount);

     // Subscribe to sync events
     const unsubscribe = syncManager.subscribe((event) => {
       switch (event.type) {
         case 'SYNC_STARTED':
           setIsMutationSyncing(true);
           break;
         case 'SYNC_COMPLETE':
         case 'SYNC_ERROR':
           setIsMutationSyncing(false);
           if (event.payload?.queueLength !== undefined) {
             setPendingMutationCount(event.payload.queueLength);
           }
           break;
         case 'QUEUE_UPDATED':
         case 'MUTATION_SYNCED':
         case 'MUTATION_FAILED':
           getPendingMutationCount().then(setPendingMutationCount);
           break;
       }
     });

     // Setup iOS fallback listeners
     const cleanupFallback = syncManager.setupFallbackListeners();

     return () => {
       unsubscribe();
       cleanupFallback();
     };
   }, []);
   ```

5. Add processMutationQueue function:
   ```typescript
   const processMutationQueue = useCallback(async () => {
     if (syncManager) {
       await syncManager.processQueue();
     }
   }, []);
   ```

6. Update context value to include new fields:
   ```typescript
   const value: OfflineContextValue = {
     // ... existing fields ...
     pendingMutationCount,
     isMutationSyncing,
     processMutationQueue,
   };
   ```

7. Also trigger mutation queue processing when coming back online (in addition to data sync):
   ```typescript
   // In the wasOffline effect
   useEffect(() => {
     if (wasOffline && isOnline && dbReady) {
       triggerSync();
       processMutationQueue(); // Add this
     }
   }, [wasOffline, isOnline, dbReady, triggerSync, processMutationQueue]);
   ```
  </action>
  <verify>
    - `bun run build` succeeds
    - `grep "pendingMutationCount" frontend/lib/contexts/offline-context.tsx` shows field added
    - `grep "syncManager" frontend/lib/contexts/offline-context.tsx` shows integration
    - `grep "setupFallbackListeners" frontend/lib/contexts/offline-context.tsx` shows iOS fallback setup
  </verify>
  <done>
    - OfflineContext exposes pendingMutationCount
    - OfflineContext exposes isMutationSyncing
    - SyncManager event subscription active
    - iOS fallback listeners initialized
    - Queue processing triggered on reconnection
  </done>
</task>

<task type="auto">
  <name>Task 3: Add BackgroundSync integration to service worker</name>
  <files>frontend/app/sw.ts</files>
  <action>
Update service worker to:

1. Add BroadcastChannel for communicating with main thread:
   ```typescript
   const syncChannel = new BroadcastChannel('sync-status');
   ```

2. Add sync event listener for Background Sync API (Chrome/Edge):
   ```typescript
   self.addEventListener('sync', (event) => {
     if (event.tag === 'mutation-queue-sync') {
       console.log('[SW] Background sync triggered');
       event.waitUntil(
         // Notify main thread to process queue
         syncChannel.postMessage({
           type: 'SYNC_REQUESTED',
           payload: { source: 'background-sync' },
         })
       );
     }
   });
   ```

3. Note: The actual queue processing happens in main thread (SyncManager).
   The SW just triggers main thread via BroadcastChannel.
   This is intentional - IndexedDB access is simpler in main thread.

4. Add listener for main thread requesting sync registration:
   ```typescript
   self.addEventListener('message', (event) => {
     if (event.data?.type === 'REGISTER_SYNC') {
       self.registration.sync.register('mutation-queue-sync').catch((error) => {
         console.warn('[SW] Background sync registration failed:', error);
         // Fallback handled by main thread online event
       });
     }
   });
   ```
  </action>
  <verify>
    - `bun run build` succeeds
    - `grep "sync-status" frontend/app/sw.ts` shows BroadcastChannel
    - `grep "mutation-queue-sync" frontend/app/sw.ts` shows sync tag
  </verify>
  <done>
    - Service worker handles Background Sync events
    - BroadcastChannel communicates sync requests to main thread
    - Sync registration message handler added
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `cd frontend && bun run build` - TypeScript compiles
2. Start dev server, go offline (DevTools Network tab), make note of console logs
3. Go back online, verify "[SyncManager] Online event" or "[SyncManager] Visibility change" in console
4. Check OfflineContext provides pendingMutationCount (inspect React DevTools)
</verification>

<success_criteria>
- [ ] SyncManager class created with processQueue, processMutation, buildApiUrl
- [ ] BroadcastChannel setup for SW communication
- [ ] iOS fallback: online event + visibilitychange handlers
- [ ] OfflineContext exposes: pendingMutationCount, isMutationSyncing, processMutationQueue
- [ ] Service worker handles 'sync' events
- [ ] Queue processing has lock to prevent concurrent runs
- [ ] Retry logic integrated with max 5 retries
</success_criteria>

<output>
After completion, create `.planning/phases/02-mutation-queue/02-02-SUMMARY.md`
</output>
