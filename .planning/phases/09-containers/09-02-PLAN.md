---
phase: 09-containers
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - frontend/e2e/offline/offline-containers.spec.ts
autonomous: true

must_haves:
  truths:
    - "E2E test verifies container can be created while offline with pending indicator"
    - "E2E test verifies container can be updated while offline with pending indicator"
    - "E2E test verifies container in pending location shows correct context badge"
    - "E2E test verifies dropdown menu is hidden for pending containers"
    - "E2E test verifies location dropdown shows pending locations"
  artifacts:
    - path: "frontend/e2e/offline/offline-containers.spec.ts"
      provides: "E2E test suite for offline container mutations"
      min_lines: 150
  key_links:
    - from: "offline-containers.spec.ts"
      to: "containers page"
      via: "Playwright navigation and interactions"
      pattern: 'page.goto.*containers'
---

<objective>
Create E2E tests for offline container mutations.

Purpose: Verify the complete offline create/update flow for containers including cross-entity dependency with pending locations, pending indicators with location context, and UI state for pending rows.

Output: Playwright test file `offline-containers.spec.ts` with comprehensive coverage of all offline container mutation scenarios.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-containers/09-RESEARCH.md

# Reference implementation - locations E2E tests
@frontend/e2e/offline/offline-locations.spec.ts

# Reference implementation - categories E2E tests
@frontend/e2e/offline/offline-categories.spec.ts

# Test fixtures
@frontend/e2e/fixtures/authenticated.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create E2E tests for offline container mutations</name>
  <files>frontend/e2e/offline/offline-containers.spec.ts</files>
  <action>
Create a new E2E test file for offline container mutations following the pattern from offline-locations.spec.ts:

```typescript
import { test, expect } from "../fixtures/authenticated";

/**
 * Offline container mutation E2E tests.
 *
 * Tests the full offline create/update flow for containers including
 * cross-entity location dependency:
 * - Create container while offline
 * - Update container while offline
 * - Create container in pending location
 * - Verify pending indicators with location context ("Pending... in [LocationName]")
 * - Verify dropdown menu hidden for pending containers
 * - Verify location dropdown shows pending locations
 *
 * Chromium only: WebKit and Firefox have inconsistent offline simulation.
 */
test.describe("Offline Container Mutations", () => {
  test.skip(({ browserName }) => browserName !== "chromium", "Chromium only");

  // Run tests serially to avoid auth state conflicts
  test.describe.configure({ mode: "serial" });

  test.beforeEach(async ({ page }) => {
    // Navigate to containers page and wait for it to load
    await page.goto("/en/dashboard/containers");
    await page.waitForLoadState("domcontentloaded");
    await expect(page.locator("main")).toBeVisible({ timeout: 15000 });
  });

  test("creates container while offline with pending indicator", async ({ page, context }) => {
    const uniqueName = `Offline Container ${Date.now()}`;

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));

    // Verify offline indicator appears
    const offlineIndicator = page.locator('[data-testid="offline-indicator"]');
    await expect(offlineIndicator).toBeVisible({ timeout: 5000 });

    // Click Add Container button
    await page.getByRole("button", { name: /Add Container/i }).click();

    // Wait for dialog to open
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    // Fill the form - name is required, location is required
    await page.getByLabel(/^Name/i).fill(uniqueName);

    // Select first available location from dropdown
    await page.locator('[role="combobox"]').first().click();
    await page.getByRole("option").first().click();

    // Submit the form
    await page.getByRole("button", { name: /Create/i }).click();

    // Dialog should close
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify optimistic container appears with pending indicator
    await expect(page.getByText(uniqueName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText(/Pending/)).toBeVisible({ timeout: 5000 });

    // Go back online
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for sync - pending indicator should disappear
    await expect(page.getByText(/Pending/)).not.toBeVisible({ timeout: 15000 });

    // Container should still be visible after sync
    await expect(page.getByText(uniqueName)).toBeVisible();
  });

  test("updates container while offline with pending indicator", async ({ page, context }) => {
    // First, ensure we have a container to update
    const containerRows = page.locator('tbody tr');

    // Wait for page to load first
    await page.waitForTimeout(2000);

    // If no containers exist, create one first (online)
    const rowCount = await containerRows.count();
    if (rowCount === 0) {
      await page.getByRole("button", { name: /Add Container/i }).click();
      await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });
      await page.getByLabel(/^Name/i).fill(`Test Container ${Date.now()}`);
      // Select first available location
      await page.locator('[role="combobox"]').first().click();
      await page.getByRole("option").first().click();
      await page.getByRole("button", { name: /Create/i }).click();
      await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });
      // Wait for container to appear
      await expect(containerRows.first()).toBeVisible({ timeout: 10000 });
    }

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));
    await expect(page.locator('[data-testid="offline-indicator"]')).toBeVisible({ timeout: 5000 });

    // Click on the first container's action menu (the MoreHorizontal button in last cell)
    const firstRow = containerRows.first();
    await firstRow.locator('button[aria-label]').last().click();
    await page.getByRole("menuitem", { name: /Edit/i }).click();

    // Wait for dialog
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    // Update the name
    const updatedName = `Updated Container ${Date.now()}`;
    await page.getByLabel(/^Name/i).clear();
    await page.getByLabel(/^Name/i).fill(updatedName);

    // Submit
    await page.getByRole("button", { name: /Update/i }).click();

    // Dialog should close
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify updated container appears with pending indicator
    await expect(page.getByText(updatedName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText(/Pending/)).toBeVisible({ timeout: 5000 });

    // Go back online
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for sync
    await expect(page.getByText(/Pending/)).not.toBeVisible({ timeout: 15000 });

    // Updated name should still be visible
    await expect(page.getByText(updatedName)).toBeVisible();
  });

  test("creates container in pending location with correct context", async ({ page, context }) => {
    const locationName = `Offline Location ${Date.now()}`;
    const containerName = `Container In Pending ${Date.now()}`;

    // First navigate to locations and create a location offline
    await page.goto("/en/dashboard/locations");
    await page.waitForLoadState("domcontentloaded");
    await expect(page.locator("main")).toBeVisible({ timeout: 15000 });

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));
    await expect(page.locator('[data-testid="offline-indicator"]')).toBeVisible({ timeout: 5000 });

    // Create location offline
    await page.getByRole("button", { name: /Add Location/i }).click();
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });
    await page.getByLabel(/^Name/i).fill(locationName);
    await page.getByRole("button", { name: /Create/i }).click();
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Navigate to containers page (still offline)
    await page.goto("/en/dashboard/containers");
    await page.waitForLoadState("domcontentloaded");
    await expect(page.locator("main")).toBeVisible({ timeout: 15000 });

    // Verify still offline
    await expect(page.locator('[data-testid="offline-indicator"]')).toBeVisible({ timeout: 5000 });

    // Create container in the pending location
    await page.getByRole("button", { name: /Add Container/i }).click();
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });
    await page.getByLabel(/^Name/i).fill(containerName);

    // Select the pending location (should show with "(pending)" suffix)
    await page.locator('[role="combobox"]').first().click();
    await page.getByRole("option", { name: new RegExp(`${locationName}.*pending`, "i") }).click();

    await page.getByRole("button", { name: /Create/i }).click();
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify container appears with pending indicator AND location context
    await expect(page.getByText(containerName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText(`Pending... in ${locationName}`)).toBeVisible({ timeout: 5000 });

    // Go online and verify sync order (location before container)
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Pending indicator should disappear
    await expect(page.getByText(/Pending/)).not.toBeVisible({ timeout: 15000 });

    // Container should remain visible
    await expect(page.getByText(containerName)).toBeVisible();
  });

  test("pending containers have no dropdown menu", async ({ page, context }) => {
    const containerName = `No Menu Container ${Date.now()}`;

    // Go offline and create a container
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));
    await expect(page.locator('[data-testid="offline-indicator"]')).toBeVisible({ timeout: 5000 });

    await page.getByRole("button", { name: /Add Container/i }).click();
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });
    await page.getByLabel(/^Name/i).fill(containerName);
    // Select first available location
    await page.locator('[role="combobox"]').first().click();
    await page.getByRole("option").first().click();
    await page.getByRole("button", { name: /Create/i }).click();
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify container appears
    await expect(page.getByText(containerName)).toBeVisible({ timeout: 5000 });

    // Find the pending container row
    const pendingRow = page.locator('tbody tr').filter({ hasText: containerName });
    await expect(pendingRow).toBeVisible();

    // Verify dropdown trigger button is NOT visible on the pending row
    // The dropdown trigger has aria-label "Actions for [container name]"
    const dropdownTrigger = pendingRow.locator(`button[aria-label="Actions for ${containerName}"]`);
    await expect(dropdownTrigger).not.toBeVisible();

    // Clean up - go online
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));
    await expect(page.getByText(/Pending/)).not.toBeVisible({ timeout: 15000 });
  });
});
```

Key differences from locations tests:
- Containers use table rows (`tbody tr`) instead of tree items (`[role="treeitem"]`)
- Container form requires selecting a location from dropdown
- Context badge uses "in" instead of "under"
- Cross-page navigation to create pending location before container
  </action>
  <verify>
Run `cd frontend && npx playwright test offline-containers.spec.ts --list` to verify tests are properly structured and can be listed.
  </verify>
  <done>
E2E test file exists at frontend/e2e/offline/offline-containers.spec.ts with 4 tests covering:
- Create container while offline with pending indicator
- Update container while offline with pending indicator
- Create container in pending location with correct context badge
- Pending containers have no dropdown menu
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify test file compiles and lists correctly</name>
  <files>frontend/e2e/offline/offline-containers.spec.ts</files>
  <action>
Verify the test file is correctly structured:

1. Run `cd frontend && npx playwright test offline-containers.spec.ts --list` to list all tests
2. Verify 4 tests are listed:
   - "creates container while offline with pending indicator"
   - "updates container while offline with pending indicator"
   - "creates container in pending location with correct context"
   - "pending containers have no dropdown menu"
3. Run `cd frontend && npx tsc --noEmit` to verify TypeScript compilation

If any issues, fix the test file accordingly.
  </action>
  <verify>
`npx playwright test offline-containers.spec.ts --list` shows 4 tests.
`npx tsc --noEmit` passes.
  </verify>
  <done>
Test file compiles without TypeScript errors.
All 4 tests are listed by Playwright.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Verify tests are listed:
   ```bash
   cd frontend && npx playwright test offline-containers.spec.ts --list
   ```
   Should show 4 tests in "Offline Container Mutations" describe block.

2. TypeScript compilation:
   ```bash
   cd frontend && npx tsc --noEmit
   ```

3. Optionally run tests (may fail if auth setup has issues - known blocker):
   ```bash
   cd frontend && npx playwright test offline-containers.spec.ts --project=chromium
   ```

Note: E2E tests may have auth timing issues as noted in STATE.md blockers. Tests are correctly written; auth fix is separate concern.
</verification>

<success_criteria>
- [ ] Test file exists at frontend/e2e/offline/offline-containers.spec.ts
- [ ] Test file follows offline-locations.spec.ts pattern
- [ ] 4 tests covering all offline container mutation scenarios
- [ ] Tests use serial mode and chromium-only skip
- [ ] Cross-page navigation test for pending location dependency
- [ ] TypeScript compiles without errors
- [ ] Playwright lists all 4 tests
</success_criteria>

<output>
After completion, create `.planning/phases/09-containers/09-02-SUMMARY.md` using summary template.
</output>
