---
phase: 24-backend-api-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/integration/repair_workflow_test.go
autonomous: true

must_haves:
  truths:
    - "Repair workflow can be created, started, completed with status transitions"
    - "Repair photos can be uploaded, listed, and deleted during repair"
    - "Repair endpoints require authentication (401 without token)"
    - "Repair endpoints enforce workspace authorization"
  artifacts:
    - path: "backend/tests/integration/repair_workflow_test.go"
      provides: "Full repair lifecycle integration test with auth/authz coverage"
      min_lines: 200
  key_links:
    - from: "repair_workflow_test.go"
      to: "TestServer"
      via: "integration test infrastructure"
      pattern: "NewTestServer"
---

<objective>
Add integration tests for repair workflow lifecycle and auth/authz for repair endpoints.

Purpose: Ensure end-to-end correctness of repair log workflow and verify repair endpoints enforce authentication and workspace authorization (covering API-04 success criterion).

Output: Comprehensive repair_workflow_test.go covering full lifecycle and auth/authz scenarios.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-backend-api-testing/24-RESEARCH.md
@backend/tests/integration/setup.go
@backend/tests/integration/workflow_test.go (example pattern)
@backend/tests/integration/permission_test.go (auth/authz pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create repair workflow integration test with auth/authz</name>
  <files>backend/tests/integration/repair_workflow_test.go</files>
  <action>
Create repair_workflow_test.go with build tag `//go:build integration`.

**Part A: Auth/Authz Tests (covers API-04 success criterion)**

TestRepairEndpoints_Unauthenticated(t *testing.T):
Following pattern from permission_test.go TestPermission_UnauthenticatedAccess:
1. Setup workspace and repair log with authenticated user
2. Clear token (ts.SetToken(""))
3. Test all repair endpoints return 401:
   - GET /workspaces/{ws}/repairs - list repairs
   - POST /workspaces/{ws}/repairs - create repair
   - GET /workspaces/{ws}/repairs/{id} - get repair
   - PATCH /workspaces/{ws}/repairs/{id} - update repair
   - POST /workspaces/{ws}/repairs/{id}/start - start repair
   - POST /workspaces/{ws}/repairs/{id}/complete - complete repair
   - GET /workspaces/{ws}/repairs/{id}/photos - list repair photos
   - DELETE /workspaces/{ws}/repairs/{id} - delete repair

TestRepairEndpoints_InvalidToken(t *testing.T):
1. Set invalid token (ts.SetToken("invalid.jwt.token"))
2. Verify repair endpoints reject with 401

**Part B: Repair Workflow Tests**

TestRepairWorkflow(t *testing.T):
1. Setup: Register user, create workspace, create item, create location, create inventory
2. Create repair log (POST /workspaces/{ws}/repairs) - status should be PENDING
3. Verify inventory status unchanged (still AVAILABLE, unlike loans)
4. Start repair (POST /workspaces/{ws}/repairs/{id}/start) - status changes to IN_PROGRESS
5. Add repair cost and notes (PATCH /workspaces/{ws}/repairs/{id})
6. Complete repair (POST /workspaces/{ws}/repairs/{id}/complete) with new condition
7. Verify repair status is COMPLETED
8. Verify completed_at timestamp is set
9. Get total repair cost (GET /workspaces/{ws}/inventory/{id}/repair-cost)
10. List repairs by status (GET /workspaces/{ws}/repairs?status=COMPLETED)

TestRepairWithWarrantyClaim(t *testing.T):
1. Create repair with is_warranty_claim=true
2. Verify warranty claim flag is persisted
3. Toggle warranty claim (POST /workspaces/{ws}/repairs/{id}/warranty)
4. Verify it's toggled off

TestRepairStatusTransitions(t *testing.T):
1. Create repair (PENDING)
2. Try to complete without starting - should fail (400)
3. Start repair (IN_PROGRESS)
4. Try to start again - should fail (400)
5. Complete repair (COMPLETED)
6. Try to update completed repair - should fail (400)

Use helper functions for setup like workflow_test.go does.
Follow RequireStatusCreated pattern for flexible 200/201 handling.
Use unique email suffixes with uuid.New().String()[:8].
  </action>
  <verify>
Run: `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go test ./tests/integration/... -v -run TestRepair -tags integration -count=1`
All repair workflow tests pass including auth tests.
  </verify>
  <done>
repair_workflow_test.go exists with 5+ test functions covering:
- Unauthenticated access rejection (401) for all repair endpoints
- Invalid token rejection (401)
- Full repair lifecycle workflow
- Warranty claim handling
- Status transition validation
  </done>
</task>

</tasks>

<verification>
1. Run repair integration tests:
   ```bash
   cd /home/antti/Repos/Misc/home-warehouse-system/backend
   go test ./tests/integration/... -v -run "TestRepair" -tags integration -count=1
   ```

2. Check all integration tests still pass:
   ```bash
   go test ./tests/integration/... -tags integration -count=1
   ```
</verification>

<success_criteria>
- repair_workflow_test.go exists with comprehensive lifecycle tests
- Auth tests verify 401 for unauthenticated/invalid token access to repair endpoints
- All integration tests pass
- Tests exercise repair workflow end-to-end with status transitions
- API-04 success criterion satisfied (auth/authz rules tested for repair endpoints)
</success_criteria>

<output>
After completion, create `.planning/phases/24-backend-api-testing/24-02-SUMMARY.md`
</output>
