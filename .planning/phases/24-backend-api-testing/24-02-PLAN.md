---
phase: 24-backend-api-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/integration/repair_workflow_test.go
  - backend/tests/integration/sync_test.go
autonomous: true

must_haves:
  truths:
    - "Repair workflow can be created, started, completed with status transitions"
    - "Repair photos can be uploaded, listed, and deleted during repair"
    - "Sync endpoints handle offline mutations correctly"
    - "Batch operations process multiple entities atomically"
  artifacts:
    - path: "backend/tests/integration/repair_workflow_test.go"
      provides: "Full repair lifecycle integration test"
      min_lines: 150
    - path: "backend/tests/integration/sync_test.go"
      provides: "Sync and batch operation tests"
      min_lines: 100
  key_links:
    - from: "repair_workflow_test.go"
      to: "TestServer"
      via: "integration test infrastructure"
      pattern: "NewTestServer"
---

<objective>
Add integration tests for critical multi-entity workflows that span multiple services.

Purpose: Ensure end-to-end correctness of repair log workflow and sync/batch operations that are difficult to test with unit tests alone.

Output: Two new integration test files covering repair lifecycle and sync operations.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-backend-api-testing/24-RESEARCH.md
@backend/tests/integration/setup.go
@backend/tests/integration/workflow_test.go (example pattern)
@backend/tests/integration/batch_test.go (batch operations pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create repair workflow integration test</name>
  <files>backend/tests/integration/repair_workflow_test.go</files>
  <action>
Create repair_workflow_test.go with build tag `//go:build integration`.

Test the full repair lifecycle:

TestRepairWorkflow(t *testing.T):
1. Setup: Register user, create workspace, create item, create location, create inventory
2. Create repair log (POST /workspaces/{ws}/repairs) - status should be PENDING
3. Verify inventory status unchanged (still AVAILABLE, unlike loans)
4. Start repair (POST /workspaces/{ws}/repairs/{id}/start) - status changes to IN_PROGRESS
5. Add repair cost and notes (PATCH /workspaces/{ws}/repairs/{id})
6. Complete repair (POST /workspaces/{ws}/repairs/{id}/complete) with new condition
7. Verify repair status is COMPLETED
8. Verify completed_at timestamp is set
9. Get total repair cost (GET /workspaces/{ws}/inventory/{id}/repair-cost)
10. List repairs by status (GET /workspaces/{ws}/repairs?status=COMPLETED)

TestRepairWithWarrantyClaim(t *testing.T):
1. Create repair with is_warranty_claim=true
2. Verify warranty claim flag is persisted
3. Toggle warranty claim (POST /workspaces/{ws}/repairs/{id}/warranty)
4. Verify it's toggled off

TestRepairStatusTransitions(t *testing.T):
1. Create repair (PENDING)
2. Try to complete without starting - should fail (400)
3. Start repair (IN_PROGRESS)
4. Try to start again - should fail (400)
5. Complete repair (COMPLETED)
6. Try to update completed repair - should fail (400)

Use helper functions for setup like workflow_test.go does.
Follow RequireStatusCreated pattern for flexible 200/201 handling.
Use unique email suffixes with uuid.New().String()[:8].
  </action>
  <verify>
Run: `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go test ./tests/integration/... -v -run TestRepair -tags integration -count=1`
All repair workflow tests pass.
  </verify>
  <done>
repair_workflow_test.go exists with 3+ test functions covering full repair lifecycle, warranty claims, and status transition validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sync and batch operation tests</name>
  <files>backend/tests/integration/sync_test.go</files>
  <action>
Create sync_test.go with build tag `//go:build integration`.

If sync endpoints exist, test them. Check for:
- POST /workspaces/{ws}/sync/push - push offline mutations
- POST /workspaces/{ws}/sync/pull - pull latest state
- POST /workspaces/{ws}/batch - batch operations

TestSyncPush(t *testing.T):
1. Setup: User, workspace
2. Create offline mutations array
3. POST to sync/push endpoint
4. Verify entities were created
5. Verify response includes sync tokens

TestSyncPull(t *testing.T):
1. Setup: User, workspace with some entities
2. GET sync/pull with last_sync timestamp
3. Verify delta changes returned
4. Verify updated_after filtering works

TestBatchOperations(t *testing.T):
1. Setup: User, workspace
2. Create batch request with multiple operations:
   - Create item
   - Create location
   - Create inventory linking them
3. POST to batch endpoint
4. Verify all operations succeeded
5. Test partial failure handling if applicable

If sync endpoints don't exist (check routes), focus on batch operations.
Check batch_test.go for existing patterns - extend if needed.
  </action>
  <verify>
Run: `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go test ./tests/integration/... -v -run TestSync -tags integration -count=1`
And: `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go test ./tests/integration/... -v -run TestBatch -tags integration -count=1`
  </verify>
  <done>
sync_test.go exists with tests for sync/batch endpoints that are implemented, or extended batch tests if sync endpoints don't exist.
  </done>
</task>

</tasks>

<verification>
1. Run integration tests:
   ```bash
   cd /home/antti/Repos/Misc/home-warehouse-system/backend
   go test ./tests/integration/... -v -run "TestRepair|TestSync|TestBatch" -tags integration -count=1
   ```

2. Check all integration tests still pass:
   ```bash
   go test ./tests/integration/... -tags integration -count=1
   ```
</verification>

<success_criteria>
- repair_workflow_test.go exists with comprehensive lifecycle tests
- sync_test.go exists (or batch tests extended)
- All integration tests pass
- Tests exercise multi-entity workflows end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/24-backend-api-testing/24-02-SUMMARY.md`
</output>
