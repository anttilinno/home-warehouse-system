---
phase: 14-declutter-assistant
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - backend/internal/domain/warehouse/declutter/entity.go
  - backend/internal/domain/warehouse/declutter/service.go
  - backend/internal/domain/warehouse/declutter/repository.go
  - backend/internal/domain/warehouse/declutter/handler.go
  - backend/internal/infra/postgres/declutter_repository.go
  - backend/internal/api/router.go
autonomous: true

must_haves:
  truths:
    - "GET /workspaces/{id}/declutter returns list of unused inventory"
    - "GET /workspaces/{id}/declutter/counts returns summary counts for 90/180/365 days"
    - "POST /workspaces/{id}/inventory/{id}/mark-used updates last_used_at"
    - "Declutter score calculated server-side combining age and value"
    - "List supports group_by=category|location|none query parameter"
  artifacts:
    - path: "backend/internal/domain/warehouse/declutter/entity.go"
      provides: "DeclutterItem and DeclutterCounts types"
      contains: "type DeclutterItem struct"
    - path: "backend/internal/domain/warehouse/declutter/service.go"
      provides: "Business logic for scoring and listing"
      contains: "func (s *Service) ListUnused"
    - path: "backend/internal/domain/warehouse/declutter/handler.go"
      provides: "HTTP handlers for declutter endpoints"
      contains: "func (h *Handler) List"
    - path: "backend/internal/infra/postgres/declutter_repository.go"
      provides: "PostgreSQL repository implementation"
      contains: "func (r *DeclutterRepository) FindUnused"
  key_links:
    - from: "backend/internal/domain/warehouse/declutter/handler.go"
      to: "backend/internal/domain/warehouse/declutter/service.go"
      via: "h.service.ListUnused"
      pattern: "service\\.ListUnused"
    - from: "backend/internal/api/router.go"
      to: "backend/internal/domain/warehouse/declutter"
      via: "declutter.RegisterRoutes"
      pattern: "declutter\\.RegisterRoutes"
---

<objective>
Create declutter domain package with entity, service, repository, and HTTP handlers following existing codebase patterns.

Purpose: Provide API endpoints for the declutter assistant feature with server-side score calculation.
Output: Working API endpoints for listing unused items, getting counts, and marking items as used.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-declutter-assistant/14-RESEARCH.md
@.planning/phases/14-declutter-assistant/14-01-SUMMARY.md

@backend/internal/domain/warehouse/repairlog/entity.go
@backend/internal/domain/warehouse/repairlog/service.go
@backend/internal/domain/warehouse/repairlog/handler.go
@backend/internal/domain/warehouse/repairlog/repository.go
@backend/internal/infra/postgres/repairlog_repository.go
@backend/internal/api/router.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create declutter domain entity and types</name>
  <files>
    backend/internal/domain/warehouse/declutter/entity.go
  </files>
  <action>
Create `backend/internal/domain/warehouse/declutter/` directory and `entity.go` with:

```go
package declutter

import (
    "time"
    "github.com/google/uuid"
)

// DeclutterItem represents an inventory item with declutter-specific metadata.
type DeclutterItem struct {
    ID           uuid.UUID
    WorkspaceID  uuid.UUID
    ItemID       uuid.UUID
    LocationID   uuid.UUID
    ContainerID  *uuid.UUID
    Quantity     int
    Condition    *string
    Status       *string
    PurchasePrice *int  // cents
    CurrencyCode *string
    LastUsedAt   *time.Time
    CreatedAt    time.Time
    UpdatedAt    time.Time

    // Joined fields
    ItemName     string
    ItemSku      *string
    LocationName string
    CategoryName *string
    CategoryID   *uuid.UUID

    // Computed fields
    DaysUnused   int
    Score        int  // Calculated declutter priority score (0-150)
}

// DeclutterCounts holds summary statistics for different thresholds.
type DeclutterCounts struct {
    Unused90  int   // Count of items unused for 90+ days
    Unused180 int   // Count of items unused for 180+ days
    Unused365 int   // Count of items unused for 365+ days
    Value90   int64 // Total value (cents) of items unused 90+ days
    Value180  int64 // Total value (cents) of items unused 180+ days
    Value365  int64 // Total value (cents) of items unused 365+ days
}

// ListParams defines parameters for listing unused inventory.
type ListParams struct {
    ThresholdDays int    // Number of days to consider "unused" (default 90)
    GroupBy       string // "category", "location", or "" (none)
    Page          int    // Pagination page (1-indexed)
    Limit         int    // Items per page (default 50)
}

// CalculateScore computes the declutter priority score for an item.
// Score = (days_unused / threshold) * 100 + inverse_value_percentile * 50
// Higher score = higher priority to declutter (old and low-value items)
// Range: 0-150 (100 for age + 50 for value)
func CalculateScore(daysUnused int, threshold int, valueCents int, maxValueCents int) int {
    if threshold <= 0 {
        threshold = 90 // default
    }

    // Age score: 0-100 based on how far past threshold
    ageScore := float64(daysUnused) / float64(threshold) * 100
    if ageScore > 100 {
        ageScore = 100
    }

    // Value score: 0-50, lower value = higher score (easier to declutter)
    valueScore := 50.0 // default if no max or zero value
    if maxValueCents > 0 && valueCents > 0 {
        // Inverse percentile: low value items score higher
        valueScore = (1 - float64(valueCents)/float64(maxValueCents)) * 50
    }

    return int(ageScore + valueScore)
}
```
  </action>
  <verify>File compiles: `go build ./backend/internal/domain/warehouse/declutter/...`</verify>
  <done>DeclutterItem, DeclutterCounts, ListParams types and CalculateScore function exist</done>
</task>

<task type="auto">
  <name>Task 2: Create repository interface and PostgreSQL implementation</name>
  <files>
    backend/internal/domain/warehouse/declutter/repository.go
    backend/internal/infra/postgres/declutter_repository.go
  </files>
  <action>
Create `repository.go` in the declutter package:

```go
package declutter

import (
    "context"
    "github.com/google/uuid"
)

// Repository defines the data access interface for declutter operations.
type Repository interface {
    // FindUnused returns inventory items unused for the specified threshold.
    FindUnused(ctx context.Context, workspaceID uuid.UUID, params ListParams) ([]DeclutterItem, int, error)

    // GetCounts returns summary counts for different unused thresholds.
    GetCounts(ctx context.Context, workspaceID uuid.UUID) (*DeclutterCounts, error)

    // GetMaxValue returns the maximum purchase price in the workspace.
    GetMaxValue(ctx context.Context, workspaceID uuid.UUID) (int, error)

    // MarkUsed updates the last_used_at timestamp for an inventory item.
    MarkUsed(ctx context.Context, workspaceID, inventoryID uuid.UUID) error
}
```

Create `declutter_repository.go` in `backend/internal/infra/postgres/`:

```go
package postgres

import (
    "context"

    "github.com/google/uuid"
    "github.com/jackc/pgx/v5/pgxpool"

    "github.com/antti/home-warehouse/go-backend/internal/domain/warehouse/declutter"
    "github.com/antti/home-warehouse/go-backend/internal/infra/queries"
    "github.com/antti/home-warehouse/go-backend/internal/shared"
)

// DeclutterRepository implements declutter.Repository using PostgreSQL.
type DeclutterRepository struct {
    pool *pgxpool.Pool
    q    *queries.Queries
}

// NewDeclutterRepository creates a new PostgreSQL declutter repository.
func NewDeclutterRepository(pool *pgxpool.Pool) *DeclutterRepository {
    return &DeclutterRepository{
        pool: pool,
        q:    queries.New(pool),
    }
}

// FindUnused returns inventory items unused for the specified threshold.
func (r *DeclutterRepository) FindUnused(ctx context.Context, workspaceID uuid.UUID, params declutter.ListParams) ([]declutter.DeclutterItem, int, error) {
    // Set defaults
    if params.ThresholdDays <= 0 {
        params.ThresholdDays = 90
    }
    if params.Limit <= 0 {
        params.Limit = 50
    }
    if params.Page <= 0 {
        params.Page = 1
    }
    offset := (params.Page - 1) * params.Limit

    // Get total count
    total, err := r.q.CountUnusedInventory(ctx, queries.CountUnusedInventoryParams{
        WorkspaceID:   workspaceID,
        ThresholdDays: int32(params.ThresholdDays),
    })
    if err != nil {
        return nil, 0, err
    }

    // Get items
    rows, err := r.q.ListUnusedInventory(ctx, queries.ListUnusedInventoryParams{
        WorkspaceID:   workspaceID,
        ThresholdDays: int32(params.ThresholdDays),
        GroupBy:       params.GroupBy,
        Limit:         int32(params.Limit),
        Offset:        int32(offset),
    })
    if err != nil {
        return nil, 0, err
    }

    items := make([]declutter.DeclutterItem, len(rows))
    for i, row := range rows {
        items[i] = declutter.DeclutterItem{
            ID:           row.ID,
            WorkspaceID:  row.WorkspaceID,
            ItemID:       row.ItemID,
            LocationID:   row.LocationID,
            ContainerID:  shared.NullUUIDToPtr(row.ContainerID),
            Quantity:     int(row.Quantity),
            Condition:    shared.NullStringToPtr(row.Condition),
            Status:       shared.NullStringToPtr(row.Status),
            PurchasePrice: shared.NullInt32ToPtr(row.PurchasePrice),
            CurrencyCode: shared.NullStringToPtr(row.CurrencyCode),
            LastUsedAt:   shared.NullTimeToPtr(row.LastUsedAt),
            CreatedAt:    row.CreatedAt.Time,
            UpdatedAt:    row.UpdatedAt.Time,
            ItemName:     row.ItemName,
            ItemSku:      shared.NullStringToPtr(row.ItemSku),
            LocationName: row.LocationName,
            CategoryName: shared.NullStringToPtr(row.CategoryName),
            CategoryID:   shared.NullUUIDToPtr(row.CategoryID),
            DaysUnused:   int(row.DaysUnused),
        }
    }

    return items, int(total), nil
}

// GetCounts returns summary counts for different unused thresholds.
func (r *DeclutterRepository) GetCounts(ctx context.Context, workspaceID uuid.UUID) (*declutter.DeclutterCounts, error) {
    row, err := r.q.GetUnusedInventoryCounts(ctx, workspaceID)
    if err != nil {
        return nil, err
    }

    return &declutter.DeclutterCounts{
        Unused90:  int(row.Unused90),
        Unused180: int(row.Unused180),
        Unused365: int(row.Unused365),
        Value90:   row.Value90,
        Value180:  row.Value180,
        Value365:  row.Value365,
    }, nil
}

// GetMaxValue returns the maximum purchase price in the workspace.
func (r *DeclutterRepository) GetMaxValue(ctx context.Context, workspaceID uuid.UUID) (int, error) {
    max, err := r.q.GetMaxInventoryValue(ctx, workspaceID)
    if err != nil {
        return 0, err
    }
    return int(max), nil
}

// MarkUsed updates the last_used_at timestamp for an inventory item.
func (r *DeclutterRepository) MarkUsed(ctx context.Context, workspaceID, inventoryID uuid.UUID) error {
    _, err := r.q.MarkInventoryUsed(ctx, queries.MarkInventoryUsedParams{
        ID:          inventoryID,
        WorkspaceID: workspaceID,
    })
    return err
}
```

Note: You may need to add helper functions to shared package if they don't exist (NullInt32ToPtr, etc). Check existing patterns in postgres package files.
  </action>
  <verify>`go build ./backend/internal/infra/postgres/...` compiles</verify>
  <done>Repository interface and PostgreSQL implementation exist and compile</done>
</task>

<task type="auto">
  <name>Task 3: Create service with score calculation and handler with routes</name>
  <files>
    backend/internal/domain/warehouse/declutter/service.go
    backend/internal/domain/warehouse/declutter/handler.go
    backend/internal/api/router.go
  </files>
  <action>
Create `service.go`:

```go
package declutter

import (
    "context"
    "github.com/google/uuid"
)

// Service provides business logic for declutter operations.
type Service struct {
    repo Repository
}

// NewService creates a new declutter service.
func NewService(repo Repository) *Service {
    return &Service{repo: repo}
}

// ListUnused returns unused inventory items with calculated scores.
func (s *Service) ListUnused(ctx context.Context, workspaceID uuid.UUID, params ListParams) ([]DeclutterItem, int, error) {
    items, total, err := s.repo.FindUnused(ctx, workspaceID, params)
    if err != nil {
        return nil, 0, err
    }

    // Get max value for score calculation
    maxValue, err := s.repo.GetMaxValue(ctx, workspaceID)
    if err != nil {
        return nil, 0, err
    }

    // Calculate scores for each item
    threshold := params.ThresholdDays
    if threshold <= 0 {
        threshold = 90
    }
    for i := range items {
        valueCents := 0
        if items[i].PurchasePrice != nil {
            valueCents = *items[i].PurchasePrice
        }
        items[i].Score = CalculateScore(items[i].DaysUnused, threshold, valueCents, maxValue)
    }

    return items, total, nil
}

// GetCounts returns summary counts for unused items at different thresholds.
func (s *Service) GetCounts(ctx context.Context, workspaceID uuid.UUID) (*DeclutterCounts, error) {
    return s.repo.GetCounts(ctx, workspaceID)
}

// MarkUsed updates an inventory item's last_used_at to now.
func (s *Service) MarkUsed(ctx context.Context, workspaceID, inventoryID uuid.UUID) error {
    return s.repo.MarkUsed(ctx, workspaceID, inventoryID)
}
```

Create `handler.go`:

```go
package declutter

import (
    "context"
    "net/http"
    "strconv"

    "github.com/danielgtaylor/huma/v2"
    "github.com/google/uuid"

    appMiddleware "github.com/antti/home-warehouse/go-backend/internal/api/middleware"
    "github.com/antti/home-warehouse/go-backend/internal/domain/events"
)

// Handler handles HTTP requests for declutter operations.
type Handler struct {
    service     *Service
    broadcaster events.Broadcaster
}

// NewHandler creates a new declutter handler.
func NewHandler(service *Service, broadcaster events.Broadcaster) *Handler {
    return &Handler{
        service:     service,
        broadcaster: broadcaster,
    }
}

// ListInput defines the input for listing unused inventory.
type ListInput struct {
    WorkspaceID   uuid.UUID `path:"workspace_id"`
    ThresholdDays int       `query:"threshold_days" default:"90" minimum:"1" maximum:"3650"`
    GroupBy       string    `query:"group_by" enum:"category,location," default:""`
    Page          int       `query:"page" default:"1" minimum:"1"`
    Limit         int       `query:"limit" default:"50" minimum:"1" maximum:"200"`
}

// ListOutput defines the response for listing unused inventory.
type ListOutput struct {
    Body struct {
        Items      []DeclutterItemResponse `json:"items"`
        Total      int                     `json:"total"`
        Page       int                     `json:"page"`
        TotalPages int                     `json:"total_pages"`
    }
}

// DeclutterItemResponse is the JSON response for a declutter item.
type DeclutterItemResponse struct {
    ID            uuid.UUID  `json:"id"`
    WorkspaceID   uuid.UUID  `json:"workspace_id"`
    ItemID        uuid.UUID  `json:"item_id"`
    LocationID    uuid.UUID  `json:"location_id"`
    ContainerID   *uuid.UUID `json:"container_id,omitempty"`
    Quantity      int        `json:"quantity"`
    Condition     *string    `json:"condition,omitempty"`
    Status        *string    `json:"status,omitempty"`
    PurchasePrice *int       `json:"purchase_price,omitempty"`
    CurrencyCode  *string    `json:"currency_code,omitempty"`
    LastUsedAt    *string    `json:"last_used_at,omitempty"`
    ItemName      string     `json:"item_name"`
    ItemSku       *string    `json:"item_sku,omitempty"`
    LocationName  string     `json:"location_name"`
    CategoryName  *string    `json:"category_name,omitempty"`
    CategoryID    *uuid.UUID `json:"category_id,omitempty"`
    DaysUnused    int        `json:"days_unused"`
    Score         int        `json:"score"`
}

// List handles GET /workspaces/{workspace_id}/declutter
func (h *Handler) List(ctx context.Context, input *ListInput) (*ListOutput, error) {
    params := ListParams{
        ThresholdDays: input.ThresholdDays,
        GroupBy:       input.GroupBy,
        Page:          input.Page,
        Limit:         input.Limit,
    }

    items, total, err := h.service.ListUnused(ctx, input.WorkspaceID, params)
    if err != nil {
        return nil, huma.Error500InternalServerError("failed to list unused items", err)
    }

    resp := &ListOutput{}
    resp.Body.Items = make([]DeclutterItemResponse, len(items))
    for i, item := range items {
        resp.Body.Items[i] = toDeclutterItemResponse(item)
    }
    resp.Body.Total = total
    resp.Body.Page = input.Page
    resp.Body.TotalPages = (total + input.Limit - 1) / input.Limit

    return resp, nil
}

// CountsInput defines input for getting unused counts.
type CountsInput struct {
    WorkspaceID uuid.UUID `path:"workspace_id"`
}

// CountsOutput defines response for unused counts.
type CountsOutput struct {
    Body struct {
        Unused90  int   `json:"unused_90"`
        Unused180 int   `json:"unused_180"`
        Unused365 int   `json:"unused_365"`
        Value90   int64 `json:"value_90"`
        Value180  int64 `json:"value_180"`
        Value365  int64 `json:"value_365"`
    }
}

// GetCounts handles GET /workspaces/{workspace_id}/declutter/counts
func (h *Handler) GetCounts(ctx context.Context, input *CountsInput) (*CountsOutput, error) {
    counts, err := h.service.GetCounts(ctx, input.WorkspaceID)
    if err != nil {
        return nil, huma.Error500InternalServerError("failed to get counts", err)
    }

    resp := &CountsOutput{}
    resp.Body.Unused90 = counts.Unused90
    resp.Body.Unused180 = counts.Unused180
    resp.Body.Unused365 = counts.Unused365
    resp.Body.Value90 = counts.Value90
    resp.Body.Value180 = counts.Value180
    resp.Body.Value365 = counts.Value365

    return resp, nil
}

// MarkUsedInput defines input for marking inventory as used.
type MarkUsedInput struct {
    WorkspaceID uuid.UUID `path:"workspace_id"`
    InventoryID uuid.UUID `path:"inventory_id"`
}

// MarkUsedOutput defines response for marking inventory as used.
type MarkUsedOutput struct {
    Body struct {
        Success bool `json:"success"`
    }
}

// MarkUsed handles POST /workspaces/{workspace_id}/inventory/{inventory_id}/mark-used
func (h *Handler) MarkUsed(ctx context.Context, input *MarkUsedInput) (*MarkUsedOutput, error) {
    err := h.service.MarkUsed(ctx, input.WorkspaceID, input.InventoryID)
    if err != nil {
        return nil, huma.Error500InternalServerError("failed to mark as used", err)
    }

    // Emit SSE event for real-time update
    h.broadcaster.Publish(ctx, events.Event{
        Type:       "inventory.used",
        EntityType: "inventory",
        EntityID:   input.InventoryID,
        Payload: map[string]interface{}{
            "inventory_id": input.InventoryID,
        },
    })

    resp := &MarkUsedOutput{}
    resp.Body.Success = true
    return resp, nil
}

// RegisterRoutes registers the declutter API routes.
func RegisterRoutes(api huma.API, service *Service, broadcaster events.Broadcaster) {
    handler := NewHandler(service, broadcaster)

    huma.Get(api, "/declutter", handler.List,
        huma.WithTags("Declutter"),
        huma.WithDescription("List unused inventory items with declutter scores"))

    huma.Get(api, "/declutter/counts", handler.GetCounts,
        huma.WithTags("Declutter"),
        huma.WithDescription("Get summary counts of unused items at different thresholds"))

    huma.Post(api, "/inventory/{inventory_id}/mark-used", handler.MarkUsed,
        huma.WithTags("Declutter"),
        huma.WithDescription("Mark an inventory item as recently used"))
}

// Helper function to convert domain to response
func toDeclutterItemResponse(item DeclutterItem) DeclutterItemResponse {
    resp := DeclutterItemResponse{
        ID:            item.ID,
        WorkspaceID:   item.WorkspaceID,
        ItemID:        item.ItemID,
        LocationID:    item.LocationID,
        ContainerID:   item.ContainerID,
        Quantity:      item.Quantity,
        Condition:     item.Condition,
        Status:        item.Status,
        PurchasePrice: item.PurchasePrice,
        CurrencyCode:  item.CurrencyCode,
        ItemName:      item.ItemName,
        ItemSku:       item.ItemSku,
        LocationName:  item.LocationName,
        CategoryName:  item.CategoryName,
        CategoryID:    item.CategoryID,
        DaysUnused:    item.DaysUnused,
        Score:         item.Score,
    }
    if item.LastUsedAt != nil {
        t := item.LastUsedAt.Format("2006-01-02T15:04:05Z")
        resp.LastUsedAt = &t
    }
    return resp
}
```

Update `router.go` to register declutter routes:

1. Add import: `"github.com/antti/home-warehouse/go-backend/internal/domain/warehouse/declutter"`
2. After the repairlog repository init (~line 144), add: `declutterRepo := postgres.NewDeclutterRepository(pool)`
3. After repairlog service init (~line 206), add: `declutterSvc := declutter.NewService(declutterRepo)`
4. Inside the workspace-scoped routes block (after repair routes ~line 367), add:
   `declutter.RegisterRoutes(wsAPI, declutterSvc, broadcaster)`
  </action>
  <verify>`mise run build` compiles, test with `curl http://localhost:8000/workspaces/{id}/declutter`</verify>
  <done>Declutter API endpoints functional: GET /declutter, GET /declutter/counts, POST /inventory/{id}/mark-used</done>
</task>

</tasks>

<verification>
1. `mise run build` compiles without errors
2. `mise run test-unit` passes without regressions
3. Manual API tests:
   - `GET /workspaces/{id}/declutter?threshold_days=90` returns items with scores
   - `GET /workspaces/{id}/declutter?group_by=category` groups results
   - `GET /workspaces/{id}/declutter/counts` returns summary counts
   - `POST /workspaces/{id}/inventory/{id}/mark-used` updates last_used_at
</verification>

<success_criteria>
- Declutter domain package exists with entity, service, repository, handler
- PostgreSQL repository implementation uses generated sqlc queries
- Routes registered in main router
- All three endpoints return expected responses
- Score calculation works (higher score = older + lower value items)
</success_criteria>

<output>
After completion, create `.planning/phases/14-declutter-assistant/14-02-SUMMARY.md`
</output>
