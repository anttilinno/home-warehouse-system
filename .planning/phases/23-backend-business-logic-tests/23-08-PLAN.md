---
phase: 23-backend-business-logic-tests
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/internal/jobs/repair_reminders_test.go
  - backend/internal/jobs/loan_reminders_test.go
  - backend/internal/jobs/thumbnail_processor_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Additional unit-testable paths in jobs package are covered"
    - "All ProcessTask unmarshal error paths are tested"
    - "All constructor functions are tested"
    - "Package coverage reaches maximum achievable with unit tests (~25-30%)"
  artifacts:
    - path: "backend/internal/jobs/repair_reminders_test.go"
      provides: "Extended tests for repair reminder edge cases"
      contains: "TestRepairReminderProcessor_ProcessTask"
    - path: "backend/internal/jobs/loan_reminders_test.go"
      provides: "Extended tests for loan reminder edge cases"
      contains: "TestLoanReminderProcessor_ProcessTask"
    - path: "backend/internal/jobs/thumbnail_processor_test.go"
      provides: "Extended tests for thumbnail processor edge cases"
      contains: "TestThumbnailProcessor_ProcessTask"
  key_links:
    - from: "*_test.go"
      to: "*_processor.go"
      via: "ProcessTask with invalid payloads"
      pattern: "json\\.Unmarshal"
---

<objective>
Close gap BE-04: Maximize jobs package unit test coverage by testing all unit-testable code paths.

Purpose: The VERIFICATION.md identified that ~80% of jobs package code requires database (pgxpool.Pool) or Redis/asynq dependencies that cannot be unit tested. However, we can still test:
- All payload serialization/deserialization
- All constructor functions (already done)
- ProcessTask unmarshal errors for ALL processors (not just thumbnail)
- Edge cases in testable helper logic

Current coverage: 20.1%
Achievable target: ~25-30% (remaining ~70% requires integration tests)

Output: Extended test coverage for all unit-testable code paths in jobs package.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/23-backend-business-logic-tests/23-VERIFICATION.md
@backend/internal/jobs/repair_reminders.go
@backend/internal/jobs/loan_reminders.go
@backend/internal/jobs/thumbnail_processor.go
@backend/internal/jobs/repair_reminders_test.go (existing tests)
@backend/internal/jobs/thumbnail_processor_test.go (existing tests)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ProcessTask unmarshal error tests for repair_reminders</name>
  <files>backend/internal/jobs/repair_reminders_test.go</files>
  <action>
Add tests for RepairReminderProcessor.ProcessTask unmarshal error path.

The ProcessTask method in repair_reminders.go has an early return on unmarshal error:
```go
if err := json.Unmarshal(t.Payload(), &payload); err != nil {
    return fmt.Errorf("failed to unmarshal payload: %w", err)
}
```

This path can be tested without database by creating a processor with nil pool and passing invalid JSON.

**Add test:**
```go
func TestRepairReminderProcessor_ProcessTask_InvalidPayload(t *testing.T) {
    processor := NewRepairReminderProcessor(nil, nil)

    // Create task with invalid JSON
    invalidTask := asynq.NewTask(TypeRepairReminder, []byte("invalid json"))

    err := processor.ProcessTask(context.Background(), invalidTask)
    require.Error(t, err)
    assert.Contains(t, err.Error(), "failed to unmarshal payload")
}

func TestRepairReminderProcessor_ProcessTask_EmptyPayload(t *testing.T) {
    processor := NewRepairReminderProcessor(nil, nil)

    // Empty payload should fail unmarshal
    emptyTask := asynq.NewTask(TypeRepairReminder, []byte{})

    err := processor.ProcessTask(context.Background(), emptyTask)
    require.Error(t, err)
    assert.Contains(t, err.Error(), "failed to unmarshal payload")
}

func TestRepairReminderProcessor_ProcessTask_MalformedJSON(t *testing.T) {
    processor := NewRepairReminderProcessor(nil, nil)

    // Missing closing brace
    malformedTask := asynq.NewTask(TypeRepairReminder, []byte(`{"repair_log_id": "not-uuid"`))

    err := processor.ProcessTask(context.Background(), malformedTask)
    require.Error(t, err)
}
```

Also add test for NewRepairReminderScheduler constructor if not already tested:
```go
func TestNewRepairReminderScheduler(t *testing.T) {
    scheduler := NewRepairReminderScheduler(nil, nil)
    require.NotNil(t, scheduler)
}
```
  </action>
  <verify>
Run: `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go test -v ./internal/jobs/... -run "TestRepairReminder" -count=1`
All repair reminder tests pass including new ProcessTask error tests.
  </verify>
  <done>
repair_reminders_test.go has ProcessTask unmarshal error tests. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ProcessTask unmarshal error tests for loan_reminders</name>
  <files>backend/internal/jobs/loan_reminders_test.go</files>
  <action>
Add tests for LoanReminderProcessor.ProcessTask unmarshal error path.

Check loan_reminders.go for the ProcessTask method structure. It should have similar unmarshal error handling.

**Add tests:**
```go
func TestLoanReminderProcessor_ProcessTask_InvalidPayload(t *testing.T) {
    processor := NewLoanReminderProcessor(nil, nil)

    invalidTask := asynq.NewTask(TypeLoanReminder, []byte("not json"))

    err := processor.ProcessTask(context.Background(), invalidTask)
    require.Error(t, err)
    assert.Contains(t, err.Error(), "unmarshal") // May be "failed to unmarshal" or similar
}

func TestLoanReminderProcessor_ProcessTask_EmptyPayload(t *testing.T) {
    processor := NewLoanReminderProcessor(nil, nil)

    emptyTask := asynq.NewTask(TypeLoanReminder, []byte{})

    err := processor.ProcessTask(context.Background(), emptyTask)
    require.Error(t, err)
}

func TestLoanReminderProcessor_ProcessTask_InvalidUUID(t *testing.T) {
    processor := NewLoanReminderProcessor(nil, nil)

    // Valid JSON but invalid UUID format
    badUUIDTask := asynq.NewTask(TypeLoanReminder, []byte(`{"loan_id": "not-a-uuid"}`))

    err := processor.ProcessTask(context.Background(), badUUIDTask)
    require.Error(t, err)
}
```

Also add scheduler constructor test:
```go
func TestNewLoanReminderScheduler(t *testing.T) {
    scheduler := NewLoanReminderScheduler(nil, nil)
    require.NotNil(t, scheduler)
}
```

Verify existing tests (like NewLoanReminderTask) still pass.
  </action>
  <verify>
Run: `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go test -v ./internal/jobs/... -run "TestLoanReminder" -count=1`
All loan reminder tests pass including new ProcessTask error tests.
  </verify>
  <done>
loan_reminders_test.go has ProcessTask unmarshal error tests. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify and document coverage ceiling</name>
  <files>backend/internal/jobs/thumbnail_processor_test.go</files>
  <action>
1. Verify thumbnail_processor_test.go already has ProcessTask unmarshal tests. If not, add them.

2. Run full jobs package coverage:
```bash
cd backend && go test -coverprofile=coverage.out ./internal/jobs/...
go tool cover -func=coverage.out | grep jobs
```

3. Document the coverage ceiling:
   - Record final coverage percentage
   - If coverage is < 25%, check for any additional unit-testable paths
   - Verify all constructors (New*Processor, New*Scheduler) are tested
   - Verify all task creators (New*Task) are tested
   - Verify all payload struct serialization is tested

4. Run all tests to ensure no regressions:
```bash
go test ./internal/jobs/... -count=1 -v
```

5. Note: The remaining untested code (~70-75%) genuinely requires:
   - pgxpool.Pool for database queries
   - asynq.Client for scheduling
   - webpush.Sender for push notifications
   - Redis for scheduler registration

   These would require integration tests, which are out of scope for this unit test phase.
  </action>
  <verify>
Run coverage analysis. Expected output:
- jobs package: 25-30% coverage
- All unit tests pass
- No test regressions
  </verify>
  <done>
Jobs package coverage maximized for unit tests (25-30%). Coverage ceiling documented. Remaining code requires integration tests due to database/Redis dependencies.
  </done>
</task>

</tasks>

<verification>
1. All jobs tests pass: `go test ./internal/jobs/... -v -count=1`
2. Coverage measured: `go test -cover ./internal/jobs/...` shows 25%+ (up from 20.1%)
3. All ProcessTask unmarshal error paths are tested for all processors
4. Coverage ceiling is documented - remaining code requires integration tests
</verification>

<success_criteria>
- repair_reminders_test.go has ProcessTask unmarshal error tests
- loan_reminders_test.go has ProcessTask unmarshal error tests
- All constructor functions are tested
- Jobs package coverage >= 25%
- All tests pass without errors
- Coverage ceiling documented (integration tests needed for 60%+)
</success_criteria>

<output>
After completion, create `.planning/phases/23-backend-business-logic-tests/23-08-SUMMARY.md`

Note in SUMMARY.md:
- Final coverage achieved: ~25-30%
- Original 60%+ target not achievable with unit tests
- Remaining ~70% requires integration tests or database mocking
- Recommend updating JOBS-COV-01 decision to accept 25% as unit test ceiling
</output>
