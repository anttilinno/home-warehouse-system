---
phase: 19-barcode-scanning
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/scanner/scan-lookup.ts
  - frontend/lib/scanner/scan-history.ts
autonomous: true

must_haves:
  truths:
    - "Scanned code can be looked up against IndexedDB to find matching entity"
    - "Scan history persists to localStorage with 10-entry limit"
    - "Duplicate scans are de-duplicated in history"
  artifacts:
    - path: "frontend/lib/scanner/scan-lookup.ts"
      provides: "IndexedDB short_code lookup"
      exports: ["lookupByShortCode"]
    - path: "frontend/lib/scanner/scan-history.ts"
      provides: "localStorage scan history CRUD"
      exports: ["getScanHistory", "addToScanHistory", "clearScanHistory"]
  key_links:
    - from: "frontend/lib/scanner/scan-lookup.ts"
      to: "frontend/lib/db/offline-db.ts"
      via: "getAll import"
      pattern: 'import.*getAll.*from.*offline-db'
---

<objective>
Create scan lookup and history persistence modules.

Purpose: Enable code-to-entity resolution from IndexedDB and maintain scan history for quick access to recent scans.
Output: Lookup and history utilities ready for scanner component integration.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-barcode-scanning/19-RESEARCH.md

Reference for existing patterns:
@frontend/lib/db/offline-db.ts (getAll function)
@frontend/lib/types/items.ts (Item type with short_code, barcode)
@frontend/lib/types/containers.ts (Container type with short_code)
@frontend/lib/types/locations.ts (Location type with short_code)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scan lookup module for IndexedDB queries</name>
  <files>frontend/lib/scanner/scan-lookup.ts</files>
  <action>
Create `frontend/lib/scanner/scan-lookup.ts`:
```typescript
/**
 * Scan Lookup Module
 *
 * Looks up scanned codes against IndexedDB to identify matching entities.
 * Searches items, containers, and locations by their short_code field.
 * Also checks item barcode field for UPC/EAN matches.
 *
 * Uses parallel queries for performance.
 */

import { getAll } from "@/lib/db/offline-db";
import type { Item } from "@/lib/types/items";
import type { Container } from "@/lib/types/containers";
import type { Location } from "@/lib/types/locations";
import type { EntityMatch } from "./types";

/**
 * Look up a scanned code in IndexedDB.
 *
 * Search order:
 * 1. Items by short_code (exact match)
 * 2. Containers by short_code (exact match)
 * 3. Locations by short_code (exact match)
 * 4. Items by barcode field (exact match for UPC/EAN)
 *
 * @param code - The scanned barcode/QR code value
 * @returns EntityMatch with found entity or not_found result
 */
export async function lookupByShortCode(code: string): Promise<EntityMatch> {
  if (!code || code.trim().length === 0) {
    return { type: "not_found", code: "" };
  }

  const trimmedCode = code.trim();

  try {
    // Parallel fetch all entities from IndexedDB
    const [items, containers, locations] = await Promise.all([
      getAll<Item>("items"),
      getAll<Container>("containers"),
      getAll<Location>("locations"),
    ]);

    // Search items by short_code first (case-insensitive)
    const itemByShortCode = items.find(
      (item) =>
        item.short_code?.toLowerCase() === trimmedCode.toLowerCase()
    );
    if (itemByShortCode) {
      return { type: "item", entity: itemByShortCode };
    }

    // Search containers by short_code
    const containerByShortCode = containers.find(
      (container) =>
        container.short_code?.toLowerCase() === trimmedCode.toLowerCase()
    );
    if (containerByShortCode) {
      return { type: "container", entity: containerByShortCode };
    }

    // Search locations by short_code
    const locationByShortCode = locations.find(
      (location) =>
        location.short_code?.toLowerCase() === trimmedCode.toLowerCase()
    );
    if (locationByShortCode) {
      return { type: "location", entity: locationByShortCode };
    }

    // Fallback: search items by barcode field (for UPC/EAN barcodes)
    const itemByBarcode = items.find(
      (item) =>
        item.barcode?.toLowerCase() === trimmedCode.toLowerCase()
    );
    if (itemByBarcode) {
      return { type: "item", entity: itemByBarcode };
    }

    // Not found
    return { type: "not_found", code: trimmedCode };
  } catch (error) {
    console.error("[ScanLookup] Failed to query IndexedDB:", error);
    // Return not_found on error rather than throwing
    return { type: "not_found", code: trimmedCode };
  }
}

/**
 * Get the display name for an entity match.
 *
 * @param match - The entity match result
 * @returns Display name or the scanned code for not_found
 */
export function getEntityDisplayName(match: EntityMatch): string {
  if (match.type === "not_found") {
    return match.code;
  }
  return match.entity.name;
}

/**
 * Get the navigation URL for an entity match.
 *
 * @param match - The entity match result
 * @returns Dashboard URL for the entity detail page
 */
export function getEntityUrl(match: EntityMatch): string | null {
  switch (match.type) {
    case "item":
      return `/dashboard/items/${match.entity.id}`;
    case "container":
      return `/dashboard/containers?selected=${match.entity.id}`;
    case "location":
      return `/dashboard/locations?selected=${match.entity.id}`;
    case "not_found":
      return null;
  }
}
```
  </action>
  <verify>
```bash
cat frontend/lib/scanner/scan-lookup.ts | grep -E "^export (async function|function)"
```
Should show: lookupByShortCode, getEntityDisplayName, getEntityUrl
  </verify>
  <done>Scan lookup module created with lookupByShortCode that queries IndexedDB items/containers/locations by short_code and barcode</done>
</task>

<task type="auto">
  <name>Task 2: Create scan history module with localStorage persistence</name>
  <files>frontend/lib/scanner/scan-history.ts</files>
  <action>
Create `frontend/lib/scanner/scan-history.ts`:
```typescript
/**
 * Scan History Module
 *
 * Persists scan history to localStorage for quick access to recent scans.
 * Maintains a rolling list of the last 10 scans with timestamps.
 *
 * Features:
 * - Automatic de-duplication (same code moves to top)
 * - Size limit enforcement (max 10 entries)
 * - Graceful handling of localStorage errors
 */

import type { ScanHistoryEntry, EntityMatch } from "./types";

const SCAN_HISTORY_KEY = "hws-scan-history";
const MAX_HISTORY_SIZE = 10;

/**
 * Get all scan history entries.
 *
 * @returns Array of scan history entries, newest first
 */
export function getScanHistory(): ScanHistoryEntry[] {
  if (typeof window === "undefined") {
    return [];
  }

  try {
    const stored = localStorage.getItem(SCAN_HISTORY_KEY);
    if (!stored) {
      return [];
    }

    const parsed = JSON.parse(stored);
    if (!Array.isArray(parsed)) {
      return [];
    }

    // Validate entries have required fields
    return parsed.filter(
      (entry): entry is ScanHistoryEntry =>
        typeof entry === "object" &&
        typeof entry.code === "string" &&
        typeof entry.timestamp === "number"
    );
  } catch (error) {
    console.warn("[ScanHistory] Failed to read history:", error);
    return [];
  }
}

/**
 * Add a scan to the history.
 *
 * - Removes existing entry with same code (de-duplication)
 * - Adds new entry at the front
 * - Trims to MAX_HISTORY_SIZE
 *
 * @param entry - Scan entry without timestamp (will be added)
 */
export function addToScanHistory(
  entry: Omit<ScanHistoryEntry, "timestamp">
): void {
  if (typeof window === "undefined") {
    return;
  }

  try {
    const history = getScanHistory();

    // Create new entry with timestamp
    const newEntry: ScanHistoryEntry = {
      ...entry,
      timestamp: Date.now(),
    };

    // Remove duplicate of same code if exists
    const filtered = history.filter((h) => h.code !== entry.code);

    // Add to front and limit size
    const updated = [newEntry, ...filtered].slice(0, MAX_HISTORY_SIZE);

    localStorage.setItem(SCAN_HISTORY_KEY, JSON.stringify(updated));
  } catch (error) {
    console.warn("[ScanHistory] Failed to save history:", error);
  }
}

/**
 * Create a history entry from an entity match result.
 *
 * @param code - The scanned code
 * @param format - The barcode format (e.g., 'qr_code', 'ean_13')
 * @param match - The entity match result from lookupByShortCode
 * @returns Partial entry ready for addToScanHistory
 */
export function createHistoryEntry(
  code: string,
  format: string,
  match: EntityMatch
): Omit<ScanHistoryEntry, "timestamp"> {
  if (match.type === "not_found") {
    return {
      code,
      format,
      entityType: "unknown",
    };
  }

  return {
    code,
    format,
    entityType: match.type,
    entityId: match.entity.id,
    entityName: match.entity.name,
  };
}

/**
 * Remove a specific entry from history by code.
 *
 * @param code - The code to remove
 */
export function removeFromScanHistory(code: string): void {
  if (typeof window === "undefined") {
    return;
  }

  try {
    const history = getScanHistory();
    const filtered = history.filter((h) => h.code !== code);
    localStorage.setItem(SCAN_HISTORY_KEY, JSON.stringify(filtered));
  } catch (error) {
    console.warn("[ScanHistory] Failed to remove from history:", error);
  }
}

/**
 * Clear all scan history.
 */
export function clearScanHistory(): void {
  if (typeof window === "undefined") {
    return;
  }

  try {
    localStorage.removeItem(SCAN_HISTORY_KEY);
  } catch (error) {
    console.warn("[ScanHistory] Failed to clear history:", error);
  }
}

/**
 * Get the most recent scan from history.
 *
 * @returns Most recent entry or undefined if history is empty
 */
export function getLastScan(): ScanHistoryEntry | undefined {
  const history = getScanHistory();
  return history[0];
}

/**
 * Format a timestamp for display.
 *
 * @param timestamp - Unix timestamp in milliseconds
 * @returns Formatted string like "2 min ago" or "Jan 15, 3:42 PM"
 */
export function formatScanTime(timestamp: number): string {
  const now = Date.now();
  const diffMs = now - timestamp;
  const diffSec = Math.floor(diffMs / 1000);
  const diffMin = Math.floor(diffSec / 60);
  const diffHour = Math.floor(diffMin / 60);

  if (diffMin < 1) {
    return "Just now";
  }

  if (diffMin < 60) {
    return `${diffMin} min ago`;
  }

  if (diffHour < 24) {
    return `${diffHour} hr ago`;
  }

  // For older entries, show date/time
  const date = new Date(timestamp);
  return date.toLocaleDateString(undefined, {
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
  });
}
```
  </action>
  <verify>
```bash
cat frontend/lib/scanner/scan-history.ts | grep -E "^export (function|const)"
```
Should show: getScanHistory, addToScanHistory, createHistoryEntry, removeFromScanHistory, clearScanHistory, getLastScan, formatScanTime
  </verify>
  <done>Scan history module created with localStorage persistence, 10-entry limit, and de-duplication</done>
</task>

<task type="auto">
  <name>Task 3: Create index file for scanner module exports</name>
  <files>frontend/lib/scanner/index.ts</files>
  <action>
Create `frontend/lib/scanner/index.ts`:
```typescript
/**
 * Scanner Module
 *
 * Barcode and QR code scanning utilities for the Home Warehouse System.
 *
 * @example
 * ```typescript
 * import {
 *   initBarcodePolyfill,
 *   lookupByShortCode,
 *   addToScanHistory,
 *   triggerScanFeedback,
 * } from "@/lib/scanner";
 *
 * // Initialize polyfill on app load
 * await initBarcodePolyfill();
 *
 * // On scan success
 * const match = await lookupByShortCode(scannedCode);
 * triggerScanFeedback();
 * addToScanHistory(createHistoryEntry(scannedCode, "qr_code", match));
 * ```
 */

// Types
export type { EntityMatch, ScanHistoryEntry, BarcodeFormat } from "./types";
export { SUPPORTED_FORMATS } from "./types";

// Polyfill
export { initBarcodePolyfill, isBarcodeDetectionAvailable } from "./init-polyfill";

// Feedback
export {
  initAudioContext,
  playBeep,
  playSuccessBeep,
  playErrorBeep,
  triggerHaptic,
  triggerScanFeedback,
} from "./feedback";

// Lookup
export {
  lookupByShortCode,
  getEntityDisplayName,
  getEntityUrl,
} from "./scan-lookup";

// History
export {
  getScanHistory,
  addToScanHistory,
  createHistoryEntry,
  removeFromScanHistory,
  clearScanHistory,
  getLastScan,
  formatScanTime,
} from "./scan-history";
```
  </action>
  <verify>
```bash
cat frontend/lib/scanner/index.ts | grep "export"
```
Should show all exports from the scanner module.
  </verify>
  <done>Scanner module index created with consolidated exports</done>
</task>

</tasks>

<verification>
1. Lookup module exists: `ls frontend/lib/scanner/scan-lookup.ts`
2. History module exists: `ls frontend/lib/scanner/scan-history.ts`
3. Index exports all: `grep -c "export" frontend/lib/scanner/index.ts` (should be > 15)
4. Lookup imports offline-db: `grep "offline-db" frontend/lib/scanner/scan-lookup.ts`
5. All scanner files present: `ls frontend/lib/scanner/`
</verification>

<success_criteria>
- frontend/lib/scanner/scan-lookup.ts exports lookupByShortCode
- frontend/lib/scanner/scan-history.ts exports getScanHistory, addToScanHistory
- frontend/lib/scanner/index.ts re-exports all scanner utilities
- Lookup searches items/containers/locations by short_code and items by barcode
- History limits to 10 entries and de-duplicates by code
</success_criteria>

<output>
After completion, create `.planning/phases/19-barcode-scanning/19-02-SUMMARY.md`
</output>
