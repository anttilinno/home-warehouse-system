---
phase: 28-security-settings
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/db/migrations/009_user_sessions.sql
  - backend/db/queries/sessions.sql
  - backend/internal/infra/queries/sessions.sql.go
  - backend/internal/infra/queries/models.go
autonomous: true

must_haves:
  truths:
    - "auth.user_sessions table exists with user_id, refresh_token_hash, device_info, ip_address, last_active_at"
    - "Sessions can be queried by user_id and by refresh_token_hash"
    - "Sessions can be deleted individually or all-except-current"
  artifacts:
    - path: "backend/db/migrations/009_user_sessions.sql"
      provides: "Sessions table migration"
      contains: "CREATE TABLE auth.user_sessions"
    - path: "backend/db/queries/sessions.sql"
      provides: "sqlc queries for session CRUD"
      contains: "CreateSession"
    - path: "backend/internal/infra/queries/sessions.sql.go"
      provides: "Generated Go code for session queries"
      contains: "CreateSession"
  key_links:
    - from: "backend/db/queries/sessions.sql"
      to: "auth.user_sessions"
      via: "SQL queries"
      pattern: "user_sessions"
---

<objective>
Create database infrastructure for user session tracking.

Purpose: Sessions table enables listing active sessions, tracking device metadata, and revoking sessions (SEC-02, SEC-03, SEC-04). This is the foundation for session management.

Output: Migration file creating auth.user_sessions table and sqlc queries for session CRUD operations.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/28-security-settings/28-RESEARCH.md

# Existing patterns
@backend/db/migrations/001_initial_schema.sql (for schema patterns)
@backend/db/queries/users.sql (for sqlc query patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sessions table migration</name>
  <files>backend/db/migrations/009_user_sessions.sql</files>
  <action>
Create migration file backend/db/migrations/009_user_sessions.sql:

```sql
-- migrate:up
CREATE TABLE auth.user_sessions (
    id UUID PRIMARY KEY DEFAULT uuidv7(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    refresh_token_hash VARCHAR(64) NOT NULL,
    device_info VARCHAR(200),
    ip_address INET,
    user_agent TEXT,
    last_active_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Index for looking up sessions by user (for listing)
CREATE INDEX idx_user_sessions_user_id ON auth.user_sessions(user_id);

-- Index for looking up session by token hash (for validation)
CREATE INDEX idx_user_sessions_token_hash ON auth.user_sessions(refresh_token_hash);

-- Index for cleaning up expired sessions
CREATE INDEX idx_user_sessions_expires_at ON auth.user_sessions(expires_at);

COMMENT ON TABLE auth.user_sessions IS
'Tracks active user sessions for multi-device management and token revocation.';

COMMENT ON COLUMN auth.user_sessions.refresh_token_hash IS
'SHA-256 hash of the refresh token. Never store plain tokens.';

COMMENT ON COLUMN auth.user_sessions.device_info IS
'Human-readable device description parsed from user agent (e.g., Chrome on Windows).';

COMMENT ON COLUMN auth.user_sessions.ip_address IS
'Client IP address at login time.';

COMMENT ON COLUMN auth.user_sessions.last_active_at IS
'Updated on token refresh to track session activity.';

-- migrate:down
DROP TABLE IF EXISTS auth.user_sessions;
```

Key design decisions:
- refresh_token_hash is VARCHAR(64) for SHA-256 hex encoding
- device_info is parsed "Chrome on Windows" style, not raw user agent
- user_agent stored for debugging but device_info shown to users
- ip_address uses INET type for proper IP handling
- expires_at matches refresh token expiry (7 days)
- ON DELETE CASCADE ensures sessions cleaned up when user deleted
  </action>
  <verify>Migration syntax check: `cd /home/antti/Repos/Misc/home-warehouse-system && mise run migrate && echo "Migration successful"`</verify>
  <done>Migration runs successfully, auth.user_sessions table exists with all columns and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create sqlc queries for sessions</name>
  <files>backend/db/queries/sessions.sql</files>
  <action>
Create backend/db/queries/sessions.sql with these queries:

```sql
-- name: CreateSession :one
-- Creates a new session record when user logs in
INSERT INTO auth.user_sessions (
    user_id, refresh_token_hash, device_info, ip_address, user_agent, expires_at
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING *;

-- name: GetSessionByTokenHash :one
-- Finds a session by its refresh token hash (for token validation)
SELECT * FROM auth.user_sessions
WHERE refresh_token_hash = $1 AND expires_at > now();

-- name: GetUserSessions :many
-- Lists all active sessions for a user (for session management UI)
SELECT id, user_id, device_info, ip_address, last_active_at, created_at
FROM auth.user_sessions
WHERE user_id = $1 AND expires_at > now()
ORDER BY last_active_at DESC;

-- name: UpdateSessionActivity :exec
-- Updates session's last_active_at and refresh_token_hash on token refresh
UPDATE auth.user_sessions
SET last_active_at = now(), refresh_token_hash = $2
WHERE id = $1;

-- name: DeleteSession :exec
-- Deletes a specific session (for individual session revocation)
DELETE FROM auth.user_sessions WHERE id = $1 AND user_id = $2;

-- name: DeleteAllSessionsExceptCurrent :exec
-- Deletes all sessions except the specified one (for "logout all others")
DELETE FROM auth.user_sessions
WHERE user_id = $1 AND id != $2;

-- name: DeleteAllUserSessions :exec
-- Deletes all sessions for a user (for password change with revoke option)
DELETE FROM auth.user_sessions WHERE user_id = $1;

-- name: DeleteExpiredSessions :exec
-- Cleanup job: removes expired sessions
DELETE FROM auth.user_sessions WHERE expires_at < now();

-- name: CountUserSessions :one
-- Counts active sessions for a user (for session limit enforcement)
SELECT COUNT(*) FROM auth.user_sessions
WHERE user_id = $1 AND expires_at > now();
```

Query design notes:
- GetUserSessions excludes sensitive fields (refresh_token_hash, user_agent) from listing
- DeleteSession requires both id AND user_id for authorization safety
- Separate DeleteAllSessionsExceptCurrent vs DeleteAllUserSessions for different use cases
  </action>
  <verify>Syntax validation: `cd /home/antti/Repos/Misc/home-warehouse-system && mise run sqlc && echo "sqlc generation successful"`</verify>
  <done>sqlc generates sessions.sql.go without errors, all query functions exist in generated code</done>
</task>

<task type="auto">
  <name>Task 3: Verify generated code and models</name>
  <files>
    backend/internal/infra/queries/sessions.sql.go
    backend/internal/infra/queries/models.go
  </files>
  <action>
After sqlc generation, verify the generated files:

1. Check sessions.sql.go exists and contains:
   - CreateSession function returning UserSession
   - GetSessionByTokenHash function
   - GetUserSessions function returning []GetUserSessionsRow
   - UpdateSessionActivity function
   - DeleteSession function
   - DeleteAllSessionsExceptCurrent function
   - DeleteAllUserSessions function
   - DeleteExpiredSessions function
   - CountUserSessions function

2. Check models.go contains AuthUserSession struct with fields:
   - ID uuid.UUID
   - UserID uuid.UUID
   - RefreshTokenHash string
   - DeviceInfo sql.NullString (or *string depending on sqlc config)
   - IpAddress interface{} (INET type handling)
   - UserAgent sql.NullString
   - LastActiveAt time.Time
   - ExpiresAt time.Time
   - CreatedAt time.Time

3. Run go build to verify everything compiles:
   `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go build ./...`

If INET type causes issues with pgx, may need to adjust the type or use string casting in queries.
  </action>
  <verify>
1. `ls /home/antti/Repos/Misc/home-warehouse-system/backend/internal/infra/queries/sessions.sql.go` exists
2. `grep "CreateSession" /home/antti/Repos/Misc/home-warehouse-system/backend/internal/infra/queries/sessions.sql.go` returns matches
3. `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go build ./...` succeeds
  </verify>
  <done>Generated Go code compiles, AuthUserSession model exists, all query functions are available</done>
</task>

</tasks>

<verification>
1. Migration file exists at backend/db/migrations/009_user_sessions.sql
2. `mise run migrate` succeeds
3. `mise run sqlc` generates code without errors
4. `cd backend && go build ./...` compiles successfully
5. Query functions exist in sessions.sql.go: CreateSession, GetSessionByTokenHash, GetUserSessions, etc.
6. Database has auth.user_sessions table: `psql -c "\d auth.user_sessions"`
</verification>

<success_criteria>
- auth.user_sessions table created with correct schema
- All required indexes exist for performance
- sqlc queries generated and compile
- Backend builds without errors
- Foundation ready for session service in plan 03
</success_criteria>

<output>
After completion, create `.planning/phases/28-security-settings/28-02-SUMMARY.md`
</output>
