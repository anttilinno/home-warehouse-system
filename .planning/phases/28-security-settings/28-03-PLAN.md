---
phase: 28-security-settings
plan: 03
type: execute
wave: 2
depends_on: ["28-02"]
files_modified:
  - backend/internal/domain/auth/session/entity.go
  - backend/internal/domain/auth/session/service.go
  - backend/internal/domain/auth/session/repository.go
  - backend/internal/domain/auth/session/handler.go
  - backend/internal/domain/auth/user/handler.go
  - backend/internal/infra/session_repository.go
  - backend/cmd/server/main.go
  - backend/go.mod
autonomous: true

must_haves:
  truths:
    - "Login creates a session record with device info parsed from user agent"
    - "Token refresh validates session exists and updates last_active_at"
    - "Logout deletes the current session"
    - "GET /users/me/sessions returns list of active sessions"
    - "DELETE /users/me/sessions/:id revokes specific session"
    - "DELETE /users/me/sessions deletes all sessions except current"
  artifacts:
    - path: "backend/internal/domain/auth/session/service.go"
      provides: "Session business logic"
      exports: ["Service", "ServiceInterface"]
    - path: "backend/internal/domain/auth/session/handler.go"
      provides: "Session HTTP handlers"
      exports: ["Handler"]
    - path: "backend/internal/infra/session_repository.go"
      provides: "Session repository implementation"
      min_lines: 80
  key_links:
    - from: "backend/internal/domain/auth/user/handler.go"
      to: "session.ServiceInterface"
      via: "login creates session"
      pattern: "sessionSvc.Create"
    - from: "backend/internal/domain/auth/user/handler.go"
      to: "session.ServiceInterface"
      via: "refresh validates session"
      pattern: "sessionSvc.FindByTokenHash"
    - from: "backend/internal/domain/auth/session/handler.go"
      to: "session.ServiceInterface"
      via: "handler calls service"
      pattern: "svc\\."
---

<objective>
Implement session backend: domain layer, repository, handlers, and integrate with auth flow.

Purpose: This enables session listing (SEC-02), individual session revocation (SEC-03), and bulk session revocation (SEC-04). The auth flow modifications make sessions trackable.

Output: Complete session management backend with endpoints for listing and revoking sessions, plus session-aware login/refresh/logout.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/28-security-settings/28-RESEARCH.md
@.planning/phases/28-security-settings/28-02-SUMMARY.md

# Existing patterns
@backend/internal/domain/auth/user/handler.go
@backend/internal/domain/auth/user/service.go
@backend/internal/domain/auth/user/entity.go
@backend/internal/infra/user_repository.go
@backend/internal/shared/jwt/jwt.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add useragent library and create session domain layer</name>
  <files>
    backend/go.mod
    backend/internal/domain/auth/session/entity.go
    backend/internal/domain/auth/session/repository.go
    backend/internal/domain/auth/session/service.go
  </files>
  <action>
1. Add useragent library:
   `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go get github.com/mssola/useragent`

2. Create backend/internal/domain/auth/session/entity.go:
```go
package session

import (
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "net"
    "time"

    "github.com/google/uuid"
    "github.com/mssola/useragent"
)

// Session represents an active user session.
type Session struct {
    id               uuid.UUID
    userID           uuid.UUID
    refreshTokenHash string
    deviceInfo       string
    ipAddress        net.IP
    userAgent        string
    lastActiveAt     time.Time
    expiresAt        time.Time
    createdAt        time.Time
}

// NewSession creates a new session from login data.
func NewSession(userID uuid.UUID, refreshToken, userAgentStr, ipAddress string, expiresAt time.Time) *Session {
    return &Session{
        id:               uuid.Must(uuid.NewV7()),
        userID:           userID,
        refreshTokenHash: HashToken(refreshToken),
        deviceInfo:       ParseDeviceInfo(userAgentStr),
        ipAddress:        net.ParseIP(ipAddress),
        userAgent:        userAgentStr,
        lastActiveAt:     time.Now(),
        expiresAt:        expiresAt,
        createdAt:        time.Now(),
    }
}

// Reconstitute creates a Session from persistence data.
func Reconstitute(id, userID uuid.UUID, tokenHash, deviceInfo, ipAddr, userAgent string, lastActive, expires, created time.Time) *Session {
    return &Session{
        id:               id,
        userID:           userID,
        refreshTokenHash: tokenHash,
        deviceInfo:       deviceInfo,
        ipAddress:        net.ParseIP(ipAddr),
        userAgent:        userAgent,
        lastActiveAt:     lastActive,
        expiresAt:        expires,
        createdAt:        created,
    }
}

// Getters
func (s *Session) ID() uuid.UUID           { return s.id }
func (s *Session) UserID() uuid.UUID       { return s.userID }
func (s *Session) TokenHash() string       { return s.refreshTokenHash }
func (s *Session) DeviceInfo() string      { return s.deviceInfo }
func (s *Session) IPAddress() string       { if s.ipAddress == nil { return "" }; return s.ipAddress.String() }
func (s *Session) UserAgent() string       { return s.userAgent }
func (s *Session) LastActiveAt() time.Time { return s.lastActiveAt }
func (s *Session) ExpiresAt() time.Time    { return s.expiresAt }
func (s *Session) CreatedAt() time.Time    { return s.createdAt }

// UpdateActivity updates the session's last active time and token hash.
func (s *Session) UpdateActivity(newRefreshToken string) {
    s.refreshTokenHash = HashToken(newRefreshToken)
    s.lastActiveAt = time.Now()
}

// HashToken creates SHA-256 hash of a refresh token.
func HashToken(token string) string {
    hash := sha256.Sum256([]byte(token))
    return hex.EncodeToString(hash[:])
}

// ParseDeviceInfo extracts human-readable device description from user agent.
func ParseDeviceInfo(userAgentStr string) string {
    if userAgentStr == "" {
        return "Unknown device"
    }
    ua := useragent.New(userAgentStr)
    browser, version := ua.Browser()
    os := ua.OS()

    if ua.Mobile() {
        if os == "iOS" || os == "iPhone OS" {
            return fmt.Sprintf("%s on iPhone", browser)
        }
        return fmt.Sprintf("%s on Android", browser)
    }

    if browser != "" && os != "" {
        return fmt.Sprintf("%s %s on %s", browser, version, os)
    }
    if browser != "" {
        return browser
    }
    return "Unknown device"
}
```

3. Create backend/internal/domain/auth/session/repository.go:
```go
package session

import (
    "context"

    "github.com/google/uuid"
)

// Repository defines session persistence operations.
type Repository interface {
    Save(ctx context.Context, session *Session) error
    FindByID(ctx context.Context, id uuid.UUID) (*Session, error)
    FindByTokenHash(ctx context.Context, hash string) (*Session, error)
    FindByUserID(ctx context.Context, userID uuid.UUID) ([]*Session, error)
    UpdateActivity(ctx context.Context, id uuid.UUID, newTokenHash string) error
    Delete(ctx context.Context, id, userID uuid.UUID) error
    DeleteAllExcept(ctx context.Context, userID, exceptID uuid.UUID) error
    DeleteAllForUser(ctx context.Context, userID uuid.UUID) error
}
```

4. Create backend/internal/domain/auth/session/service.go:
```go
package session

import (
    "context"
    "errors"
    "time"

    "github.com/google/uuid"
)

var (
    ErrSessionNotFound = errors.New("session not found")
    ErrUnauthorized    = errors.New("unauthorized to access this session")
)

// ServiceInterface defines session service operations.
type ServiceInterface interface {
    Create(ctx context.Context, userID uuid.UUID, refreshToken, userAgent, ipAddress string) (*Session, error)
    FindByTokenHash(ctx context.Context, tokenHash string) (*Session, error)
    FindByUserID(ctx context.Context, userID uuid.UUID) ([]*Session, error)
    UpdateActivity(ctx context.Context, sessionID uuid.UUID, newRefreshToken string) error
    Revoke(ctx context.Context, userID, sessionID uuid.UUID) error
    RevokeAllExcept(ctx context.Context, userID, currentSessionID uuid.UUID) error
    RevokeAll(ctx context.Context, userID uuid.UUID) error
}

// Service handles session business logic.
type Service struct {
    repo            Repository
    refreshDuration time.Duration
}

// NewService creates a new session service.
func NewService(repo Repository) *Service {
    return &Service{
        repo:            repo,
        refreshDuration: 7 * 24 * time.Hour, // Match JWT refresh token expiry
    }
}

// Create creates a new session.
func (s *Service) Create(ctx context.Context, userID uuid.UUID, refreshToken, userAgent, ipAddress string) (*Session, error) {
    expiresAt := time.Now().Add(s.refreshDuration)
    session := NewSession(userID, refreshToken, userAgent, ipAddress, expiresAt)
    if err := s.repo.Save(ctx, session); err != nil {
        return nil, err
    }
    return session, nil
}

// FindByTokenHash finds a session by its refresh token hash.
func (s *Service) FindByTokenHash(ctx context.Context, tokenHash string) (*Session, error) {
    session, err := s.repo.FindByTokenHash(ctx, tokenHash)
    if err != nil {
        return nil, err
    }
    if session == nil {
        return nil, ErrSessionNotFound
    }
    return session, nil
}

// FindByUserID returns all active sessions for a user.
func (s *Service) FindByUserID(ctx context.Context, userID uuid.UUID) ([]*Session, error) {
    return s.repo.FindByUserID(ctx, userID)
}

// UpdateActivity updates session activity on token refresh.
func (s *Service) UpdateActivity(ctx context.Context, sessionID uuid.UUID, newRefreshToken string) error {
    return s.repo.UpdateActivity(ctx, sessionID, HashToken(newRefreshToken))
}

// Revoke deletes a specific session.
func (s *Service) Revoke(ctx context.Context, userID, sessionID uuid.UUID) error {
    return s.repo.Delete(ctx, sessionID, userID)
}

// RevokeAllExcept deletes all sessions except the specified one.
func (s *Service) RevokeAllExcept(ctx context.Context, userID, currentSessionID uuid.UUID) error {
    return s.repo.DeleteAllExcept(ctx, userID, currentSessionID)
}

// RevokeAll deletes all sessions for a user.
func (s *Service) RevokeAll(ctx context.Context, userID uuid.UUID) error {
    return s.repo.DeleteAllForUser(ctx, userID)
}
```
  </action>
  <verify>`cd /home/antti/Repos/Misc/home-warehouse-system/backend && go build ./internal/domain/auth/session/...`</verify>
  <done>Session entity, repository interface, and service compile without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create session repository implementation and handler</name>
  <files>
    backend/internal/infra/session_repository.go
    backend/internal/domain/auth/session/handler.go
  </files>
  <action>
1. Create backend/internal/infra/session_repository.go:
```go
package infra

import (
    "context"

    "github.com/google/uuid"
    "github.com/jackc/pgx/v5/pgtype"

    "github.com/antti/home-warehouse/go-backend/internal/domain/auth/session"
    "github.com/antti/home-warehouse/go-backend/internal/infra/queries"
)

// SessionRepository implements session.Repository using sqlc queries.
type SessionRepository struct {
    queries *queries.Queries
}

// NewSessionRepository creates a new session repository.
func NewSessionRepository(q *queries.Queries) *SessionRepository {
    return &SessionRepository{queries: q}
}

// Save persists a new session.
func (r *SessionRepository) Save(ctx context.Context, s *session.Session) error {
    var ipAddr pgtype.Inet
    if s.IPAddress() != "" {
        _ = ipAddr.Scan(s.IPAddress())
    }

    var deviceInfo, userAgent pgtype.Text
    if s.DeviceInfo() != "" {
        deviceInfo = pgtype.Text{String: s.DeviceInfo(), Valid: true}
    }
    if s.UserAgent() != "" {
        userAgent = pgtype.Text{String: s.UserAgent(), Valid: true}
    }

    _, err := r.queries.CreateSession(ctx, queries.CreateSessionParams{
        UserID:           s.UserID(),
        RefreshTokenHash: s.TokenHash(),
        DeviceInfo:       deviceInfo,
        IpAddress:        ipAddr,
        UserAgent:        userAgent,
        ExpiresAt:        pgtype.Timestamptz{Time: s.ExpiresAt(), Valid: true},
    })
    return err
}

// FindByID finds a session by ID.
func (r *SessionRepository) FindByID(ctx context.Context, id uuid.UUID) (*session.Session, error) {
    // Use GetSessionByTokenHash as a base - we may need to add a GetSessionByID query
    // For now, this isn't needed by the service layer
    return nil, nil
}

// FindByTokenHash finds a session by its refresh token hash.
func (r *SessionRepository) FindByTokenHash(ctx context.Context, hash string) (*session.Session, error) {
    row, err := r.queries.GetSessionByTokenHash(ctx, hash)
    if err != nil {
        return nil, err
    }

    var ipAddr string
    if row.IpAddress.Valid {
        ipAddr = row.IpAddress.Addr.String()
    }

    return session.Reconstitute(
        row.ID,
        row.UserID,
        row.RefreshTokenHash,
        row.DeviceInfo.String,
        ipAddr,
        row.UserAgent.String,
        row.LastActiveAt.Time,
        row.ExpiresAt.Time,
        row.CreatedAt.Time,
    ), nil
}

// FindByUserID returns all active sessions for a user.
func (r *SessionRepository) FindByUserID(ctx context.Context, userID uuid.UUID) ([]*session.Session, error) {
    rows, err := r.queries.GetUserSessions(ctx, userID)
    if err != nil {
        return nil, err
    }

    sessions := make([]*session.Session, len(rows))
    for i, row := range rows {
        var ipAddr string
        if row.IpAddress.Valid {
            ipAddr = row.IpAddress.Addr.String()
        }
        sessions[i] = session.Reconstitute(
            row.ID,
            row.UserID,
            "", // Token hash not returned in listing
            row.DeviceInfo.String,
            ipAddr,
            "", // User agent not returned in listing
            row.LastActiveAt.Time,
            time.Time{}, // Expires not returned in listing
            row.CreatedAt.Time,
        )
    }
    return sessions, nil
}

// UpdateActivity updates a session's activity.
func (r *SessionRepository) UpdateActivity(ctx context.Context, id uuid.UUID, newTokenHash string) error {
    return r.queries.UpdateSessionActivity(ctx, queries.UpdateSessionActivityParams{
        ID:               id,
        RefreshTokenHash: newTokenHash,
    })
}

// Delete removes a specific session.
func (r *SessionRepository) Delete(ctx context.Context, id, userID uuid.UUID) error {
    return r.queries.DeleteSession(ctx, queries.DeleteSessionParams{
        ID:     id,
        UserID: userID,
    })
}

// DeleteAllExcept removes all sessions except the specified one.
func (r *SessionRepository) DeleteAllExcept(ctx context.Context, userID, exceptID uuid.UUID) error {
    return r.queries.DeleteAllSessionsExceptCurrent(ctx, queries.DeleteAllSessionsExceptCurrentParams{
        UserID: userID,
        ID:     exceptID,
    })
}

// DeleteAllForUser removes all sessions for a user.
func (r *SessionRepository) DeleteAllForUser(ctx context.Context, userID uuid.UUID) error {
    return r.queries.DeleteAllUserSessions(ctx, userID)
}
```

Add `"time"` to imports.

2. Create backend/internal/domain/auth/session/handler.go:
```go
package session

import (
    "context"
    "time"

    "github.com/danielgtaylor/huma/v2"
    "github.com/google/uuid"

    appMiddleware "github.com/antti/home-warehouse/go-backend/internal/api/middleware"
)

// Handler holds dependencies for session HTTP handlers.
type Handler struct {
    svc ServiceInterface
}

// NewHandler creates a new session handler.
func NewHandler(svc ServiceInterface) *Handler {
    return &Handler{svc: svc}
}

// RegisterRoutes registers session routes (protected).
func (h *Handler) RegisterRoutes(api huma.API) {
    huma.Get(api, "/users/me/sessions", h.listSessions)
    huma.Delete(api, "/users/me/sessions/{id}", h.revokeSession)
    huma.Delete(api, "/users/me/sessions", h.revokeAllOtherSessions)
}

// SessionResponse represents a session in API responses.
type SessionResponse struct {
    ID           uuid.UUID `json:"id"`
    DeviceInfo   string    `json:"device_info"`
    IPAddress    string    `json:"ip_address,omitempty"`
    LastActiveAt time.Time `json:"last_active_at"`
    CreatedAt    time.Time `json:"created_at"`
    IsCurrent    bool      `json:"is_current"`
}

type ListSessionsOutput struct {
    Body []SessionResponse
}

func (h *Handler) listSessions(ctx context.Context, input *struct{}) (*ListSessionsOutput, error) {
    authUser, ok := appMiddleware.GetAuthUser(ctx)
    if !ok {
        return nil, huma.Error401Unauthorized("not authenticated")
    }

    // Get current session ID from context (set by auth middleware)
    currentSessionID, _ := appMiddleware.GetCurrentSessionID(ctx)

    sessions, err := h.svc.FindByUserID(ctx, authUser.ID)
    if err != nil {
        return nil, huma.Error500InternalServerError("failed to get sessions")
    }

    result := make([]SessionResponse, len(sessions))
    for i, s := range sessions {
        result[i] = SessionResponse{
            ID:           s.ID(),
            DeviceInfo:   s.DeviceInfo(),
            IPAddress:    s.IPAddress(),
            LastActiveAt: s.LastActiveAt(),
            CreatedAt:    s.CreatedAt(),
            IsCurrent:    s.ID() == currentSessionID,
        }
    }

    return &ListSessionsOutput{Body: result}, nil
}

type RevokeSessionInput struct {
    ID uuid.UUID `path:"id" format:"uuid"`
}

func (h *Handler) revokeSession(ctx context.Context, input *RevokeSessionInput) (*struct{}, error) {
    authUser, ok := appMiddleware.GetAuthUser(ctx)
    if !ok {
        return nil, huma.Error401Unauthorized("not authenticated")
    }

    // Prevent revoking current session
    currentSessionID, _ := appMiddleware.GetCurrentSessionID(ctx)
    if input.ID == currentSessionID {
        return nil, huma.Error400BadRequest("cannot revoke current session")
    }

    if err := h.svc.Revoke(ctx, authUser.ID, input.ID); err != nil {
        return nil, huma.Error500InternalServerError("failed to revoke session")
    }

    return nil, nil
}

func (h *Handler) revokeAllOtherSessions(ctx context.Context, input *struct{}) (*struct{}, error) {
    authUser, ok := appMiddleware.GetAuthUser(ctx)
    if !ok {
        return nil, huma.Error401Unauthorized("not authenticated")
    }

    currentSessionID, ok := appMiddleware.GetCurrentSessionID(ctx)
    if !ok {
        return nil, huma.Error400BadRequest("current session not found")
    }

    if err := h.svc.RevokeAllExcept(ctx, authUser.ID, currentSessionID); err != nil {
        return nil, huma.Error500InternalServerError("failed to revoke sessions")
    }

    return nil, nil
}
```
  </action>
  <verify>`cd /home/antti/Repos/Misc/home-warehouse-system/backend && go build ./internal/...`</verify>
  <done>Session repository and handler compile without errors</done>
</task>

<task type="auto">
  <name>Task 3: Integrate sessions into auth flow and wire up in main</name>
  <files>
    backend/internal/api/middleware/auth.go
    backend/internal/domain/auth/user/handler.go
    backend/cmd/server/main.go
  </files>
  <action>
1. Update backend/internal/api/middleware/auth.go to add session ID context:

Add after existing context keys:
```go
type currentSessionIDKey struct{}

// WithCurrentSessionID adds the current session ID to context.
func WithCurrentSessionID(ctx context.Context, sessionID uuid.UUID) context.Context {
    return context.WithValue(ctx, currentSessionIDKey{}, sessionID)
}

// GetCurrentSessionID retrieves the current session ID from context.
func GetCurrentSessionID(ctx context.Context) (uuid.UUID, bool) {
    id, ok := ctx.Value(currentSessionIDKey{}).(uuid.UUID)
    return id, ok
}
```

2. Update backend/internal/domain/auth/user/handler.go:

Add session service to Handler:
```go
type Handler struct {
    svc            ServiceInterface
    jwtService     jwt.ServiceInterface
    workspaceSvc   workspace.ServiceInterface
    sessionSvc     session.ServiceInterface  // NEW
    avatarStorage  AvatarStorage
    imageProcessor AvatarImageProcessor
    uploadDir      string
}
```

Update NewHandler:
```go
func NewHandler(svc ServiceInterface, jwtService jwt.ServiceInterface, workspaceSvc workspace.ServiceInterface) *Handler {
    return &Handler{
        svc:          svc,
        jwtService:   jwtService,
        workspaceSvc: workspaceSvc,
    }
}

// SetSessionService sets the session service for session tracking.
func (h *Handler) SetSessionService(sessionSvc session.ServiceInterface) {
    h.sessionSvc = sessionSvc
}
```

Modify login handler to create session (after generating tokens):
```go
func (h *Handler) login(ctx context.Context, input *LoginInput) (*LoginOutput, error) {
    // ... existing auth code ...

    // Create session if session service is configured
    if h.sessionSvc != nil {
        userAgent := "" // Will get from request context
        ipAddress := "" // Will get from request context
        if reqCtx, ok := ctx.Value(huma.RequestKey).(*http.Request); ok {
            userAgent = reqCtx.Header.Get("User-Agent")
            ipAddress = getClientIP(reqCtx)
        }
        _, _ = h.sessionSvc.Create(ctx, user.ID(), refreshToken, userAgent, ipAddress)
    }

    return &LoginOutput{...}, nil
}
```

Add helper to get client IP:
```go
func getClientIP(r *http.Request) string {
    // Check X-Forwarded-For first (for proxies)
    if xff := r.Header.Get("X-Forwarded-For"); xff != "" {
        parts := strings.Split(xff, ",")
        return strings.TrimSpace(parts[0])
    }
    // Check X-Real-IP
    if xri := r.Header.Get("X-Real-IP"); xri != "" {
        return xri
    }
    // Fall back to RemoteAddr
    host, _, _ := net.SplitHostPort(r.RemoteAddr)
    return host
}
```

Modify refreshToken handler to validate and update session:
```go
func (h *Handler) refreshToken(ctx context.Context, input *RefreshTokenInput) (*RefreshTokenOutput, error) {
    // ... existing validation ...

    // Validate session exists (if session service configured)
    var currentSession *session.Session
    if h.sessionSvc != nil {
        tokenHash := session.HashToken(input.Body.RefreshToken)
        currentSession, err = h.sessionSvc.FindByTokenHash(ctx, tokenHash)
        if err != nil {
            return nil, huma.Error401Unauthorized("session has been revoked")
        }
    }

    // ... generate new tokens ...

    // Update session with new token
    if h.sessionSvc != nil && currentSession != nil {
        _ = h.sessionSvc.UpdateActivity(ctx, currentSession.ID(), refreshToken)
    }

    return &RefreshTokenOutput{...}, nil
}
```

Modify logout handler to delete session:
```go
func (h *Handler) logout(ctx context.Context, input *struct{}) (*LogoutOutput, error) {
    // Delete session if we can identify it
    if h.sessionSvc != nil {
        // Session deletion would require knowing the current session
        // For now, just clear cookies - session will expire
    }

    return &LogoutOutput{...}, nil
}
```

3. Update backend/cmd/server/main.go to wire session service:

Add imports and create session service after user service:
```go
import (
    // ... existing imports ...
    "github.com/antti/home-warehouse/go-backend/internal/domain/auth/session"
)

// After creating user service
sessionRepo := infra.NewSessionRepository(queries)
sessionSvc := session.NewService(sessionRepo)
sessionHandler := session.NewHandler(sessionSvc)

// Set session service on user handler
userHandler.SetSessionService(sessionSvc)

// Register session routes in protected routes section
sessionHandler.RegisterRoutes(protectedApi)
```
  </action>
  <verify>
1. `cd /home/antti/Repos/Misc/home-warehouse-system/backend && go build ./...`
2. Server starts: `mise run dev` (in background, then Ctrl+C)
  </verify>
  <done>Session service integrated into auth flow, login creates sessions, refresh validates sessions, session endpoints available</done>
</task>

</tasks>

<verification>
1. Backend compiles: `cd backend && go build ./...`
2. Server starts without errors
3. Login creates session: Check database after login
4. GET /users/me/sessions returns session list
5. DELETE /users/me/sessions/:id revokes specific session
6. DELETE /users/me/sessions revokes all other sessions
7. Token refresh with revoked session returns 401
</verification>

<success_criteria>
- Login creates session record with device_info parsed from user agent
- Token refresh validates session exists (revoked sessions return 401)
- Session list endpoint returns active sessions with is_current marker
- Individual session revocation works (except current session)
- "Logout all others" revokes all sessions except current
- Backend compiles and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/28-security-settings/28-03-SUMMARY.md`
</output>
