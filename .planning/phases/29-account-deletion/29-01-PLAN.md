---
phase: 29-account-deletion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/db/queries/workspace_members.sql
  - backend/internal/infra/queries/workspace_members.sql.go
  - backend/internal/infra/queries/models.go
  - backend/internal/domain/auth/user/service.go
  - backend/internal/domain/auth/user/handler.go
  - backend/internal/domain/auth/user/errors.go
autonomous: true

must_haves:
  truths:
    - "Backend can identify workspaces where user is sole owner"
    - "Backend prevents deletion if user is sole owner of any workspace"
    - "Backend deletes user account when constraints satisfied"
    - "Backend clears auth cookies after deletion"
    - "Backend cleans up avatar file before user deletion"
  artifacts:
    - path: "backend/db/queries/workspace_members.sql"
      provides: "GetUserSoleOwnerWorkspaces query"
      contains: "GetUserSoleOwnerWorkspaces"
    - path: "backend/internal/domain/auth/user/handler.go"
      provides: "DELETE /users/me endpoint"
      contains: "deleteMe"
    - path: "backend/internal/domain/auth/user/service.go"
      provides: "Delete and CanDelete methods"
      contains: "CanDelete"
    - path: "backend/internal/domain/auth/user/errors.go"
      provides: "ErrSoleOwnerOfWorkspace error"
      contains: "ErrSoleOwnerOfWorkspace"
  key_links:
    - from: "handler.go deleteMe"
      to: "service.go CanDelete"
      via: "method call"
      pattern: "h\\.svc\\.CanDelete"
    - from: "handler.go deleteMe"
      to: "avatarStorage.DeleteAvatar"
      via: "file cleanup before delete"
      pattern: "avatarStorage\\.DeleteAvatar"
    - from: "service.go CanDelete"
      to: "queries GetUserSoleOwnerWorkspaces"
      via: "repository call"
      pattern: "GetUserSoleOwnerWorkspaces"
---

<objective>
Implement backend account deletion with sole owner validation

Purpose: Enable users to delete their account while preventing orphaned workspaces where they are the sole owner. Database cascades handle data cleanup automatically.

Output: DELETE /users/me endpoint with validation, GET /users/me/can-delete check endpoint
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-account-deletion/29-RESEARCH.md

# Codebase patterns
@backend/db/queries/workspace_members.sql
@backend/db/queries/users.sql
@backend/internal/domain/auth/user/handler.go
@backend/internal/domain/auth/user/service.go
@backend/internal/domain/auth/user/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GetUserSoleOwnerWorkspaces SQL query</name>
  <files>
    backend/db/queries/workspace_members.sql
  </files>
  <action>
Add a new sqlc query to find workspaces where a user is the sole owner (blocking account deletion).

Query name: GetUserSoleOwnerWorkspaces
Returns: Array of workspaces (id, name, slug, is_personal)
Logic:
- Join auth.workspaces with auth.workspace_members
- Filter by user_id = $1 AND role = 'owner'
- Filter by is_personal = false (personal workspace should NOT block deletion)
- Subquery: COUNT owners for workspace = 1 (user is the ONLY owner)

Example query from RESEARCH.md:
```sql
-- name: GetUserSoleOwnerWorkspaces :many
-- Returns workspaces where the user is the ONLY owner (blocking account deletion)
SELECT w.id, w.name, w.slug, w.is_personal
FROM auth.workspaces w
JOIN auth.workspace_members wm ON w.id = wm.workspace_id
WHERE wm.user_id = $1
  AND wm.role = 'owner'
  AND w.is_personal = false
  AND (
    SELECT COUNT(*) FROM auth.workspace_members
    WHERE workspace_id = w.id AND role = 'owner'
  ) = 1;
```

After adding, run `mise run sqlc` to generate Go code.
  </action>
  <verify>
Run `mise run sqlc` - should complete without errors.
Check that backend/internal/infra/queries/workspace_members.sql.go has GetUserSoleOwnerWorkspaces function generated.
  </verify>
  <done>
GetUserSoleOwnerWorkspaces query exists in workspace_members.sql and corresponding Go code is generated by sqlc.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CanDelete and Delete service methods</name>
  <files>
    backend/internal/domain/auth/user/service.go
    backend/internal/domain/auth/user/errors.go
  </files>
  <action>
1. In errors.go, add new error:
```go
var ErrSoleOwnerOfWorkspace = errors.New("user is sole owner of one or more workspaces")
```

2. In service.go, add two new methods to ServiceInterface:
```go
// CanDelete checks if a user can delete their account
CanDelete(ctx context.Context, userID uuid.UUID) (canDelete bool, blockingWorkspaces []BlockingWorkspace, err error)

// Delete permanently deletes a user account
Delete(ctx context.Context, userID uuid.UUID) error
```

3. Add BlockingWorkspace struct (for returning workspace details to frontend):
```go
type BlockingWorkspace struct {
    ID         uuid.UUID
    Name       string
    Slug       string
    IsPersonal bool
}
```

4. Implement CanDelete in Service:
- Call queries.GetUserSoleOwnerWorkspaces(ctx, userID)
- If results exist, return false with list of blocking workspaces
- If empty, return true with nil

5. Implement Delete in Service:
- Call queries.DeleteUser(ctx, userID) - already exists in users.sql
- PostgreSQL ON DELETE CASCADE handles related data cleanup automatically

Note: Avatar cleanup is handled in handler, not service (matches existing pattern in deleteAvatar handler).
  </action>
  <verify>
Run `mise run build` - should compile without errors.
Run `mise run test-unit` - existing tests should pass.
  </verify>
  <done>
Service has CanDelete and Delete methods. ErrSoleOwnerOfWorkspace error is defined. ServiceInterface updated with new methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add DELETE /users/me and GET /users/me/can-delete endpoints</name>
  <files>
    backend/internal/domain/auth/user/handler.go
  </files>
  <action>
1. Add two new Huma request/response types:

```go
// CanDeleteAccountOutput for GET /users/me/can-delete
type CanDeleteAccountOutput struct {
    Body CanDeleteAccountResponse
}

type CanDeleteAccountResponse struct {
    CanDelete          bool                     `json:"can_delete"`
    BlockingWorkspaces []BlockingWorkspaceDTO   `json:"blocking_workspaces"`
}

type BlockingWorkspaceDTO struct {
    ID   uuid.UUID `json:"id"`
    Name string    `json:"name"`
    Slug string    `json:"slug"`
}

// DeleteAccountInput for DELETE /users/me
type DeleteAccountInput struct {
    Body struct {
        Confirmation string `json:"confirmation" required:"true"`
    }
}

type DeleteAccountOutput struct {
    SetCookie []http.Cookie `header:"Set-Cookie"`
}
```

2. Add canDeleteMe handler:
- Get auth user from context
- Call h.svc.CanDelete(ctx, authUser.ID)
- Return CanDeleteAccountResponse with result

3. Add deleteMe handler:
- Get auth user from context
- Validate input.Body.Confirmation == "DELETE" (case-insensitive with strings.EqualFold or ToUpper)
- Return 400 if confirmation doesn't match
- Call h.svc.CanDelete to check constraints
- Return 409 Conflict with blocking workspaces if cannot delete
- Delete avatar file if exists (before deleting user - same pattern as deleteAvatar handler)
- Call h.svc.Delete(ctx, authUser.ID)
- Return response with clearAuthCookie for both access_token and refresh_token

4. Register endpoints in RegisterProtectedRoutes:
```go
huma.Get(api, "/users/me/can-delete", h.canDeleteMe)
huma.Delete(api, "/users/me", h.deleteMe)
```
  </action>
  <verify>
Run `mise run build` - should compile without errors.
Start server with `mise run dev` and test:
- `curl -X GET http://localhost:8000/users/me/can-delete -H "Cookie: access_token=..."` returns 200 with can_delete status
- `curl -X DELETE http://localhost:8000/users/me -H "Cookie: access_token=..." -d '{"confirmation":"DELETE"}'` returns 200 with Set-Cookie headers clearing auth
  </verify>
  <done>
GET /users/me/can-delete returns deletion eligibility with blocking workspaces.
DELETE /users/me validates confirmation, checks sole owner constraint, cleans up avatar, deletes user, and clears auth cookies.
  </done>
</task>

</tasks>

<verification>
1. `mise run build` compiles successfully
2. `mise run sqlc` generates without errors
3. `mise run test` passes (existing tests still work)
4. Manual test: Create user, make them sole owner of workspace, attempt delete - should fail with 409 and list workspace
5. Manual test: Create user with no sole-owner workspaces, delete with wrong confirmation - should fail with 400
6. Manual test: Create user with no sole-owner workspaces, delete with "DELETE" confirmation - should succeed with cleared cookies
</verification>

<success_criteria>
- GetUserSoleOwnerWorkspaces query returns workspaces blocking deletion (excludes personal workspace)
- CanDelete service method accurately reports deletion eligibility
- Delete service method removes user from database
- DELETE /users/me validates confirmation text is "DELETE"
- DELETE /users/me returns 409 with workspace list if user is sole owner
- DELETE /users/me clears auth cookies on successful deletion
- DELETE /users/me cleans up avatar file before user deletion
- GET /users/me/can-delete provides pre-check for frontend
</success_criteria>

<output>
After completion, create `.planning/phases/29-account-deletion/29-01-SUMMARY.md`
</output>
