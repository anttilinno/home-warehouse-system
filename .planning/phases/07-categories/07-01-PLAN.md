---
phase: 07-categories
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/hooks/use-offline-mutation.ts
  - frontend/lib/sync/sync-manager.ts
  - frontend/app/[locale]/(dashboard)/dashboard/categories/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a category while offline and see it immediately with pending badge"
    - "User can update category details while offline and see changes immediately"
    - "User can create subcategory under existing or pending parent while offline"
    - "Pending category rows show parent name context (e.g., 'Pending... under Electronics')"
    - "Drag-drop is disabled for pending categories"
  artifacts:
    - path: "frontend/lib/hooks/use-offline-mutation.ts"
      provides: "dependsOn parameter support for hierarchical mutations"
      contains: "dependsOn"
    - path: "frontend/lib/sync/sync-manager.ts"
      provides: "Topological sort for hierarchical categories"
      contains: "topologicalSortCategories"
    - path: "frontend/app/[locale]/(dashboard)/dashboard/categories/page.tsx"
      provides: "Offline mutation support with optimistic UI"
      contains: "useOfflineMutation"
  key_links:
    - from: "frontend/app/[locale]/(dashboard)/dashboard/categories/page.tsx"
      to: "frontend/lib/hooks/use-offline-mutation.ts"
      via: "useOfflineMutation hook import"
      pattern: "useOfflineMutation"
    - from: "frontend/lib/sync/sync-manager.ts"
      to: "topologicalSortCategories"
      via: "function call in processQueue"
      pattern: "topologicalSortCategories\\(mutations\\)"
---

<objective>
Add offline mutation support for categories with hierarchical dependency handling

Purpose: Enable users to create and update categories while offline, with correct sync ordering for parent-child relationships and visual pending indicators.

Output: Categories page supports offline create/update with optimistic UI, topological sort ensures correct sync order, pending badges show parent context.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-categories/07-RESEARCH.md
@.planning/phases/06-infrastructure-borrowers/06-02-SUMMARY.md

# Existing implementation patterns
@frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx
@frontend/lib/sync/sync-manager.ts
@frontend/app/[locale]/(dashboard)/dashboard/categories/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependsOn support to useOfflineMutation hook</name>
  <files>frontend/lib/hooks/use-offline-mutation.ts</files>
  <action>
The useOfflineMutation hook needs to support a `dependsOn` parameter for hierarchical entities where child mutations depend on parent mutations.

1. **Update UseOfflineMutationOptions interface** - Add dependsOn to onMutate callback signature:
   ```typescript
   onMutate?: (payload: TPayload, tempId: string, dependsOn?: string[]) => void;
   ```

2. **Update UseOfflineMutationResult interface** - Add third parameter to mutate:
   ```typescript
   mutate: (payload: TPayload, entityId?: string, dependsOn?: string[]) => Promise<string>;
   ```

3. **Update mutate function signature** in useCallback:
   ```typescript
   const mutate = useCallback(
     async (payload: TPayload, entityId?: string, dependsOn?: string[]): Promise<string> => {
   ```

4. **Pass dependsOn to queueMutation** - Update the queueMutation call:
   ```typescript
   const entry = await queueMutation({
     operation,
     entity,
     entityId,
     payload: payload as Record<string, unknown>,
     dependsOn, // Add this line
   });
   ```

5. **Pass dependsOn to onMutate callback**:
   ```typescript
   if (onMutate) {
     startTransition(() => {
       onMutate(payload, tempId, dependsOn);
     });
   }
   ```
  </action>
  <verify>
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
- Existing tests pass: `cd frontend && npm test`
  </verify>
  <done>
useOfflineMutation hook accepts dependsOn as third parameter to mutate(), passes it to queueMutation(), and provides it to onMutate callback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add topological sort for categories in sync-manager</name>
  <files>frontend/lib/sync/sync-manager.ts</files>
  <action>
Add a topologicalSortCategories function using Kahn's algorithm (~20 lines) that sorts category create mutations by parent-child dependency.

Implementation:
1. Add function `topologicalSortCategories(mutations: MutationQueueEntry[]): MutationQueueEntry[]` before the SyncManager class
2. Separate creates from updates (only creates need sorting)
3. Build indegree map from parent_category_id references where parent is also a pending create
4. Apply Kahn's algorithm: start with nodes with indegree 0, decrement children's indegree
5. Return sorted creates followed by updates

In processQueue method, after grouping mutations by entity type:
- When processing 'categories' entity, apply topologicalSortCategories before iterating
- Pattern: `const sortedMutations = entityType === 'categories' ? topologicalSortCategories(mutations) : mutations;`

Reference the algorithm from 07-RESEARCH.md Pattern 1.
  </action>
  <verify>
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
- Vitest unit tests pass: `cd frontend && npm test`
  </verify>
  <done>
Topological sort function exists in sync-manager.ts and is called for categories entity during queue processing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add offline mutation support to categories page</name>
  <files>frontend/app/[locale]/(dashboard)/dashboard/categories/page.tsx</files>
  <action>
Integrate offline mutation support following the exact borrowers page pattern with tree-specific adaptations.

1. **Imports** - Add at top:
   - `import { Cloud } from "lucide-react";`
   - `import { Badge } from "@/components/ui/badge";`
   - `import { cn } from "@/lib/utils";`
   - `import { useOfflineMutation } from "@/lib/hooks/use-offline-mutation";`
   - `import { syncManager } from "@/lib/sync/sync-manager";`
   - `import type { SyncEvent } from "@/lib/sync/sync-manager";`

2. **Optimistic state** - Add state in CategoriesPage:
   ```typescript
   const [optimisticCategories, setOptimisticCategories] = useState<(Category & { _pending?: boolean })[]>([]);
   ```

3. **Create mutation hook**:
   ```typescript
   const { mutate: createCategoryOffline } = useOfflineMutation<Record<string, unknown>>({
     entity: 'categories',
     operation: 'create',
     onMutate: (payload, tempId, dependsOn) => {
       const optimisticCategory: Category & { _pending: boolean } = {
         id: tempId,
         workspace_id: workspaceId!,
         name: (payload.name as string) || '',
         description: (payload.description as string) || null,
         parent_category_id: (payload.parent_category_id as string) || null,
         created_at: new Date().toISOString(),
         updated_at: new Date().toISOString(),
         _pending: true,
       };
       setOptimisticCategories(prev => [...prev, optimisticCategory]);
     },
   });
   ```

4. **Update mutation hook**:
   ```typescript
   const { mutate: updateCategoryOffline } = useOfflineMutation<Record<string, unknown>>({
     entity: 'categories',
     operation: 'update',
     onMutate: (payload, _tempId) => {
       const entityId = payload._entityId as string;
       if (entityId) {
         setOptimisticCategories(prev => {
           const existing = prev.find(c => c.id === entityId);
           if (existing) {
             return prev.map(c => c.id === entityId ? { ...c, ...payload, _pending: true } : c);
           }
           const fromFetched = categories.find(c => c.id === entityId);
           if (fromFetched) {
             return [...prev, { ...fromFetched, ...payload, _pending: true }];
           }
           return prev;
         });
       }
     },
   });
   ```

5. **Sync event subscription** - Add useEffect:
   ```typescript
   useEffect(() => {
     if (!syncManager) return;

     const handleSyncEvent = (event: SyncEvent) => {
       if (event.type === 'MUTATION_SYNCED' && event.payload?.mutation?.entity === 'categories') {
         const syncedKey = event.payload.mutation.idempotencyKey;
         const entityId = event.payload.mutation.entityId;
         setOptimisticCategories(prev => prev.filter(c => c.id !== syncedKey && c.id !== entityId));
         loadCategories();
       }
       if (event.type === 'MUTATION_FAILED' && event.payload?.mutation?.entity === 'categories') {
         toast.error('Failed to sync category', {
           description: event.payload.mutation.lastError || 'Please try again',
         });
       }
     };

     return syncManager.subscribe(handleSyncEvent);
   }, [loadCategories]);
   ```

6. **Merge categories** - Add useMemo after loadCategories:
   ```typescript
   const mergedCategories = useMemo(() => {
     const fetchedIds = new Set(categories.map(c => c.id));
     const merged = categories.map(c => {
       const optimistic = optimisticCategories.find(o => o.id === c.id);
       if (optimistic) return { ...c, ...optimistic, _pending: true };
       return c;
     });
     const newOptimistic = optimisticCategories.filter(o => !fetchedIds.has(o.id));
     return [...merged, ...newOptimistic];
   }, [categories, optimisticCategories]);
   ```

7. **Update tree building** - Change `buildCategoryTree(categories)` to `buildCategoryTree(mergedCategories)` in the `tree` useMemo

8. **Update handleSave** - Replace API calls with offline mutations:
   - For create: Check if parent is pending, pass dependsOn if so
   ```typescript
   const parentIsPending = formParentId && optimisticCategories.some(
     c => c.id === formParentId && c._pending
   );
   const dependsOn = parentIsPending ? [formParentId] : undefined;
   createCategoryOffline({
     name: formName.trim(),
     description: formDescription.trim() || null,
     parent_category_id: formParentId,
   }, undefined, dependsOn);
   ```
   - For update: Use updateCategoryOffline with _entityId
   - Show success toast, close dialog, DON'T call loadCategories (handled by sync event)

9. **Update getAvailableParents** - Include optimistic categories in parent dropdown:
   ```typescript
   const getAvailableParents = (): (Category & { _pending?: boolean })[] => {
     const allCategories = [...categories, ...optimisticCategories.filter(o => !categories.some(c => c.id === o.id))];
     if (!editingCategory) return allCategories;
     // ... existing descendant exclusion logic using allCategories
   };
   ```

10. **Update parent dropdown** - Show "(pending)" suffix for pending parents:
    ```typescript
    {getAvailableParents().map((cat) => (
      <SelectItem key={cat.id} value={cat.id}>
        {cat.name}{'_pending' in cat && cat._pending ? ' (pending)' : ''}
      </SelectItem>
    ))}
    ```
  </action>
  <verify>
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
- Dev server runs: `cd frontend && npm run dev` (manual check page loads)
  </verify>
  <done>
Categories page imports useOfflineMutation, has optimistic state, create/update use offline mutations with dependsOn for pending parents, sync events clear optimistic state.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add pending indicator with parent context and disable drag-drop for pending</name>
  <files>frontend/app/[locale]/(dashboard)/dashboard/categories/page.tsx</files>
  <action>
Add pending badge with parent context to CategoryRow and disable drag-drop for pending categories.

1. **Update CategoryTreeItem interface** to include _pending:
   ```typescript
   interface CategoryTreeItem extends Category {
     children: CategoryTreeItem[];
     expanded?: boolean;
     _pending?: boolean;
   }
   ```

2. **Update CategoryRow props** to pass allCategories for parent lookup:
   ```typescript
   function CategoryRow({
     category,
     level,
     onEdit,
     onDelete,
     onToggle,
     allCategories,
     t,
   }: {
     category: CategoryTreeItem;
     level: number;
     onEdit: (cat: Category) => void;
     onDelete: (cat: Category) => void;
     onToggle: (id: string) => void;
     allCategories: Category[];
     t: ReturnType<typeof useTranslations<"categories">>;
   })
   ```

3. **Add getParentName helper** inside CategoryRow:
   ```typescript
   const getParentName = (parentId: string | null): string | null => {
     if (!parentId) return null;
     const parent = allCategories.find(c => c.id === parentId);
     return parent?.name || null;
   };
   ```

4. **Disable drag-drop for pending categories** - In useSortable call:
   ```typescript
   const {
     attributes,
     listeners,
     setNodeRef,
     transform,
     transition,
     isDragging,
   } = useSortable({
     id: category.id,
     disabled: category._pending === true,
   });
   ```

5. **Add pending styling to row container**:
   ```typescript
   className={cn(
     "flex items-center gap-2 py-2 px-3 hover:bg-muted/50 rounded-lg group",
     level > 0 && "ml-6",
     isDragging && "cursor-grabbing",
     category._pending && "bg-amber-50"
   )}
   ```

6. **Hide drag handle for pending categories**:
   ```typescript
   {!category._pending && (
     <div
       {...listeners}
       className="cursor-grab active:cursor-grabbing p-1 rounded hover:bg-muted opacity-0 group-hover:opacity-100"
       style={{ marginLeft: level * 24 }}
     >
       <GripVertical className="h-4 w-4 text-muted-foreground" aria-hidden="true" />
     </div>
   )}
   {category._pending && (
     <div style={{ marginLeft: level * 24, width: 32 }} /> {/* Spacer */}
   )}
   ```

7. **Add pending badge after the name div**:
   ```typescript
   {category._pending && (
     <Badge variant="outline" className="text-xs text-amber-600 border-amber-300 shrink-0">
       <Cloud className="w-3 h-3 mr-1 animate-pulse" />
       {(() => {
         if (!category.parent_category_id) return 'Pending';
         const parentName = getParentName(category.parent_category_id);
         return parentName ? `Pending... under ${parentName}` : 'Pending';
       })()}
     </Badge>
   )}
   ```

8. **Update all CategoryRow usages** to pass allCategories prop:
   ```typescript
   <CategoryRow
     key={category.id}
     category={category}
     level={0}
     onEdit={openEditDialog}
     onDelete={openDeleteDialog}
     onToggle={handleToggle}
     allCategories={mergedCategories}
     t={t}
   />
   ```
   Also update the recursive call inside CategoryRow for children.

9. **Prevent edit/delete for pending categories** - Add disabled state to dropdown menu items when category._pending is true, or simply hide the dropdown:
   ```typescript
   {!category._pending && (
     <DropdownMenu>
       {/* ... existing dropdown ... */}
     </DropdownMenu>
   )}
   ```
  </action>
  <verify>
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
- Vitest tests pass: `cd frontend && npm test`
  </verify>
  <done>
CategoryRow shows pending badge with parent context, has amber background for pending rows, drag handles hidden for pending categories, edit/delete disabled for pending.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd frontend && npx tsc --noEmit` - No TypeScript errors
2. `cd frontend && npm test` - All vitest tests pass
3. Manual verification (dev server):
   - Create category offline - appears with "Pending" badge
   - Create subcategory under pending parent - appears with "Pending... under [ParentName]"
   - Pending categories cannot be dragged
   - Go online - pending badges disappear, categories persist
</verification>

<success_criteria>
1. Categories page supports offline create with optimistic UI
2. Categories page supports offline update with optimistic UI
3. Subcategories under pending parents show correct parent context
4. Topological sort ensures parent syncs before child
5. Drag-drop disabled for pending categories
6. All TypeScript and vitest tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-categories/07-01-SUMMARY.md`
</output>
