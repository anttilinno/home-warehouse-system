---
phase: 07-categories
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - frontend/e2e/offline/offline-categories.spec.ts
autonomous: true

must_haves:
  truths:
    - "E2E test verifies category create offline with pending indicator"
    - "E2E test verifies category update offline with pending indicator"
    - "E2E test verifies subcategory under pending parent shows correct context"
    - "All E2E tests pass in Chromium"
  artifacts:
    - path: "frontend/e2e/offline/offline-categories.spec.ts"
      provides: "E2E tests for offline category mutations"
      min_lines: 100
  key_links:
    - from: "frontend/e2e/offline/offline-categories.spec.ts"
      to: "/en/dashboard/categories"
      via: "page.goto"
      pattern: "page\\.goto.*categories"
---

<objective>
Add E2E tests for offline category mutations including hierarchical parent-child scenarios

Purpose: Validate the offline category functionality works end-to-end, including the special case of creating subcategories under pending parents.

Output: E2E test file covering offline create, update, and hierarchical subcategory scenarios.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-categories/07-RESEARCH.md
@.planning/phases/07-categories/07-01-SUMMARY.md

# Test patterns
@frontend/e2e/offline/offline-borrowers.spec.ts
@frontend/e2e/fixtures/authenticated.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create E2E tests for offline category mutations</name>
  <files>frontend/e2e/offline/offline-categories.spec.ts</files>
  <action>
Create E2E test file following the exact pattern from offline-borrowers.spec.ts with category-specific tests.

```typescript
import { test, expect } from "../fixtures/authenticated";

/**
 * Offline category mutation E2E tests.
 *
 * Tests the full offline create/update flow for categories including
 * hierarchical parent-child relationships:
 * - Create category while offline
 * - Update category while offline
 * - Create subcategory under pending parent
 * - Verify pending indicators with parent context
 *
 * Chromium only: WebKit and Firefox have inconsistent offline simulation.
 */
test.describe("Offline Category Mutations", () => {
  test.skip(({ browserName }) => browserName !== "chromium", "Chromium only");

  // Run tests serially to avoid auth state conflicts
  test.describe.configure({ mode: "serial" });

  test.beforeEach(async ({ page }) => {
    // Navigate to categories page and wait for it to load
    await page.goto("/en/dashboard/categories");
    await page.waitForLoadState("domcontentloaded");
    await expect(page.locator("main")).toBeVisible({ timeout: 15000 });
  });

  test("creates category while offline with pending indicator", async ({ page, context }) => {
    const uniqueName = `Offline Category ${Date.now()}`;

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));

    // Verify offline indicator appears
    const offlineIndicator = page.locator('[data-testid="offline-indicator"]');
    await expect(offlineIndicator).toBeVisible({ timeout: 5000 });

    // Click Add Category button (the button with Plus icon)
    await page.getByRole("button", { name: /Add Category/i }).click();

    // Wait for dialog to open
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    // Fill the form
    await page.getByLabel(/Name/i).fill(uniqueName);

    // Submit the form
    await page.getByRole("button", { name: /Save/i }).click();

    // Dialog should close
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify optimistic category appears with pending indicator
    await expect(page.getByText(uniqueName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText("Pending")).toBeVisible({ timeout: 5000 });

    // Go back online
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for sync - pending indicator should disappear
    await expect(page.getByText("Pending")).not.toBeVisible({ timeout: 15000 });

    // Category should still be visible after sync
    await expect(page.getByText(uniqueName)).toBeVisible();
  });

  test("updates category while offline with pending indicator", async ({ page, context }) => {
    // First, ensure we have a category to update
    // Check for existing categories in the tree
    const categoryRows = page.locator('[role="treeitem"]');

    // If no categories exist, create one first (online)
    const rowCount = await categoryRows.count();
    if (rowCount === 0) {
      await page.getByRole("button", { name: /Add Category/i }).click();
      await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });
      await page.getByLabel(/Name/i).fill(`Test Category ${Date.now()}`);
      await page.getByRole("button", { name: /Save/i }).click();
      await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });
      // Wait for category to appear
      await expect(categoryRows.first()).toBeVisible({ timeout: 10000 });
    }

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));
    await expect(page.locator('[data-testid="offline-indicator"]')).toBeVisible({ timeout: 5000 });

    // Click on the first category's action menu
    const firstRow = categoryRows.first();
    await firstRow.hover();
    await firstRow.getByRole("button", { name: /Actions/i }).click();
    await page.getByRole("menuitem", { name: /Edit/i }).click();

    // Wait for dialog
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    // Update the name
    const updatedName = `Updated Category ${Date.now()}`;
    await page.getByLabel(/Name/i).clear();
    await page.getByLabel(/Name/i).fill(updatedName);

    // Submit
    await page.getByRole("button", { name: /Save/i }).click();

    // Dialog should close
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify updated category appears with pending indicator
    await expect(page.getByText(updatedName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText("Pending")).toBeVisible({ timeout: 5000 });

    // Go back online
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for sync
    await expect(page.getByText("Pending")).not.toBeVisible({ timeout: 15000 });

    // Updated name should still be visible
    await expect(page.getByText(updatedName)).toBeVisible();
  });

  test("creates subcategory under pending parent with correct context", async ({ page, context }) => {
    const parentName = `Parent Category ${Date.now()}`;
    const childName = `Child Category ${Date.now()}`;

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));
    await expect(page.locator('[data-testid="offline-indicator"]')).toBeVisible({ timeout: 5000 });

    // Create parent category
    await page.getByRole("button", { name: /Add Category/i }).click();
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });
    await page.getByLabel(/Name/i).fill(parentName);
    await page.getByRole("button", { name: /Save/i }).click();
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify parent appears with pending indicator
    await expect(page.getByText(parentName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText("Pending")).toBeVisible({ timeout: 5000 });

    // Create child category under pending parent
    await page.getByRole("button", { name: /Add Category/i }).click();
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });
    await page.getByLabel(/Name/i).fill(childName);

    // Select the pending parent from dropdown
    await page.getByLabel(/Parent/i).click();
    // The pending parent should show with (pending) suffix
    await page.getByRole("option", { name: new RegExp(parentName) }).click();

    await page.getByRole("button", { name: /Save/i }).click();
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify child appears with pending indicator AND parent context
    await expect(page.getByText(childName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText(`Pending... under ${parentName}`)).toBeVisible({ timeout: 5000 });

    // Go online and verify sync order (parent before child)
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for both pending indicators to disappear
    await expect(page.getByText("Pending")).not.toBeVisible({ timeout: 15000 });

    // Both categories should remain visible
    await expect(page.getByText(parentName)).toBeVisible();
    await expect(page.getByText(childName)).toBeVisible();
  });

  test("pending categories cannot be dragged", async ({ page, context }) => {
    const categoryName = `No Drag Category ${Date.now()}`;

    // Go offline and create a category
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));

    await page.getByRole("button", { name: /Add Category/i }).click();
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });
    await page.getByLabel(/Name/i).fill(categoryName);
    await page.getByRole("button", { name: /Save/i }).click();
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify category appears
    await expect(page.getByText(categoryName)).toBeVisible({ timeout: 5000 });

    // Find the pending category row
    const pendingRow = page.locator('[role="treeitem"]').filter({ hasText: categoryName });
    await expect(pendingRow).toBeVisible();

    // Verify drag handle is NOT visible on the pending row
    // (The drag handle should be hidden for pending categories)
    const dragHandle = pendingRow.locator('[class*="cursor-grab"]');
    await expect(dragHandle).not.toBeVisible();

    // Clean up - go online
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));
    await expect(page.getByText("Pending")).not.toBeVisible({ timeout: 15000 });
  });
});
```

Note: The tests use the same patterns as offline-borrowers.spec.ts but adapted for the categories page:
- Categories use tree structure (`[role="treeitem"]`) instead of table rows
- Parent category dropdown selection for subcategory creation
- Verification of "Pending... under [ParentName]" context text
- Verification that drag handles are hidden for pending categories
  </action>
  <verify>
- File exists and has correct structure
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
- E2E tests run (may skip if auth issues persist): `cd frontend && npx playwright test offline-categories.spec.ts --project=chromium`
  </verify>
  <done>
E2E test file created at frontend/e2e/offline/offline-categories.spec.ts with tests for create, update, subcategory under pending parent, and drag-drop disabled verification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run E2E tests and fix any issues</name>
  <files>frontend/e2e/offline/offline-categories.spec.ts</files>
  <action>
Run the E2E tests and fix any selector or timing issues that arise.

1. Run the tests:
   ```bash
   cd frontend && npx playwright test offline-categories.spec.ts --project=chromium
   ```

2. If tests fail due to selector mismatches:
   - Check actual button text (may be translations)
   - Check actual role/label attributes
   - Update selectors to match actual DOM

3. Common fixes needed:
   - Button names might be t("add") not "Add Category" - check translations
   - Dialog labels might differ from assumed names
   - Tree item selectors may need adjustment

4. If auth issues cause failures (known issue from Phase 6):
   - Document which tests fail and why
   - Tests are correctly written, auth infrastructure needs separate fix
   - Mark as "tests written correctly, await auth fix" in summary

5. Run tests a second time to verify any fixes work consistently.
  </action>
  <verify>
- E2E tests run without selector errors
- Tests pass OR failures are documented as auth-related (known issue)
  </verify>
  <done>
E2E tests execute correctly. Any auth-related failures documented. Selector and timing issues resolved.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd frontend && npx tsc --noEmit` - No TypeScript errors
2. E2E tests in offline-categories.spec.ts execute (pass or fail on known auth issues)
3. Tests cover: create offline, update offline, subcategory under pending parent, drag-drop disabled
</verification>

<success_criteria>
1. E2E test file exists at frontend/e2e/offline/offline-categories.spec.ts
2. Tests cover all Phase 7 requirements
3. Tests use correct selectors matching actual DOM structure
4. Tests pass OR failures are documented as related to known auth infrastructure issues
</success_criteria>

<output>
After completion, create `.planning/phases/07-categories/07-02-SUMMARY.md`
</output>
