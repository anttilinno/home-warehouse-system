---
phase: 18-fuzzy-search-infrastructure
plan: 04
type: execute
wave: 4
depends_on: ["18-03"]
files_modified:
  - frontend/lib/hooks/use-global-search.ts
  - frontend/lib/hooks/use-offline-search.ts
autonomous: true

must_haves:
  truths:
    - "User can search and see results within 300ms while offline"
    - "Search automatically switches between online and offline mode based on network status"
    - "Recent searches are shown when search box is focused (5 most recent)"
    - "Autocomplete suggestions appear while typing (5-8 items)"
    - "Fuzzy matching finds items with 1-2 character typos"
  artifacts:
    - path: "frontend/lib/hooks/use-global-search.ts"
      provides: "Enhanced global search hook with offline mode"
      exports: ["useGlobalSearch", "UseGlobalSearchOptions", "UseGlobalSearchReturn"]
      min_lines: 150
    - path: "frontend/lib/hooks/use-offline-search.ts"
      provides: "Hook for managing offline search indices"
      exports: ["useOfflineSearch"]
      min_lines: 50
  key_links:
    - from: "frontend/lib/hooks/use-global-search.ts"
      to: "frontend/lib/hooks/use-network-status.ts"
      via: "offline detection"
      pattern: "import.*useNetworkStatus.*from"
    - from: "frontend/lib/hooks/use-global-search.ts"
      to: "frontend/lib/search/offline-search.ts"
      via: "offline search call"
      pattern: "offlineGlobalSearch"
    - from: "frontend/lib/hooks/use-offline-search.ts"
      to: "frontend/lib/search/offline-search.ts"
      via: "index building"
      pattern: "buildSearchIndices"
---

<objective>
Enhance the global search hook with offline mode detection and Fuse.js-powered offline search.

Purpose: Enables seamless search experience that automatically switches between online API search and offline Fuse.js search based on network status, fulfilling SRCH-01 (instant results), SRCH-02 (fuzzy matching), SRCH-03 (autocomplete), SRCH-04 (recent searches), and SRCH-06 (offline search).

Output: Enhanced useGlobalSearch hook with dual-mode operation.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/phases/18-fuzzy-search-infrastructure/18-01-SUMMARY.md
@.planning/phases/18-fuzzy-search-infrastructure/18-02-SUMMARY.md
@.planning/phases/18-fuzzy-search-infrastructure/18-03-SUMMARY.md

Reference files:
@frontend/lib/hooks/use-global-search.ts
@frontend/lib/hooks/use-network-status.ts
@frontend/lib/search/offline-search.ts
@frontend/lib/api/search.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useOfflineSearch hook for index management</name>
  <files>frontend/lib/hooks/use-offline-search.ts</files>
  <action>
Create `frontend/lib/hooks/use-offline-search.ts` to manage Fuse search indices with proper memoization.

This hook:
- Builds and caches SearchIndices from IndexedDB
- Rebuilds indices when data changes (sync events)
- Provides memoized indices to prevent re-indexing on every render (Pitfall 3-F)

Structure:
```typescript
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import {
  buildSearchIndices,
  offlineGlobalSearch,
  type SearchIndices,
} from "@/lib/search/offline-search";
import type { GlobalSearchResponse } from "@/lib/api/search";

interface UseOfflineSearchReturn {
  /** Whether indices are ready for searching */
  isReady: boolean;
  /** Whether indices are currently being built */
  isBuilding: boolean;
  /** Perform offline search with current indices */
  search: (query: string, limit?: number) => Promise<GlobalSearchResponse | null>;
  /** Rebuild indices (call after sync completes) */
  rebuildIndices: () => Promise<void>;
  /** Last time indices were rebuilt */
  lastUpdated: number | null;
}

export function useOfflineSearch(): UseOfflineSearchReturn {
  const [isReady, setIsReady] = useState(false);
  const [isBuilding, setIsBuilding] = useState(false);
  const [lastUpdated, setLastUpdated] = useState<number | null>(null);
  const indicesRef = useRef<SearchIndices | null>(null);

  // Build indices on mount
  useEffect(() => {
    buildIndices();
  }, []);

  const buildIndices = useCallback(async () => {
    setIsBuilding(true);
    try {
      indicesRef.current = await buildSearchIndices();
      setLastUpdated(Date.now());
      setIsReady(true);
    } catch (error) {
      console.error("[useOfflineSearch] Failed to build indices:", error);
    } finally {
      setIsBuilding(false);
    }
  }, []);

  const search = useCallback(async (query: string, limit = 5) => {
    if (!indicesRef.current) return null;
    return offlineGlobalSearch(indicesRef.current, query, limit);
  }, []);

  const rebuildIndices = useCallback(async () => {
    await buildIndices();
  }, [buildIndices]);

  return {
    isReady,
    isBuilding,
    search,
    rebuildIndices,
    lastUpdated,
  };
}
```

Key design decisions:
- Use ref for indices (stable reference, no re-renders on index change)
- Expose rebuildIndices for sync manager to call
- isReady flag for components to know when search is available
- Memoized search function to avoid recreating on every render
  </action>
  <verify>
Run `cd frontend && bunx tsc --noEmit` to verify TypeScript compiles.
Run `cd frontend && bun run lint` to verify no lint errors.
  </verify>
  <done>useOfflineSearch hook created with memoized indices and rebuild capability</done>
</task>

<task type="auto">
  <name>Task 2: Enhance useGlobalSearch with offline mode</name>
  <files>frontend/lib/hooks/use-global-search.ts</files>
  <action>
Enhance `frontend/lib/hooks/use-global-search.ts` to support dual-mode operation (online/offline).

Changes:

1. **Add network status detection:**
```typescript
import { useNetworkStatus } from "./use-network-status";
import { useOfflineSearch } from "./use-offline-search";
```

2. **Add to options interface:**
```typescript
export interface UseGlobalSearchOptions {
  workspaceId: string;
  debounceMs?: number;
  limit?: number;
  minQueryLength?: number;
  /** Force offline mode for testing */
  forceOffline?: boolean;
}
```

3. **Add to return interface:**
```typescript
export interface UseGlobalSearchReturn {
  // ... existing fields ...

  /** Whether currently searching offline */
  isOffline: boolean;
  /** Whether offline search indices are ready */
  isOfflineReady: boolean;
}
```

4. **Update executeSearch to use dual-mode:**
```typescript
const { isOnline } = useNetworkStatus();
const offlineSearch = useOfflineSearch();

const executeSearch = useCallback(async () => {
  const trimmedQuery = debouncedQuery.trim();

  if (!workspaceId || trimmedQuery.length < minQueryLength) {
    setResults(null);
    setError(null);
    setIsLoading(false);
    return;
  }

  setIsLoading(true);
  setError(null);
  setSelectedIndex(-1);

  try {
    let searchResults: GlobalSearchResponse;

    // Use offline search if offline or forced
    if (!isOnline || forceOffline) {
      if (!offlineSearch.isReady) {
        // Indices not ready yet, show loading state
        setIsLoading(true);
        return;
      }
      const offlineResults = await offlineSearch.search(trimmedQuery, limit);
      if (!offlineResults) {
        throw new Error("Offline search unavailable");
      }
      searchResults = offlineResults;
    } else {
      // Online mode - use existing API
      searchResults = await globalSearch(workspaceId, trimmedQuery, limit);
    }

    setResults(searchResults);

    // Add to recent searches if results found
    if (searchResults.totalCount > 0) {
      addRecentSearch(trimmedQuery);
      setRecentSearches(getRecentSearches());
    }
  } catch (err) {
    setError(err instanceof Error ? err.message : "Search failed");
    setResults(null);
  } finally {
    setIsLoading(false);
  }
}, [workspaceId, debouncedQuery, limit, minQueryLength, isOnline, forceOffline, offlineSearch]);
```

5. **Return offline status:**
```typescript
return {
  // ... existing fields ...
  isOffline: !isOnline || forceOffline,
  isOfflineReady: offlineSearch.isReady,
};
```

Ensure backward compatibility:
- Existing consumers don't need to change
- Online mode works exactly as before
- Offline mode is automatic based on network status
  </action>
  <verify>
Run `cd frontend && bunx tsc --noEmit` to verify TypeScript compiles.
Run `cd frontend && bun run lint` to verify no lint errors.
Verify existing global search UI still works by checking the component that uses useGlobalSearch.
  </verify>
  <done>useGlobalSearch enhanced with automatic online/offline mode switching</done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for offline search flow</name>
  <files>frontend/lib/hooks/__tests__/use-global-search.test.ts</files>
  <action>
Add or update tests for the enhanced useGlobalSearch hook.

Test cases:

1. **Online mode tests:**
   - Calls API when online (existing behavior preserved)
   - Returns results from API
   - Adds to recent searches

2. **Offline mode tests:**
   - Uses offline search when network is offline
   - Uses offline search when forceOffline is true
   - Returns results from IndexedDB/Fuse
   - Shows isOffline: true when offline

3. **Mode switching tests:**
   - Switches to offline search when going offline
   - Switches back to online search when connectivity returns
   - Handles transition gracefully (no errors)

4. **Recent searches tests (SRCH-04):**
   - Shows 5 most recent searches on focus
   - Recent searches persist across sessions (localStorage)

Use vitest and @testing-library/react-hooks (or renderHook from @testing-library/react):
```typescript
import { renderHook, act, waitFor } from "@testing-library/react";
import { vi, describe, it, expect, beforeEach } from "vitest";
import { useGlobalSearch } from "../use-global-search";
import * as networkStatus from "../use-network-status";
import * as searchApi from "@/lib/api/search";

vi.mock("../use-network-status");
vi.mock("@/lib/api/search");
vi.mock("../use-offline-search", () => ({
  useOfflineSearch: () => ({
    isReady: true,
    isBuilding: false,
    search: vi.fn().mockResolvedValue({
      query: "test",
      results: { items: [], borrowers: [], containers: [], locations: [] },
      totalCount: 0,
    }),
    rebuildIndices: vi.fn(),
    lastUpdated: Date.now(),
  }),
}));

describe("useGlobalSearch - offline mode", () => {
  it("uses offline search when network is offline", async () => {
    vi.mocked(networkStatus.useNetworkStatus).mockReturnValue({
      isOnline: false,
      isOffline: true,
      wasOffline: false,
    });

    const { result } = renderHook(() =>
      useGlobalSearch({ workspaceId: "ws-1" })
    );

    await act(async () => {
      result.current.setQuery("test");
    });

    await waitFor(() => {
      expect(result.current.isOffline).toBe(true);
    });
  });
});
```
  </action>
  <verify>
Run `cd frontend && bun run test -- lib/hooks/__tests__/use-global-search.test.ts` to verify tests pass.
  </verify>
  <done>Integration tests pass for online/offline mode switching and recent searches</done>
</task>

</tasks>

<verification>
1. Run `cd frontend && bunx tsc --noEmit` - should compile without errors
2. Run `cd frontend && bun run lint` - should pass
3. Run `cd frontend && bun run test -- lib/hooks` - all hook tests should pass
4. Manual verification:
   - Start dev server: `mise run fe-dev`
   - Open browser, navigate to dashboard
   - Use search while online - results from API
   - Enable airplane mode (or disconnect network)
   - Use search while offline - results from IndexedDB/Fuse
   - Verify fuzzy matching works (type with typos)
   - Verify recent searches appear on focus
</verification>

<success_criteria>
- useGlobalSearch automatically switches between online/offline mode
- Offline search uses Fuse.js against IndexedDB data
- Search results appear within 300ms (SRCH-01)
- Fuzzy matching finds items with typos (SRCH-02)
- Autocomplete shows 5-8 suggestions (SRCH-03)
- Recent searches shown on focus (SRCH-04)
- Search works in airplane mode (SRCH-06)
- All tests pass
- Existing search UI works without modification
</success_criteria>

<output>
After completion, create `.planning/phases/18-fuzzy-search-infrastructure/18-04-SUMMARY.md`
</output>
