---
phase: 18-fuzzy-search-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - frontend/lib/search/fuse-index.ts
autonomous: true

must_haves:
  truths:
    - "Fuse indices can be built from IndexedDB data for all searchable entities"
    - "Fuse instances are memoizable (factory functions return stable references)"
    - "Index builders handle empty data gracefully"
  artifacts:
    - path: "frontend/lib/search/fuse-index.ts"
      provides: "Fuse index builders per entity"
      exports: ["createItemsFuse", "createBorrowersFuse", "createContainersFuse", "createLocationsFuse", "createCategoriesFuse", "FuseSearchOptions"]
      min_lines: 100
  key_links:
    - from: "frontend/lib/search/fuse-index.ts"
      to: "fuse.js"
      via: "import Fuse"
      pattern: "import Fuse from"
    - from: "frontend/lib/search/fuse-index.ts"
      to: "frontend/lib/db/types.ts"
      via: "type imports"
      pattern: "import.*from.*@/lib/db/types"
---

<objective>
Create Fuse.js index builder functions for each searchable entity type.

Purpose: Provides optimized Fuse indices that can be built from IndexedDB data and memoized to avoid re-indexing on every render (addresses Pitfall 3-F from research).

Output: Reusable index builder functions for items, borrowers, containers, locations, and categories.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/phases/18-fuzzy-search-infrastructure/18-01-SUMMARY.md

Reference files:
@frontend/lib/db/types.ts
@frontend/lib/types/items.ts
@frontend/lib/types/borrowers.ts
@frontend/lib/types/containers.ts
@frontend/lib/types/locations.ts
@frontend/lib/api/categories.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Fuse index builder module</name>
  <files>frontend/lib/search/fuse-index.ts</files>
  <action>
Create `frontend/lib/search/fuse-index.ts` with Fuse index builders for each entity type.

Structure:
```typescript
import Fuse, { type IFuseOptions } from "fuse.js";
import type { Item } from "@/lib/types/items";
import type { Borrower } from "@/lib/types/borrowers";
import type { Container } from "@/lib/types/containers";
import type { Location } from "@/lib/types/locations";
import type { Category } from "@/lib/api/categories";

// Shared Fuse options optimized for inventory search
export const FuseSearchOptions: IFuseOptions<unknown> = {
  threshold: 0.4,           // Fuzzy match threshold (0 = exact, 1 = match anything)
  distance: 100,            // How far to search for matches
  includeScore: true,       // Include match score for ranking
  includeMatches: true,     // Include match indices for highlighting
  minMatchCharLength: 2,    // Minimum characters to start matching
  ignoreLocation: true,     // Search entire string, not just beginning
  useExtendedSearch: false, // Keep simple for performance
};
```

Create builder functions for each entity:

1. **createItemsFuse(items: Item[])** - Search fields: name, sku, brand, model, serial_number, short_code, manufacturer
2. **createBorrowersFuse(borrowers: Borrower[])** - Search fields: name, email, phone, notes
3. **createContainersFuse(containers: Container[])** - Search fields: name, short_code, description
4. **createLocationsFuse(locations: Location[])** - Search fields: name, short_code, zone, shelf, bin, description
5. **createCategoriesFuse(categories: Category[])** - Search fields: name, description

Each builder function:
- Takes an array of entities
- Returns a Fuse instance configured with appropriate search keys
- Handles empty arrays gracefully (returns Fuse with empty data)
- Uses weighted keys (name should have higher weight than description)

Example structure for items:
```typescript
export function createItemsFuse(items: Item[]): Fuse<Item> {
  return new Fuse(items, {
    ...FuseSearchOptions,
    keys: [
      { name: "name", weight: 2 },
      { name: "sku", weight: 1.5 },
      { name: "brand", weight: 1 },
      { name: "model", weight: 1 },
      { name: "serial_number", weight: 0.8 },
      { name: "short_code", weight: 1.5 },
      { name: "manufacturer", weight: 0.8 },
    ],
  });
}
```

Add JSDoc comments explaining:
- Purpose of each builder
- Weight rationale (name prioritized for quick finds)
- That these are meant to be memoized with useMemo in components
  </action>
  <verify>
Run `cd frontend && bunx tsc --noEmit` to verify TypeScript compiles.
Run `cd frontend && bun run lint` to verify no lint errors.
  </verify>
  <done>All five Fuse index builder functions created with typed inputs and weighted search keys</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for Fuse index builders</name>
  <files>frontend/lib/search/__tests__/fuse-index.test.ts</files>
  <action>
Create unit tests for the Fuse index builder functions.

Test cases for each builder:
1. Returns Fuse instance with empty array (no crash)
2. Returns Fuse instance with valid data
3. Fuzzy search finds items with typos (threshold working)
4. Search returns scored results in order
5. Primary field (name) has higher weight than secondary fields

Example test structure:
```typescript
import { describe, it, expect } from "vitest";
import { createItemsFuse, createBorrowersFuse } from "../fuse-index";
import type { Item } from "@/lib/types/items";

describe("createItemsFuse", () => {
  it("handles empty array", () => {
    const fuse = createItemsFuse([]);
    const results = fuse.search("test");
    expect(results).toEqual([]);
  });

  it("finds items by name with exact match", () => {
    const items: Item[] = [
      { id: "1", name: "Power Drill", sku: "PD001", ... },
      { id: "2", name: "Hammer", sku: "HM001", ... },
    ];
    const fuse = createItemsFuse(items);
    const results = fuse.search("Power Drill");
    expect(results[0].item.name).toBe("Power Drill");
  });

  it("finds items with fuzzy matching (typos)", () => {
    const items = [{ id: "1", name: "Power Drill", ... }];
    const fuse = createItemsFuse(items);
    const results = fuse.search("Powr Dril"); // typos
    expect(results.length).toBeGreaterThan(0);
    expect(results[0].item.name).toBe("Power Drill");
  });

  it("prioritizes name matches over SKU matches", () => {
    const items = [
      { id: "1", name: "Widget", sku: "DRILL001", ... },
      { id: "2", name: "Drill", sku: "WDG001", ... },
    ];
    const fuse = createItemsFuse(items);
    const results = fuse.search("Drill");
    expect(results[0].item.name).toBe("Drill"); // name match ranked higher
  });
});
```

Create similar test suites for borrowers, containers, locations, and categories.
  </action>
  <verify>
Run `cd frontend && bun run test -- lib/search/__tests__/fuse-index.test.ts` to verify tests pass.
  </verify>
  <done>All Fuse index builder tests pass, covering empty arrays, exact matches, fuzzy matches, and field weighting</done>
</task>

</tasks>

<verification>
1. Run `cd frontend && bunx tsc --noEmit` - should compile without errors
2. Run `cd frontend && bun run lint` - should pass
3. Run `cd frontend && bun run test -- lib/search` - Fuse index tests should pass
4. Verify exports are available: createItemsFuse, createBorrowersFuse, createContainersFuse, createLocationsFuse, createCategoriesFuse
</verification>

<success_criteria>
- Fuse index builders created for all 5 entity types
- Each builder handles empty arrays gracefully
- Fuzzy matching works (1-2 character typos find results)
- Field weighting prioritizes name over secondary fields
- Unit tests pass for all builders
</success_criteria>

<output>
After completion, create `.planning/phases/18-fuzzy-search-infrastructure/18-02-SUMMARY.md`
</output>
