---
phase: 18-fuzzy-search-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["18-02"]
files_modified:
  - frontend/lib/search/offline-search.ts
autonomous: true

must_haves:
  truths:
    - "Offline search queries IndexedDB and applies Fuse.js fuzzy matching"
    - "Search results include pending create mutations from the queue"
    - "Results are normalized to SearchResult format matching online search"
    - "Search responds within 300ms for datasets under 5000 items"
  artifacts:
    - path: "frontend/lib/search/offline-search.ts"
      provides: "Offline fuzzy search implementation"
      exports: ["offlineGlobalSearch", "buildSearchIndices", "SearchIndices"]
      min_lines: 150
  key_links:
    - from: "frontend/lib/search/offline-search.ts"
      to: "frontend/lib/db/offline-db.ts"
      via: "getAll import"
      pattern: "import.*getAll.*from.*offline-db"
    - from: "frontend/lib/search/offline-search.ts"
      to: "frontend/lib/search/fuse-index.ts"
      via: "Fuse builder imports"
      pattern: "import.*create.*Fuse.*from.*fuse-index"
    - from: "frontend/lib/search/offline-search.ts"
      to: "frontend/lib/sync/mutation-queue.ts"
      via: "pending mutations merge"
      pattern: "import.*getPendingMutations.*from.*mutation-queue"
---

<objective>
Create offline search module that queries IndexedDB with Fuse.js fuzzy matching and merges pending mutations.

Purpose: Enables search to work completely offline by querying local IndexedDB stores with fuzzy matching, while ensuring newly created items (pending in mutation queue) appear in search results (addresses Pitfall 3-I from research).

Output: Offline search function returning results compatible with the online GlobalSearchResponse format.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/phases/18-fuzzy-search-infrastructure/18-01-SUMMARY.md
@.planning/phases/18-fuzzy-search-infrastructure/18-02-SUMMARY.md

Reference files:
@frontend/lib/db/offline-db.ts
@frontend/lib/search/fuse-index.ts
@frontend/lib/api/search.ts (for SearchResult, GlobalSearchResponse types)
@frontend/lib/sync/mutation-queue.ts
@frontend/lib/db/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create offline search module</name>
  <files>frontend/lib/search/offline-search.ts</files>
  <action>
Create `frontend/lib/search/offline-search.ts` implementing offline fuzzy search.

Structure:
```typescript
import Fuse from "fuse.js";
import { getAll } from "@/lib/db/offline-db";
import { getPendingMutations } from "@/lib/sync/mutation-queue";
import {
  createItemsFuse,
  createBorrowersFuse,
  createContainersFuse,
  createLocationsFuse,
  createCategoriesFuse,
} from "./fuse-index";
import type {
  GlobalSearchResponse,
  SearchResult,
  SearchResultsByType,
} from "@/lib/api/search";
import type { Item } from "@/lib/types/items";
import type { Borrower } from "@/lib/types/borrowers";
import type { Container } from "@/lib/types/containers";
import type { Location } from "@/lib/types/locations";
import type { Category } from "@/lib/api/categories";
import type { MutationQueueEntry } from "@/lib/db/types";
```

Key components:

1. **SearchIndices type** - Holds memoized Fuse instances:
```typescript
export interface SearchIndices {
  items: Fuse<Item>;
  borrowers: Fuse<Borrower>;
  containers: Fuse<Container>;
  locations: Fuse<Location>;
  categories: Fuse<Category>;
  lastUpdated: number;
}
```

2. **buildSearchIndices()** - Loads all data from IndexedDB and builds Fuse indices:
```typescript
export async function buildSearchIndices(): Promise<SearchIndices> {
  const [items, borrowers, containers, locations, categories] = await Promise.all([
    getAll<Item>("items"),
    getAll<Borrower>("borrowers"),
    getAll<Container>("containers"),
    getAll<Location>("locations"),
    getAll<Category>("categories"),
  ]);

  return {
    items: createItemsFuse(items),
    borrowers: createBorrowersFuse(borrowers),
    containers: createContainersFuse(containers),
    locations: createLocationsFuse(locations),
    categories: createCategoriesFuse(categories),
    lastUpdated: Date.now(),
  };
}
```

3. **mergePendingCreates()** - Merges pending create mutations into search results:
   - Get pending mutations with status='pending' and operation='create'
   - Filter by entity type (items, borrowers, etc.)
   - Transform mutation payloads to entity format
   - Mark with isPending: true for UI indication
   - Avoid duplicates (entity might already be in IndexedDB after optimistic update)

4. **offlineGlobalSearch()** - Main search function:
```typescript
export async function offlineGlobalSearch(
  indices: SearchIndices,
  query: string,
  limit: number = 5
): Promise<GlobalSearchResponse> {
  // Search each Fuse index
  // Transform results to SearchResult format (matching online API)
  // Merge pending creates
  // Return GlobalSearchResponse
}
```

Transform functions (mirror online API search.ts):
- itemToSearchResult(item: Item, isPending?: boolean): SearchResult
- borrowerToSearchResult(borrower: Borrower, isPending?: boolean): SearchResult
- containerToSearchResult(container: Container, isPending?: boolean): SearchResult
- locationToSearchResult(location: Location, isPending?: boolean): SearchResult

Add isPending to metadata for pending items:
```typescript
metadata: {
  ...existingMetadata,
  isPending: isPending ? "true" : undefined,
}
```

5. **Hybrid query optimization** (for large datasets, addresses Pitfall 3-G):
   - If dataset > 1000 items, use Fuse's `search()` with limit
   - Results already scored by Fuse, take top N
   - Don't load all data into results array

Add JSDoc comments explaining:
- Purpose of the module (offline search capability)
- That indices should be memoized in components
- That pending creates are merged for offline-first UX
  </action>
  <verify>
Run `cd frontend && bunx tsc --noEmit` to verify TypeScript compiles.
Run `cd frontend && bun run lint` to verify no lint errors.
  </verify>
  <done>Offline search module created with IndexedDB querying, Fuse matching, and pending mutations merge</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for offline search</name>
  <files>frontend/lib/search/__tests__/offline-search.test.ts</files>
  <action>
Create unit tests for the offline search module.

Test cases:

1. **buildSearchIndices tests:**
   - Builds indices from IndexedDB data
   - Returns valid SearchIndices object with all Fuse instances
   - Handles empty IndexedDB gracefully

2. **offlineGlobalSearch tests:**
   - Returns empty results for empty query
   - Returns results matching query across entity types
   - Limits results per entity type
   - Fuzzy matching works (typos find items)
   - Results normalized to SearchResult format

3. **Pending mutations merge tests:**
   - Pending create mutations appear in search results
   - Pending items marked with isPending metadata
   - Duplicate prevention (same ID in IndexedDB and pending queue)

Use vitest mocking for IndexedDB and mutation queue:
```typescript
import { vi, describe, it, expect, beforeEach } from "vitest";
import * as offlineDb from "@/lib/db/offline-db";
import * as mutationQueue from "@/lib/sync/mutation-queue";

vi.mock("@/lib/db/offline-db");
vi.mock("@/lib/sync/mutation-queue");

describe("offlineGlobalSearch", () => {
  beforeEach(() => {
    vi.mocked(offlineDb.getAll).mockResolvedValue([]);
    vi.mocked(mutationQueue.getPendingMutations).mockResolvedValue([]);
  });

  it("returns normalized SearchResult format", async () => {
    vi.mocked(offlineDb.getAll).mockImplementation(async (store) => {
      if (store === "items") {
        return [{ id: "1", name: "Test Item", sku: "TST001", ... }];
      }
      return [];
    });

    const indices = await buildSearchIndices();
    const results = await offlineGlobalSearch(indices, "Test");

    expect(results.results.items[0]).toMatchObject({
      id: "1",
      type: "item",
      title: "Test Item",
      url: expect.stringContaining("/inventory"),
    });
  });
});
```
  </action>
  <verify>
Run `cd frontend && bun run test -- lib/search/__tests__/offline-search.test.ts` to verify tests pass.
  </verify>
  <done>All offline search tests pass, covering index building, fuzzy search, and pending mutations merge</done>
</task>

</tasks>

<verification>
1. Run `cd frontend && bunx tsc --noEmit` - should compile without errors
2. Run `cd frontend && bun run lint` - should pass
3. Run `cd frontend && bun run test -- lib/search` - all search tests should pass
4. Verify offlineGlobalSearch returns GlobalSearchResponse format
5. Verify pending create mutations appear in results
</verification>

<success_criteria>
- offlineGlobalSearch queries IndexedDB with Fuse.js fuzzy matching
- Results normalized to GlobalSearchResponse format (compatible with online search)
- Pending create mutations merged into search results (SRCH-06 offline requirement)
- Pending items marked with isPending metadata for UI indication
- Search completes within 300ms for typical datasets (SRCH-01)
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-fuzzy-search-infrastructure/18-03-SUMMARY.md`
</output>
