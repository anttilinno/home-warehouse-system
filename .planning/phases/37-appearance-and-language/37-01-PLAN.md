---
phase: 37-appearance-and-language
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/app/globals.css
  - frontend/components/settings/theme-settings.tsx
  - frontend/components/settings/language-settings.tsx
  - frontend/components/providers/theme-provider.tsx
  - frontend/app/[locale]/(dashboard)/dashboard/settings/appearance/page.tsx
  - frontend/app/[locale]/(dashboard)/dashboard/settings/language/page.tsx
  - frontend/messages/en.json
  - frontend/messages/et.json
  - frontend/messages/ru.json
autonomous: true

must_haves:
  truths:
    - "User sees a three-way theme selector (Light, Dark, System) on the Appearance subpage"
    - "Selecting a theme option changes the app theme instantly without page reload"
    - "Theme preference persists to backend so logging in on another device loads the same theme"
    - "Theme loads without a flash of the wrong theme on page load"
    - "CSS dark mode variant uses :where() so dark: utilities work on html and body elements"
    - "User sees a language selector with en, et, ru on the Language subpage"
    - "Selecting a language persists to backend and switches the app locale"
  artifacts:
    - path: "frontend/components/settings/theme-settings.tsx"
      provides: "ThemeSettings component with RadioGroup for light/dark/system"
      exports: ["ThemeSettings"]
    - path: "frontend/components/settings/language-settings.tsx"
      provides: "LanguageSettings component with RadioGroup for en/et/ru"
      exports: ["LanguageSettings"]
    - path: "frontend/app/[locale]/(dashboard)/dashboard/settings/appearance/page.tsx"
      provides: "Appearance subpage rendering ThemeSettings"
    - path: "frontend/app/[locale]/(dashboard)/dashboard/settings/language/page.tsx"
      provides: "Language subpage rendering LanguageSettings"
    - path: "frontend/app/globals.css"
      provides: "Corrected dark mode variant with :where() selector"
      contains: "@custom-variant dark (&:where(.dark, .dark *))"
  key_links:
    - from: "frontend/components/settings/theme-settings.tsx"
      to: "/users/me/preferences"
      via: "fetch PATCH with { theme: value }"
      pattern: "fetch.*users/me/preferences.*theme"
    - from: "frontend/components/settings/theme-settings.tsx"
      to: "next-themes"
      via: "setTheme() for instant visual change"
      pattern: "setTheme\\(value\\)"
    - from: "frontend/components/settings/language-settings.tsx"
      to: "/users/me/preferences"
      via: "fetch PATCH with { language: value }"
      pattern: "fetch.*users/me/preferences.*language"
    - from: "frontend/components/settings/language-settings.tsx"
      to: "next-intl router"
      via: "router.replace(pathname, { locale })"
      pattern: "router\\.replace.*locale"
    - from: "frontend/components/providers/theme-provider.tsx"
      to: "auth-context user.theme"
      via: "useEffect syncing backend theme to next-themes on login"
      pattern: "user\\.theme.*setTheme"
---

<objective>
Implement Appearance and Language settings subpages with backend-persisted preferences.

Purpose: Users can choose a visual theme (light/dark/system) and language (en/et/ru) that persist across devices. Replaces two stub subpages created in Phase 35 with functional implementations.

Output: Two new settings components (ThemeSettings, LanguageSettings), two updated subpages, CSS dark mode fix, theme sync on login, and i18n translations for all three locales.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-appearance-and-language/37-RESEARCH.md

Key existing files to reference:
@frontend/components/settings/time-format-settings.tsx (pattern to follow for both components)
@frontend/components/shared/theme-toggle.tsx (mounted pattern for hydration safety)
@frontend/components/shared/language-switcher.tsx (locale switching pattern)
@frontend/components/providers/theme-provider.tsx (add theme sync here)
@frontend/i18n/config.ts (locales, localeNames, localeFlags exports)
@frontend/i18n/navigation.ts (useRouter, usePathname exports)
@frontend/app/globals.css (line 4 needs CSS fix)
@frontend/app/[locale]/(dashboard)/dashboard/settings/appearance/page.tsx (stub to replace)
@frontend/app/[locale]/(dashboard)/dashboard/settings/language/page.tsx (stub to replace)
@frontend/messages/en.json (add appearance and language translation keys)
@frontend/messages/et.json (add appearance and language translation keys)
@frontend/messages/ru.json (add appearance and language translation keys)
</context>

<tasks>

<task type="auto">
  <name>Task 1: CSS fix, ThemeSettings component, appearance subpage, and theme sync</name>
  <files>
    frontend/app/globals.css
    frontend/components/settings/theme-settings.tsx
    frontend/components/providers/theme-provider.tsx
    frontend/app/[locale]/(dashboard)/dashboard/settings/appearance/page.tsx
    frontend/messages/en.json
    frontend/messages/et.json
    frontend/messages/ru.json
  </files>
  <action>
    **1. Fix CSS dark mode variant (globals.css line 4):**
    Change `@custom-variant dark (&:is(.dark *));` to `@custom-variant dark (&:where(.dark, .dark *));`
    This fixes two issues: `:where()` has zero specificity (matching Tailwind v4 expectations), and `.dark, .dark *` matches both the `.dark` element itself AND its descendants (the old selector only matched descendants via `*`).

    **2. Create ThemeSettings component (frontend/components/settings/theme-settings.tsx):**
    Follow the exact pattern of `time-format-settings.tsx`. Use the code example from 37-RESEARCH.md as the blueprint:
    - "use client" directive
    - Import `useState, useEffect` from react, `useTheme` from next-themes, `useTranslations` from next-intl
    - Import `Sun, Moon, Monitor` from lucide-react for option icons
    - Import Card/CardContent/CardDescription/CardHeader/CardTitle, Label, RadioGroup/RadioGroupItem from shadcn
    - Import `useAuth` from auth-context, `toast` from sonner
    - Define `THEME_OPTIONS` array: `[{ value: "light", icon: Sun }, { value: "dark", icon: Moon }, { value: "system", icon: Monitor }]`
    - Use `mounted` state with useEffect (same pattern as ThemeToggle) to prevent hydration mismatch -- return null until mounted
    - Get `currentTheme` from `user?.theme || "system"`
    - `handleChange(value)`: (1) call `setTheme(value)` for instant visual change, (2) PATCH `/users/me/preferences` with `{ theme: value }`, (3) `refreshUser()`, (4) toast success. On error: revert via `setTheme(currentTheme)` and toast error.
    - Render Card with RadioGroup. Each option: bordered row with RadioGroupItem, icon, and translated label. Use translation keys `settings.appearance.title`, `settings.appearance.description`, `settings.appearance.light`, `settings.appearance.dark`, `settings.appearance.system`, `settings.appearance.saved`, `settings.appearance.saveError`.

    **3. Add theme sync on login (frontend/components/providers/theme-provider.tsx):**
    Expand the existing ThemeProvider to sync the backend theme preference to next-themes when the user loads/logs in. Add:
    - Import `useAuth` from auth-context and `useTheme` from next-themes
    - Create an inner `ThemeSyncer` component (rendered inside NextThemesProvider) that:
      - Gets `{ user }` from `useAuth()` and `{ setTheme, theme }` from `useTheme()`
      - Has a `useEffect` that runs when `user?.theme` changes: if `user?.theme` exists and differs from current `theme`, call `setTheme(user.theme)`
      - Returns `{children}` (no extra DOM)
    - The existing ThemeProvider wraps `<NextThemesProvider>` around `<ThemeSyncer>{children}</ThemeSyncer>`
    This ensures that after login/getMe(), if the backend has a different theme than what next-themes picked from localStorage, it corrects it. The check prevents sync loops (only syncs when values differ, and only when user.theme changes).

    **4. Replace appearance stub (appearance/page.tsx):**
    Follow the exact subpage composition pattern from Phase 36:
    - "use client", import useTranslations, ArrowLeft, Link from @/i18n/navigation, ThemeSettings
    - Mobile back link (md:hidden), h2 heading with `t("nav.appearance")`, description with `t("hub.appearanceDesc")`, then `<ThemeSettings />`

    **5. Add i18n keys for appearance (all 3 locale files):**
    Add `settings.appearance` section to en.json, et.json, ru.json:

    en.json:
    ```json
    "appearance": {
      "title": "Appearance",
      "description": "Choose your preferred visual theme",
      "light": "Light",
      "dark": "Dark",
      "system": "System",
      "saved": "Theme updated",
      "saveError": "Failed to update theme"
    }
    ```

    et.json:
    ```json
    "appearance": {
      "title": "Välimus",
      "description": "Vali eelistatud visuaalne teema",
      "light": "Hele",
      "dark": "Tume",
      "system": "Süsteem",
      "saved": "Teema uuendatud",
      "saveError": "Teema uuendamine ebaõnnestus"
    }
    ```

    ru.json:
    ```json
    "appearance": {
      "title": "Внешний вид",
      "description": "Выберите предпочтительную тему оформления",
      "light": "Светлая",
      "dark": "Тёмная",
      "system": "Системная",
      "saved": "Тема обновлена",
      "saveError": "Не удалось обновить тему"
    }
    ```

    Place the `appearance` key inside the `settings` object, after the `hub` section (before `dataManagement`).
  </action>
  <verify>
    1. `grep -n "where(.dark" frontend/app/globals.css` shows the corrected variant on line 4
    2. `npx tsc --noEmit` passes with no errors from the new files
    3. `grep -r "ThemeSettings" frontend/components/settings/theme-settings.tsx` confirms export exists
    4. `grep "ThemeSyncer" frontend/components/providers/theme-provider.tsx` confirms sync component exists
    5. `grep "appearance" frontend/messages/en.json | head -5` shows the new keys
  </verify>
  <done>
    - CSS dark variant uses `:where(.dark, .dark *)` instead of `:is(.dark *)`
    - ThemeSettings component exists with 3-way RadioGroup (light/dark/system), instant setTheme, PATCH to backend, refreshUser, toast feedback, hydration-safe mounted check
    - ThemeProvider syncs backend theme to next-themes on user load (no loop)
    - Appearance subpage renders ThemeSettings with mobile back link and heading
    - All 3 locale files have settings.appearance translation keys
  </done>
</task>

<task type="auto">
  <name>Task 2: LanguageSettings component and language subpage</name>
  <files>
    frontend/components/settings/language-settings.tsx
    frontend/app/[locale]/(dashboard)/dashboard/settings/language/page.tsx
    frontend/messages/en.json
    frontend/messages/et.json
    frontend/messages/ru.json
  </files>
  <action>
    **1. Create LanguageSettings component (frontend/components/settings/language-settings.tsx):**
    Follow the exact pattern of `time-format-settings.tsx` combined with locale-switching logic from `language-switcher.tsx`. Use the code example from 37-RESEARCH.md as the blueprint:
    - "use client" directive
    - Import `useState` from react, `useTranslations, useLocale` from next-intl
    - Import `Globe` from lucide-react
    - Import `useRouter, usePathname` from `@/i18n/navigation`
    - Import `locales, localeNames, localeFlags, type Locale` from `@/i18n/config`
    - Import Card/CardContent/CardDescription/CardHeader/CardTitle, Label, RadioGroup/RadioGroupItem from shadcn
    - Import `useAuth` from auth-context, `toast` from sonner
    - `currentLanguage` = `(user?.language || locale) as Locale`
    - `handleChange(value)`: (1) PATCH `/users/me/preferences` with `{ language: value }`, (2) `refreshUser()`, (3) `router.replace(pathname, { locale: value as Locale })`. On error: toast error and setIsUpdating(false). Do NOT toast success -- the language actually changing IS the user feedback (toast would be lost during navigation re-render anyway, per research pitfall 4).
    - Note: `setIsUpdating(false)` is NOT needed in the success path because `router.replace` triggers a full re-render.
    - Render Card with Globe icon in title. RadioGroup with each locale as an option. Each option row shows: RadioGroupItem, flag emoji from `localeFlags[loc]`, locale display name from `localeNames[loc]`.
    - Translation keys: `settings.language.title`, `settings.language.description`, `settings.language.saveError`.

    **2. Replace language stub (language/page.tsx):**
    Follow the exact subpage composition pattern from Phase 36:
    - "use client", import useTranslations, ArrowLeft, Link from @/i18n/navigation, LanguageSettings
    - Mobile back link (md:hidden), h2 heading with `t("nav.language")`, description with `t("hub.languageDesc")`, then `<LanguageSettings />`

    **3. Add i18n keys for language settings (all 3 locale files):**
    Add `settings.language` section to en.json, et.json, ru.json (place after `appearance`, before `dataManagement`):

    en.json:
    ```json
    "language": {
      "title": "Language",
      "description": "Choose your preferred app language",
      "saveError": "Failed to update language"
    }
    ```

    et.json:
    ```json
    "language": {
      "title": "Keel",
      "description": "Vali eelistatud rakenduse keel",
      "saveError": "Keele uuendamine ebaõnnestus"
    }
    ```

    ru.json:
    ```json
    "language": {
      "title": "Язык",
      "description": "Выберите предпочтительный язык приложения",
      "saveError": "Не удалось обновить язык"
    }
    ```

    Note: No "saved" key needed -- language change feedback is the language itself changing.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes with no errors
    2. `grep -r "LanguageSettings" frontend/components/settings/language-settings.tsx` confirms export exists
    3. `grep "LanguageSettings" frontend/app/*/\(dashboard\)/dashboard/settings/language/page.tsx` confirms wiring
    4. `grep '"language"' frontend/messages/en.json | head -5` shows the new translation keys
    5. `cd frontend && bun run build` succeeds (full build verification)
  </verify>
  <done>
    - LanguageSettings component exists with RadioGroup for 3 locales (en/et/ru), flags, display names, PATCH to backend, refreshUser, router.replace for locale switch
    - Language subpage renders LanguageSettings with mobile back link and heading
    - All 3 locale files have settings.language translation keys
    - No success toast on language change (the language changing is the feedback)
    - Frontend builds successfully
  </done>
</task>

</tasks>

<verification>
Phase-level verification after both tasks:

1. **CSS fix (APPR-05):** `globals.css` line 4 contains `@custom-variant dark (&:where(.dark, .dark *));`
2. **Theme selector (APPR-01):** ThemeSettings renders 3 radio options (Light, Dark, System) with icons
3. **Instant theme change (APPR-02):** `setTheme(value)` called before API call in handleChange
4. **Theme persistence (APPR-03):** PATCH to `/users/me/preferences` with `{ theme: value }` followed by `refreshUser()`
5. **No flash (APPR-04):** next-themes ThemeProvider already handles this; ThemeSyncer corrects mismatches after login
6. **Language selector (LANG-01):** LanguageSettings renders 3 radio options with flags and display names
7. **Language persistence (LANG-02):** PATCH to `/users/me/preferences` with `{ language: value }` followed by `refreshUser()` and `router.replace`
8. **Build passes:** `cd frontend && bun run build` exits 0
9. **Type check passes:** `npx tsc --noEmit` exits 0
</verification>

<success_criteria>
- Appearance subpage shows three-way theme selector that changes theme instantly and persists to backend
- Language subpage shows three-language selector that persists to backend and switches app locale
- CSS dark mode variant fixed with :where() for correct specificity
- Theme syncs from backend to client on login (ThemeSyncer in ThemeProvider)
- All text translated in en, et, ru
- Frontend builds and type-checks successfully
</success_criteria>

<output>
After completion, create `.planning/phases/37-appearance-and-language/37-01-SUMMARY.md`
</output>
