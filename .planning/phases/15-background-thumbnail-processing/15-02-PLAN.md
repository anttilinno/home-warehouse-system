---
phase: 15-background-thumbnail-processing
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - backend/internal/jobs/tasks.go
  - backend/internal/jobs/thumbnail_processor.go
  - backend/internal/jobs/scheduler.go
  - backend/internal/domain/warehouse/itemphoto/service.go
  - backend/internal/domain/warehouse/itemphoto/repository.go
autonomous: true

must_haves:
  truths:
    - "Photo upload returns immediately without generating thumbnails"
    - "Background job generates thumbnails in small/medium/large sizes"
    - "Failed thumbnail jobs retry with exponential backoff up to 5 times"
    - "SSE event emitted when thumbnails are ready or failed"
  artifacts:
    - path: "backend/internal/jobs/thumbnail_processor.go"
      provides: "Asynq task handler for thumbnail generation"
      exports: ["ThumbnailProcessor", "NewThumbnailGenerationTask"]
    - path: "backend/internal/jobs/tasks.go"
      provides: "TypeThumbnailGeneration task constant"
      contains: "TypeThumbnailGeneration"
    - path: "backend/internal/domain/warehouse/itemphoto/service.go"
      provides: "Async upload flow that queues thumbnail job"
      contains: "Enqueue"
  key_links:
    - from: "backend/internal/domain/warehouse/itemphoto/service.go"
      to: "backend/internal/jobs/thumbnail_processor.go"
      via: "asynq task enqueue"
      pattern: "NewThumbnailGenerationTask"
    - from: "backend/internal/jobs/thumbnail_processor.go"
      to: "backend/internal/infra/imageprocessor/processor.go"
      via: "GenerateAllThumbnails call"
      pattern: "GenerateAllThumbnails"
    - from: "backend/internal/jobs/thumbnail_processor.go"
      to: "backend/internal/infra/events/broadcaster.go"
      via: "SSE event publish"
      pattern: "broadcaster.*Publish"
---

<objective>
Implement async thumbnail generation with background job processing and SSE notifications.

Purpose: Make photo uploads non-blocking by moving thumbnail generation to a background job queue with retry support and real-time status updates via SSE.

Output: Thumbnail processor job, updated service for async flow, SSE event publishing for status updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-background-thumbnail-processing/15-RESEARCH.md
@.planning/phases/15-background-thumbnail-processing/15-01-SUMMARY.md

@backend/internal/jobs/tasks.go
@backend/internal/jobs/scheduler.go
@backend/internal/jobs/repair_reminders.go
@backend/internal/domain/warehouse/itemphoto/service.go
@backend/internal/infra/imageprocessor/processor.go
@backend/internal/infra/events/broadcaster.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create thumbnail processor job handler</name>
  <files>backend/internal/jobs/tasks.go, backend/internal/jobs/thumbnail_processor.go</files>
  <action>
1. In `tasks.go`, add task type constant:
   ```go
   // TypeThumbnailGeneration is the task type for generating photo thumbnails
   TypeThumbnailGeneration = "photo:generate_thumbnails"
   ```

2. Create `thumbnail_processor.go` following the repair_reminders.go pattern:

   ```go
   package jobs

   import (
       "context"
       "encoding/json"
       "fmt"
       "io"
       "log"
       "os"
       "path/filepath"
       "time"

       "github.com/google/uuid"
       "github.com/hibiken/asynq"
       "github.com/jackc/pgx/v5/pgxpool"

       "github.com/antti/home-warehouse/go-backend/internal/infra/events"
       "github.com/antti/home-warehouse/go-backend/internal/infra/imageprocessor"
       "github.com/antti/home-warehouse/go-backend/internal/infra/queries"
       "github.com/antti/home-warehouse/go-backend/internal/infra/storage"
   )

   // ThumbnailPayload contains data for thumbnail generation task
   type ThumbnailPayload struct {
       PhotoID     uuid.UUID `json:"photo_id"`
       WorkspaceID uuid.UUID `json:"workspace_id"`
       ItemID      uuid.UUID `json:"item_id"`
       StoragePath string    `json:"storage_path"`
   }

   // NewThumbnailGenerationTask creates a new thumbnail generation task
   func NewThumbnailGenerationTask(photoID, workspaceID, itemID uuid.UUID, storagePath string) *asynq.Task {
       payload, _ := json.Marshal(ThumbnailPayload{
           PhotoID:     photoID,
           WorkspaceID: workspaceID,
           ItemID:      itemID,
           StoragePath: storagePath,
       })
       return asynq.NewTask(TypeThumbnailGeneration, payload,
           asynq.MaxRetry(5),
           asynq.Timeout(5*time.Minute),
           asynq.Queue(QueueDefault),
       )
   }

   // ThumbnailProcessor handles thumbnail generation tasks
   type ThumbnailProcessor struct {
       pool        *pgxpool.Pool
       processor   imageprocessor.ImageProcessor
       storage     storage.Storage
       broadcaster *events.Broadcaster
       uploadDir   string
   }

   // NewThumbnailProcessor creates a new thumbnail processor
   func NewThumbnailProcessor(
       pool *pgxpool.Pool,
       processor imageprocessor.ImageProcessor,
       storage storage.Storage,
       broadcaster *events.Broadcaster,
       uploadDir string,
   ) *ThumbnailProcessor {
       return &ThumbnailProcessor{
           pool:        pool,
           processor:   processor,
           storage:     storage,
           broadcaster: broadcaster,
           uploadDir:   uploadDir,
       }
   }

   // ProcessTask handles the thumbnail generation task
   func (p *ThumbnailProcessor) ProcessTask(ctx context.Context, t *asynq.Task) error {
       var payload ThumbnailPayload
       if err := json.Unmarshal(t.Payload(), &payload); err != nil {
           return fmt.Errorf("unmarshal payload: %w", err)
       }

       log.Printf("Processing thumbnails for photo %s", payload.PhotoID)

       q := queries.New(p.pool)

       // Update status to processing
       if err := q.UpdateThumbnailStatus(ctx, queries.UpdateThumbnailStatusParams{
           ID:             payload.PhotoID,
           ThumbnailStatus: "processing",
       }); err != nil {
           return fmt.Errorf("update status to processing: %w", err)
       }

       // Download original file to temp location
       tempPath := filepath.Join(p.uploadDir, fmt.Sprintf("thumb-src-%s", payload.PhotoID))
       defer os.Remove(tempPath)

       reader, err := p.storage.Get(ctx, payload.StoragePath)
       if err != nil {
           p.handleFailure(ctx, q, payload, fmt.Errorf("get original: %w", err))
           return err
       }
       defer reader.Close()

       tempFile, err := os.Create(tempPath)
       if err != nil {
           p.handleFailure(ctx, q, payload, fmt.Errorf("create temp: %w", err))
           return err
       }
       if _, err := io.Copy(tempFile, reader); err != nil {
           tempFile.Close()
           p.handleFailure(ctx, q, payload, fmt.Errorf("copy to temp: %w", err))
           return err
       }
       tempFile.Close()

       // Generate thumbnails in all sizes
       baseDest := filepath.Join(p.uploadDir, fmt.Sprintf("thumb-%s.webp", payload.PhotoID))
       thumbnails, err := p.processor.GenerateAllThumbnails(ctx, tempPath, baseDest)
       if err != nil {
           p.handleFailure(ctx, q, payload, fmt.Errorf("generate thumbnails: %w", err))
           return err
       }

       // Upload thumbnails to storage
       paths := make(map[imageprocessor.ThumbnailSize]string)
       for size, localPath := range thumbnails {
           defer os.Remove(localPath)

           thumbFile, err := os.Open(localPath)
           if err != nil {
               p.handleFailure(ctx, q, payload, fmt.Errorf("open %s thumbnail: %w", size, err))
               return err
           }

           storagePath, err := p.storage.Save(ctx,
               payload.WorkspaceID.String(),
               payload.ItemID.String(),
               fmt.Sprintf("thumb_%s_%s.webp", size, payload.PhotoID),
               thumbFile,
           )
           thumbFile.Close()
           if err != nil {
               p.handleFailure(ctx, q, payload, fmt.Errorf("save %s thumbnail: %w", size, err))
               return err
           }
           paths[size] = storagePath
       }

       // Update database with thumbnail paths
       var smallPath, mediumPath, largePath *string
       if p, ok := paths[imageprocessor.ThumbnailSizeSmall]; ok {
           smallPath = &p
       }
       if p, ok := paths[imageprocessor.ThumbnailSizeMedium]; ok {
           mediumPath = &p
       }
       if p, ok := paths[imageprocessor.ThumbnailSizeLarge]; ok {
           largePath = &p
       }

       _, err = q.UpdateThumbnailPaths(ctx, queries.UpdateThumbnailPathsParams{
           ID:                  payload.PhotoID,
           ThumbnailSmallPath:  smallPath,
           ThumbnailMediumPath: mediumPath,
           ThumbnailLargePath:  largePath,
       })
       if err != nil {
           p.handleFailure(ctx, q, payload, fmt.Errorf("update paths: %w", err))
           return err
       }

       // Emit SSE event
       p.broadcaster.Publish(payload.WorkspaceID, events.Event{
           Type:       "photo.thumbnail_ready",
           EntityID:   payload.PhotoID.String(),
           EntityType: "item_photo",
           Data: map[string]interface{}{
               "photo_id":             payload.PhotoID.String(),
               "item_id":              payload.ItemID.String(),
               "small_thumbnail_url":  smallPath,
               "medium_thumbnail_url": mediumPath,
               "large_thumbnail_url":  largePath,
           },
       })

       log.Printf("Thumbnails ready for photo %s", payload.PhotoID)
       return nil
   }

   func (p *ThumbnailProcessor) handleFailure(ctx context.Context, q *queries.Queries, payload ThumbnailPayload, err error) {
       errMsg := err.Error()
       q.UpdateThumbnailStatus(ctx, queries.UpdateThumbnailStatusParams{
           ID:              payload.PhotoID,
           ThumbnailStatus: "failed",
           ThumbnailError:  &errMsg,
       })

       p.broadcaster.Publish(payload.WorkspaceID, events.Event{
           Type:       "photo.thumbnail_failed",
           EntityID:   payload.PhotoID.String(),
           EntityType: "item_photo",
           Data: map[string]interface{}{
               "photo_id": payload.PhotoID.String(),
               "item_id":  payload.ItemID.String(),
               "error":    errMsg,
           },
       })
   }
   ```

Note: Adapt type mappings based on actual sqlc generated types.
  </action>
  <verify>
Run `go build ./internal/jobs/...` - compiles without errors
  </verify>
  <done>
ThumbnailProcessor job handler exists with ProcessTask that generates all sizes, uploads to storage, updates DB, and emits SSE events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register thumbnail processor in scheduler</name>
  <files>backend/internal/jobs/scheduler.go</files>
  <action>
1. Update `RegisterHandlers` signature to accept additional dependencies:
   ```go
   func (s *Scheduler) RegisterHandlers(
       emailSender EmailSender,
       pushSender *webpush.Sender,
       cleanupConfig CleanupConfig,
       imgProcessor imageprocessor.ImageProcessor,
       fileStorage storage.Storage,
       broadcaster *events.Broadcaster,
       uploadDir string,
   ) *asynq.ServeMux
   ```

2. Add thumbnail processor registration in RegisterHandlers:
   ```go
   // Thumbnail processor
   thumbnailProcessor := NewThumbnailProcessor(s.pool, imgProcessor, fileStorage, broadcaster, uploadDir)
   mux.HandleFunc(TypeThumbnailGeneration, thumbnailProcessor.ProcessTask)
   ```

3. Add required imports for imageprocessor, storage, events packages.

4. Update `cmd/worker/main.go` to pass the new dependencies:
   - Import imageprocessor, storage, events packages
   - Create imageprocessor instance (or get from existing setup)
   - Create storage instance (or get from existing setup)
   - Get broadcaster instance (or get from existing setup)
   - Pass to RegisterHandlers
  </action>
  <verify>
Run `go build ./internal/jobs/...` - compiles without errors
Run `go build ./cmd/worker/...` - compiles without errors (confirms main.go updated correctly)
  </verify>
  <done>
Scheduler registers ThumbnailProcessor for TypeThumbnailGeneration task type.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update itemphoto service for async thumbnail generation</name>
  <files>backend/internal/domain/warehouse/itemphoto/service.go, backend/internal/domain/warehouse/itemphoto/repository.go</files>
  <action>
1. Add asynq client to Service struct:
   ```go
   type Service struct {
       repo        Repository
       storage     Storage
       processor   ImageProcessor
       asynqClient *asynq.Client  // NEW
       uploadDir   string
   }
   ```

2. Update NewService to accept asynq client:
   ```go
   func NewService(repo Repository, storage Storage, processor ImageProcessor, asynqClient *asynq.Client, uploadDir string) *Service
   ```

3. Refactor UploadPhoto to be non-blocking:
   - Remove synchronous thumbnail generation (lines ~125-148)
   - Set ThumbnailStatus to "pending" in new photo record
   - Leave ThumbnailPath empty (for legacy compat, set to empty string)
   - After successful DB insert, enqueue thumbnail job:
     ```go
     // Enqueue thumbnail generation job
     if s.asynqClient != nil {
         task := jobs.NewThumbnailGenerationTask(
             createdPhoto.ID,
             workspaceID,
             itemID,
             storagePath,
         )
         if _, err := s.asynqClient.Enqueue(task); err != nil {
             log.Printf("Failed to enqueue thumbnail job for photo %s: %v", createdPhoto.ID, err)
             // Don't fail upload - photo is usable, thumbnails will be missing
         }
     }
     ```
   - Return immediately after enqueue

4. Update Validate() in entity.go to NOT require ThumbnailPath when ThumbnailStatus is pending/processing.

5. Update repository interface if needed to support ThumbnailStatus in Create.

6. Add import for jobs package (for NewThumbnailGenerationTask).

7. Update any callers of NewService (handlers, tests) to pass asynq client.
  </action>
  <verify>
Run `go build ./...` from backend directory - compiles
Run `mise run test` - tests pass (may need updates for new Service signature)
  </verify>
  <done>
Photo upload saves original, creates DB record with status=pending, enqueues thumbnail job, returns immediately without waiting for thumbnails.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `cd backend && go build ./...`
2. Worker builds: `go build ./cmd/worker/...`
3. Tests pass: `mise run test`
4. Manual test:
   - Start worker: `mise run worker`
   - Upload a photo via API
   - Observe in logs: "Processing thumbnails for photo..."
   - Check DB: thumbnail_status changes from pending -> processing -> complete
</verification>

<success_criteria>
- TypeThumbnailGeneration task type defined
- ThumbnailProcessor job generates small/medium/large thumbnails using imageprocessor
- Processor uploads thumbnails to storage, updates DB paths, emits SSE event
- Failed jobs update status to "failed" with error message
- itemphoto service enqueues job on upload instead of blocking
- Upload returns immediately with photo record (status=pending)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-background-thumbnail-processing/15-02-SUMMARY.md`
</output>
