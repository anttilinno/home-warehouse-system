---
phase: 26-e2e-stability-and-coverage
plan: 03
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - frontend/e2e/pages/InventoryPage.ts
  - frontend/e2e/dashboard/inventory.spec.ts
autonomous: true

must_haves:
  truths:
    - "User can navigate to inventory page and see items table or empty state"
    - "User can open the Add Inventory dialog"
    - "User can search and filter inventory"
    - "User can export inventory to CSV"
  artifacts:
    - path: "frontend/e2e/pages/InventoryPage.ts"
      provides: "Page Object for inventory page interactions"
      min_lines: 150
    - path: "frontend/e2e/dashboard/inventory.spec.ts"
      provides: "E2E tests for inventory page"
      min_lines: 150
  key_links:
    - from: "frontend/e2e/dashboard/inventory.spec.ts"
      to: "frontend/e2e/pages/InventoryPage.ts"
      via: "Page Object import and usage"
      pattern: "new InventoryPage"
---

<objective>
Add comprehensive E2E tests for the inventory page, which currently has no test coverage despite being a 1675-line feature-rich page.

Purpose: The inventory page is a critical user flow for tracking physical items at locations. It has full CRUD capabilities, inline editing, filtering, and bulk operations but zero E2E tests.

Output: InventoryPage Page Object and inventory.spec.ts test suite covering UI interactions.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-e2e-stability-and-coverage/26-RESEARCH.md

@frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx
@frontend/e2e/pages/ItemsPage.ts
@frontend/e2e/dashboard/items.spec.ts
@frontend/e2e/fixtures/authenticated.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InventoryPage Page Object</name>
  <files>frontend/e2e/pages/InventoryPage.ts</files>
  <action>
Create a comprehensive Page Object for the inventory page following the ItemsPage pattern:

```typescript
import type { Locator, Page } from "@playwright/test";
import { BasePage } from "./BasePage";
import { DashboardShell } from "./DashboardShell";

export class InventoryPage extends BasePage {
  readonly shell: DashboardShell;

  // Page header
  readonly pageTitle: Locator;
  readonly pageSubtitle: Locator;

  // Search and filter controls
  readonly searchInput: Locator;
  readonly filterButton: Locator;
  readonly filterPopover: Locator;
  readonly importButton: Locator;
  readonly exportButton: Locator;
  readonly archiveToggle: Locator;

  // Card container
  readonly inventoryCard: Locator;
  readonly cardTitle: Locator;
  readonly cardDescription: Locator;

  // Add inventory button
  readonly addInventoryButton: Locator;

  // Table elements
  readonly inventoryTable: Locator;
  readonly tableHeader: Locator;
  readonly tableBody: Locator;

  // Empty state
  readonly emptyState: Locator;

  // Bulk action bar
  readonly bulkActionBar: Locator;

  // Create dialog
  readonly createDialog: Locator;
  readonly dialogItemSelect: Locator;
  readonly dialogLocationSelect: Locator;
  readonly dialogContainerSelect: Locator;
  readonly dialogQuantityInput: Locator;
  readonly dialogConditionSelect: Locator;
  readonly dialogStatusSelect: Locator;
  readonly dialogNotesInput: Locator;
  readonly dialogCancelButton: Locator;
  readonly dialogSubmitButton: Locator;

  // Export dialog
  readonly exportDialog: Locator;

  // Import dialog
  readonly importDialog: Locator;

  constructor(page: Page, locale = "en") {
    super(page, locale);
    this.shell = new DashboardShell(page, locale);

    // Page header - match the actual page structure
    this.pageTitle = page.getByRole("heading", { level: 1, name: "Inventory" });
    this.pageSubtitle = page.locator("p.text-muted-foreground").first();

    // Card
    this.inventoryCard = page.locator('[class*="card"]').filter({ hasText: "Inventory Tracking" });
    this.cardTitle = this.inventoryCard.locator('[class*="card-title"]');
    this.cardDescription = this.inventoryCard.locator('[class*="card-description"]');

    // Add inventory button
    this.addInventoryButton = page.getByRole("button", { name: /add inventory/i });

    // Search and filters
    this.searchInput = page.getByPlaceholder(/search by item, sku, or location/i);
    this.filterButton = page.locator("button").filter({ has: page.locator('[class*="lucide-filter"]') });
    this.filterPopover = page.locator("[data-radix-popper-content-wrapper]");
    this.importButton = page.getByRole("button", { name: /import/i });
    this.exportButton = page.getByRole("button", { name: /export/i });
    this.archiveToggle = page.getByRole("button", { name: /archived|active/i });

    // Table - note: uses "Inventory items" as aria-label
    this.inventoryTable = page.locator('table[aria-label="Inventory items"]');
    this.tableHeader = this.inventoryTable.locator("thead");
    this.tableBody = page.locator("table tbody");

    // Empty state
    this.emptyState = page.locator('[class*="flex flex-col items-center"]').filter({ hasText: /no inventory/i });

    // Bulk action bar
    this.bulkActionBar = page.locator('[class*="fixed"]').filter({ hasText: /selected/i });

    // Create dialog
    this.createDialog = page.locator('[role="dialog"]').filter({ hasText: /add inventory/i });
    this.dialogItemSelect = this.createDialog.locator('#item').locator('..').locator('button[role="combobox"]');
    this.dialogLocationSelect = this.createDialog.locator('#location').locator('..').locator('button[role="combobox"]');
    this.dialogContainerSelect = this.createDialog.locator('button[role="combobox"]').nth(2);
    this.dialogQuantityInput = this.createDialog.locator('input[id="quantity"]');
    this.dialogConditionSelect = this.createDialog.locator('button[role="combobox"]').filter({ hasText: /good|new|excellent/i });
    this.dialogStatusSelect = this.createDialog.locator('button[role="combobox"]').filter({ hasText: /available|in use/i });
    this.dialogNotesInput = this.createDialog.locator('textarea[id="notes"]');
    this.dialogCancelButton = this.createDialog.getByRole("button", { name: /cancel/i });
    this.dialogSubmitButton = this.createDialog.getByRole("button", { name: /create/i });

    // Export dialog
    this.exportDialog = page.locator('[role="dialog"]').filter({ hasText: /export inventory/i });

    // Import dialog
    this.importDialog = page.locator('[role="dialog"]').filter({ hasText: /import inventory/i });
  }

  async goto(): Promise<void> {
    await super.goto("/dashboard/inventory");
  }

  async waitForPageLoaded(): Promise<void> {
    // Wait for skeleton to disappear
    await this.page.locator('[class*="skeleton"]').first().waitFor({ state: "hidden", timeout: 10000 }).catch(() => {});
    // Wait for page title
    await this.pageTitle.waitFor({ state: "visible" });
  }

  async openCreateDialog(): Promise<void> {
    await this.addInventoryButton.click();
    await this.createDialog.waitFor({ state: "visible" });
  }

  async closeDialog(): Promise<void> {
    await this.dialogCancelButton.click();
    await this.createDialog.waitFor({ state: "hidden" });
  }

  async search(query: string): Promise<void> {
    await this.searchInput.fill(query);
    // Wait for debounced search to apply
    await this.page.waitForLoadState("domcontentloaded");
  }

  async clearSearch(): Promise<void> {
    await this.searchInput.clear();
    await this.page.waitForLoadState("domcontentloaded");
  }

  getAllInventoryRows(): Locator {
    return this.tableBody.locator("tr");
  }

  async hasEmptyState(): Promise<boolean> {
    return this.emptyState.isVisible();
  }

  async getInventoryCount(): Promise<string | null> {
    return this.cardDescription.textContent();
  }

  tableHeaderColumn(name: string): Locator {
    return this.tableHeader.getByRole("columnheader").filter({ hasText: name });
  }
}
```
  </action>
  <verify>
```bash
cd frontend && npx tsc --noEmit e2e/pages/InventoryPage.ts
```
Should compile without TypeScript errors.
  </verify>
  <done>InventoryPage.ts Page Object created with all major locators and helper methods.</done>
</task>

<task type="auto">
  <name>Task 2: Create inventory.spec.ts test suite</name>
  <files>frontend/e2e/dashboard/inventory.spec.ts</files>
  <action>
Create comprehensive E2E tests for the inventory page:

```typescript
import { test, expect } from "../fixtures/authenticated";
import { InventoryPage } from "../pages/InventoryPage";

test.describe("Inventory Page", () => {
  let inventoryPage: InventoryPage;

  test.beforeEach(async ({ page }) => {
    inventoryPage = new InventoryPage(page);
    await inventoryPage.goto();
    await inventoryPage.waitForPageLoaded();
  });

  test("page loads with inventory table or empty state", async ({ page }) => {
    // Page title should be visible
    await expect(inventoryPage.pageTitle).toBeVisible();

    // Either the table or empty state should be present
    const hasTable = await inventoryPage.inventoryTable.isVisible().catch(() => false);
    const hasEmpty = await inventoryPage.hasEmptyState();

    expect(hasTable || hasEmpty).toBe(true);
  });

  test("page title and subtitle are displayed", async ({ page }) => {
    await expect(inventoryPage.pageTitle).toHaveText("Inventory");
    await expect(inventoryPage.pageSubtitle).toContainText("Track physical instances");
  });

  test("Add Inventory button opens create dialog", async ({ page }) => {
    await inventoryPage.openCreateDialog();

    await expect(inventoryPage.createDialog).toBeVisible();
    // Dialog should have Add Inventory title
    const dialogTitle = inventoryPage.createDialog.locator('[class*="dialog-title"]');
    await expect(dialogTitle).toContainText(/add inventory/i);
  });

  test("create dialog has required fields", async ({ page }) => {
    await inventoryPage.openCreateDialog();

    // Item and Location selects should be visible
    await expect(inventoryPage.dialogQuantityInput).toBeVisible();
    await expect(inventoryPage.dialogNotesInput).toBeVisible();

    // Check for required field indicators
    const itemLabel = inventoryPage.createDialog.locator('label').filter({ hasText: "Item" });
    const locationLabel = inventoryPage.createDialog.locator('label').filter({ hasText: "Location" });
    await expect(itemLabel).toContainText("*");
    await expect(locationLabel).toContainText("*");
  });

  test("create dialog closes on cancel", async ({ page }) => {
    await inventoryPage.openCreateDialog();
    await expect(inventoryPage.createDialog).toBeVisible();

    await inventoryPage.closeDialog();
    await expect(inventoryPage.createDialog).toBeHidden();
  });

  test("search input is present and functional", async ({ page }) => {
    await expect(inventoryPage.searchInput).toBeVisible();
    await expect(inventoryPage.searchInput).toHaveAttribute("placeholder", /search/i);

    // Type in search
    await inventoryPage.search("test query");
    await expect(inventoryPage.searchInput).toHaveValue("test query");
  });

  test("filter button opens filter popover", async ({ page }) => {
    const filterBtn = inventoryPage.filterButton;

    if (await filterBtn.isVisible()) {
      await filterBtn.click();
      await expect(inventoryPage.filterPopover).toBeVisible();
    }
  });

  test("archive toggle changes view", async ({ page }) => {
    const archiveButton = inventoryPage.archiveToggle;
    await expect(archiveButton).toBeVisible();

    // Check initial state
    const initialText = await archiveButton.textContent();
    expect(initialText).toMatch(/active|archived/i);

    // Click to toggle
    await archiveButton.click();

    // Text should change
    const newText = await archiveButton.textContent();
    expect(newText).not.toBe(initialText);
  });

  test("import button opens import dialog", async ({ page }) => {
    await inventoryPage.importButton.click();
    await expect(inventoryPage.importDialog).toBeVisible();
  });

  test("export button is present and disabled when empty", async ({ page }) => {
    await expect(inventoryPage.exportButton).toBeVisible();

    // If empty state is shown, export should be disabled
    const hasEmpty = await inventoryPage.hasEmptyState();
    if (hasEmpty) {
      await expect(inventoryPage.exportButton).toBeDisabled();
    }
  });

  test("card shows inventory count in description", async ({ page }) => {
    const countText = await inventoryPage.getInventoryCount();
    // Should contain "inventor" (singular or plural) - matches "inventory" or "inventories"
    expect(countText).toMatch(/inventor/i);
  });
});

test.describe("Inventory Table Interactions", () => {
  let inventoryPage: InventoryPage;

  test.beforeEach(async ({ page }) => {
    inventoryPage = new InventoryPage(page);
    await inventoryPage.goto();
    await inventoryPage.waitForPageLoaded();
  });

  test("table headers are visible when inventory exists", async ({ page }) => {
    const hasTable = await inventoryPage.inventoryTable.isVisible().catch(() => false);

    if (hasTable) {
      // Check for sortable headers
      const itemHeader = inventoryPage.tableHeaderColumn("Item");
      const locationHeader = inventoryPage.tableHeaderColumn("Location");
      const qtyHeader = inventoryPage.tableHeaderColumn("Qty");
      const conditionHeader = inventoryPage.tableHeaderColumn("Condition");
      const statusHeader = inventoryPage.tableHeaderColumn("Status");

      await expect(itemHeader).toBeVisible();
      await expect(locationHeader).toBeVisible();
      await expect(qtyHeader).toBeVisible();
      await expect(conditionHeader).toBeVisible();
      await expect(statusHeader).toBeVisible();
    }
  });

  test("table headers are sortable", async ({ page }) => {
    const hasTable = await inventoryPage.inventoryTable.isVisible().catch(() => false);

    if (hasTable) {
      const itemHeader = inventoryPage.tableHeaderColumn("Item");

      // Click to sort
      await itemHeader.click();

      // Header should have sort indicator (chevron or arrow)
      const sortIcon = itemHeader.locator('[class*="lucide-arrow"], [class*="lucide-chevron"]');
      await expect(sortIcon.or(itemHeader)).toBeVisible();
    }
  });

  test("checkbox in header selects all rows", async ({ page }) => {
    const hasTable = await inventoryPage.inventoryTable.isVisible().catch(() => false);
    const rows = inventoryPage.getAllInventoryRows();
    const rowCount = await rows.count();

    if (hasTable && rowCount > 0) {
      // Find header checkbox
      const headerCheckbox = inventoryPage.tableHeader.locator('input[type="checkbox"], [role="checkbox"]');

      if (await headerCheckbox.isVisible()) {
        await headerCheckbox.click();

        // Bulk action bar should appear
        await expect(inventoryPage.bulkActionBar).toBeVisible({ timeout: 3000 });
      }
    }
  });

  test("search filters table rows", async ({ page }) => {
    const hasTable = await inventoryPage.inventoryTable.isVisible().catch(() => false);

    if (hasTable) {
      const initialRows = await inventoryPage.getAllInventoryRows().count();

      if (initialRows > 0) {
        // Search for something unlikely to match
        await inventoryPage.search("zzz-unlikely-search-term-xyz");

        // Either fewer rows or empty state
        const filteredRows = await inventoryPage.getAllInventoryRows().count();
        const hasEmptyAfterSearch = await inventoryPage.hasEmptyState();

        expect(filteredRows < initialRows || hasEmptyAfterSearch || filteredRows === 0).toBe(true);
      }
    }
  });
});

test.describe("Inventory Empty State", () => {
  test("empty state shows create button", async ({ page }) => {
    const inventoryPage = new InventoryPage(page);
    await inventoryPage.goto();
    await inventoryPage.waitForPageLoaded();

    const hasEmpty = await inventoryPage.hasEmptyState();

    if (hasEmpty) {
      // Empty state should have a create button
      const emptyStateButton = inventoryPage.emptyState.getByRole("button", { name: /add/i });
      await expect(emptyStateButton).toBeVisible();
    }
  });

  test("empty state displays appropriate message", async ({ page }) => {
    const inventoryPage = new InventoryPage(page);
    await inventoryPage.goto();
    await inventoryPage.waitForPageLoaded();

    const hasEmpty = await inventoryPage.hasEmptyState();

    if (hasEmpty) {
      await expect(inventoryPage.emptyState).toContainText(/no inventory/i);
    }
  });
});
```
  </action>
  <verify>
```bash
cd frontend && bun run test:e2e -- e2e/dashboard/inventory.spec.ts --project=chromium
```
Tests should pass (may skip some if no data exists, but no failures).
  </verify>
  <done>inventory.spec.ts created with comprehensive UI tests matching items.spec.ts pattern.</done>
</task>

<task type="auto">
  <name>Task 3: Add InventoryPage to pages index and verify</name>
  <files>frontend/e2e/pages/index.ts</files>
  <action>
1. Add InventoryPage export to the pages index file:
   ```typescript
   export { InventoryPage } from "./InventoryPage";
   ```

2. Run the full inventory test suite:
   ```bash
   bun run test:e2e -- e2e/dashboard/inventory.spec.ts --project=chromium
   ```

3. Verify no TypeScript errors across all E2E files:
   ```bash
   npx tsc --noEmit
   ```
  </action>
  <verify>
```bash
cd frontend && grep "InventoryPage" e2e/pages/index.ts
```
Should show the export.
```bash
cd frontend && bun run test:e2e -- e2e/dashboard/inventory.spec.ts --project=chromium
```
All tests should pass or be skipped gracefully (no hard failures).
  </verify>
  <done>InventoryPage exported from index, all tests pass.</done>
</task>

</tasks>

<verification>
1. `frontend/e2e/pages/InventoryPage.ts` exists with 150+ lines
2. `frontend/e2e/dashboard/inventory.spec.ts` exists with 150+ lines
3. TypeScript compilation passes: `npx tsc --noEmit`
4. Tests run without errors: `bun run test:e2e -- e2e/dashboard/inventory.spec.ts`
5. InventoryPage is exported from `frontend/e2e/pages/index.ts`
</verification>

<success_criteria>
- InventoryPage Page Object follows existing patterns (ItemsPage, LocationsPage)
- inventory.spec.ts covers: page load, empty state, create dialog, search, filters, archive toggle, import/export
- No waitForTimeout calls in new files
- All tests pass on chromium
</success_criteria>

<output>
After completion, create `.planning/phases/26-e2e-stability-and-coverage/26-03-SUMMARY.md`
</output>
