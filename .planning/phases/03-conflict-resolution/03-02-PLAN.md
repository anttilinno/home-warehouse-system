---
phase: 03-conflict-resolution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/components/conflict-resolution-dialog.tsx
  - frontend/lib/sync/use-conflict-resolution.ts
autonomous: true

must_haves:
  truths:
    - "User sees toast notification when auto-resolved (LWW) conflict occurs"
    - "User sees dialog for critical field conflicts (inventory quantity/status)"
    - "User can choose 'Keep Mine', 'Use Server', or merge individual fields"
    - "Dialog shows side-by-side comparison of conflicting values"
  artifacts:
    - path: "frontend/components/conflict-resolution-dialog.tsx"
      provides: "ConflictResolutionDialog component"
      exports: ["ConflictResolutionDialog"]
      min_lines: 100
    - path: "frontend/lib/sync/use-conflict-resolution.ts"
      provides: "React hook for managing conflict state and resolution"
      exports: ["useConflictResolution", "ConflictResolutionProvider"]
  key_links:
    - from: "frontend/components/conflict-resolution-dialog.tsx"
      to: "@/components/ui/dialog"
      via: "shadcn Dialog component"
      pattern: "import.*Dialog.*from.*ui/dialog"
    - from: "frontend/lib/sync/use-conflict-resolution.ts"
      to: "sonner"
      via: "toast notifications"
      pattern: "import.*toast.*from.*sonner"
---

<objective>
Create the conflict resolution UI: toast notifications for auto-resolved conflicts and a dialog for manual resolution of critical field conflicts.

Purpose: Provides user-facing conflict handling. Non-critical conflicts show informational toasts after LWW resolution. Critical conflicts (inventory quantity, loan status) require explicit user decision via a dialog.

Output: ConflictResolutionDialog component and useConflictResolution hook with conflict queue management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@frontend/components/ui/dialog.tsx
@frontend/components/ui/button.tsx
@frontend/components/sync-status-indicator.tsx
@.planning/phases/03-conflict-resolution/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useConflictResolution hook with conflict queue and toast notifications</name>
  <files>frontend/lib/sync/use-conflict-resolution.ts</files>
  <action>
Create frontend/lib/sync/use-conflict-resolution.ts:

1. Import dependencies:
   - React (createContext, useContext, useState, useCallback)
   - toast from "sonner"
   - ConflictLogEntry, ConflictResolution, MutationEntityType from "@/lib/db/types"

2. Define types:
   ```typescript
   interface PendingConflict {
     id: string; // unique id for this conflict instance
     entityType: MutationEntityType;
     entityId: string;
     entityName?: string; // human-readable name for display
     localData: Record<string, unknown>;
     serverData: Record<string, unknown>;
     conflictFields: string[];
     timestamp: number;
   }

   interface ConflictResolutionContextType {
     pendingConflicts: PendingConflict[];
     currentConflict: PendingConflict | null;
     addConflict: (conflict: Omit<PendingConflict, 'id' | 'timestamp'>) => void;
     resolveConflict: (id: string, resolution: ConflictResolution, mergedData?: Record<string, unknown>) => void;
     dismissConflict: (id: string) => void;
     showAutoResolvedToast: (entityType: string, entityName: string) => void;
   }
   ```

3. Create ConflictResolutionContext and provider:
   - Maintain pendingConflicts array in state
   - currentConflict = first item in queue (FIFO)
   - addConflict: generate unique id (crypto.randomUUID or Date.now()), add to queue
   - resolveConflict: remove from queue, call resolution callback
   - dismissConflict: remove from queue (user chose to ignore)

4. showAutoResolvedToast function:
   ```typescript
   toast.info("Changes merged", {
     description: `Your edits to '${entityName}' were merged with server changes`,
     duration: 4000,
   });
   ```

5. Create useConflictResolution hook that returns context value

6. Export ConflictResolutionProvider component that wraps children
  </action>
  <verify>
    Run `bun run typecheck` - no type errors
    Run `bun run lint` - no lint errors
  </verify>
  <done>
    useConflictResolution hook and ConflictResolutionProvider exported, with conflict queue management and showAutoResolvedToast function
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ConflictResolutionDialog component</name>
  <files>frontend/components/conflict-resolution-dialog.tsx</files>
  <action>
Create frontend/components/conflict-resolution-dialog.tsx:

1. Import dependencies:
   - Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter from "@/components/ui/dialog"
   - Button from "@/components/ui/button"
   - useConflictResolution from "@/lib/sync/use-conflict-resolution"
   - AlertTriangle icon from "lucide-react"
   - formatDistanceToNow from "date-fns" (already installed: ^4.1.0)

2. Create ConflictFieldRow sub-component:
   ```typescript
   interface ConflictFieldRowProps {
     fieldName: string;
     localValue: unknown;
     serverValue: unknown;
     selectedSource: 'local' | 'server';
     onSelect: (source: 'local' | 'server') => void;
   }
   ```
   - Display field name with human-readable label
   - Show local value on left, server value on right
   - Radio buttons or clickable cards to select which value to use
   - Highlight differing values

3. Format field values for display:
   - Handle null/undefined as "(empty)"
   - Format dates with date-fns (already installed: ^4.1.0)
   - Format numbers with locale
   - Truncate long strings

4. Main ConflictResolutionDialog component:
   - Get currentConflict from useConflictResolution
   - Show dialog when currentConflict is not null
   - Header: "Conflict Detected" with warning icon
   - Show entity type and name
   - Map conflictFields to ConflictFieldRow components
   - Track selected values per field in local state (default to 'server')

5. Footer buttons:
   - "Use All Server Values" - resolves with 'server'
   - "Keep All My Values" - resolves with 'local'
   - "Merge Selected" - builds merged object from selections, resolves with 'merged'

6. On resolve:
   - Build resolvedData based on selections
   - Call resolveConflict(conflict.id, resolution, mergedData)
  </action>
  <verify>
    Run `bun run typecheck` - no type errors
    Run `bun run lint` - no lint errors
    Run `bun run build` - builds successfully
  </verify>
  <done>
    ConflictResolutionDialog component renders when currentConflict exists, shows field comparison, allows Keep Mine/Use Server/Merge selection
  </done>
</task>

<task type="auto">
  <name>Task 3: Add resolution callback and enhance hook with logging</name>
  <files>frontend/lib/sync/use-conflict-resolution.ts</files>
  <action>
Enhance use-conflict-resolution.ts:

1. Add onResolve callback prop to provider:
   ```typescript
   interface ConflictResolutionProviderProps {
     children: React.ReactNode;
     onResolve?: (
       conflict: PendingConflict,
       resolution: ConflictResolution,
       resolvedData?: Record<string, unknown>
     ) => Promise<void>;
   }
   ```

2. Update resolveConflict to call onResolve callback:
   - This callback will be used by SyncManager integration to:
     a. Log conflict to IndexedDB
     b. Apply resolved data to local cache
     c. Re-queue mutation if needed

3. Add conflict count getter:
   ```typescript
   conflictCount: number; // pendingConflicts.length
   ```

4. Add critical conflict toast for when dialog is queued:
   ```typescript
   showCriticalConflictToast: (entityType: string, entityName: string) => void
   // Shows: "Review required: Changes to 'Hammer Drill' need your attention"
   // With action button to focus dialog
   ```

5. Ensure cleanup on unmount - clear any pending toasts
  </action>
  <verify>
    Run `bun run typecheck` - no type errors
    Run `bun run lint` - no lint errors
  </verify>
  <done>
    useConflictResolution hook has onResolve callback, conflictCount getter, and showCriticalConflictToast for integration with sync flow
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes
2. `bun run build` succeeds
3. `bun run lint` passes
4. Manual test: Import ConflictResolutionDialog in a test page, verify it renders dialog markup
</verification>

<success_criteria>
- ConflictResolutionDialog component exported and renders conflict comparison UI
- useConflictResolution hook manages conflict queue (FIFO)
- ConflictResolutionProvider wraps app and provides context
- showAutoResolvedToast shows informational toast for LWW resolutions
- showCriticalConflictToast shows warning toast for conflicts requiring review
- onResolve callback allows SyncManager to process resolution
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-conflict-resolution/03-02-SUMMARY.md`
</output>
