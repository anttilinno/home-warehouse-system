---
phase: 03-conflict-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/db/types.ts
  - frontend/lib/db/offline-db.ts
  - frontend/lib/sync/conflict-resolver.ts
autonomous: true

must_haves:
  truths:
    - "Conflicts are detected when server updated_at is newer than client's"
    - "Critical fields (inventory.quantity, inventory.status, loans.quantity) are identified"
    - "Non-critical conflicts are auto-resolved with last-write-wins"
    - "Conflict resolution history is available for review"
  artifacts:
    - path: "frontend/lib/db/types.ts"
      provides: "ConflictLogEntry type and updated OfflineDBSchema"
      contains: "ConflictLogEntry"
    - path: "frontend/lib/db/offline-db.ts"
      provides: "conflictLog store with indexes"
      contains: "conflictLog"
    - path: "frontend/lib/sync/conflict-resolver.ts"
      provides: "Conflict detection, classification, and resolution logic"
      exports: ["detectConflict", "classifyConflict", "resolveConflict", "logConflict"]
  key_links:
    - from: "frontend/lib/sync/conflict-resolver.ts"
      to: "frontend/lib/db/offline-db.ts"
      via: "getDB() for conflict logging"
      pattern: "getDB\\(\\)"
    - from: "frontend/lib/sync/conflict-resolver.ts"
      to: "frontend/lib/db/types.ts"
      via: "ConflictLogEntry type import"
      pattern: "import.*ConflictLogEntry"
---

<objective>
Create the conflict resolution infrastructure: types, IndexedDB store, and core resolution logic.

Purpose: Establishes the foundation for detecting and handling sync conflicts. The backend batch endpoint already returns server data on conflicts - this plan creates the client-side machinery to process those responses.

Output: ConflictLogEntry type, conflictLog IndexedDB store (version 3), and conflict-resolver.ts with detection/classification/resolution functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@frontend/lib/db/types.ts
@frontend/lib/db/offline-db.ts
@frontend/lib/sync/sync-manager.ts
@frontend/lib/sync/mutation-queue.ts
@.planning/phases/03-conflict-resolution/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ConflictLogEntry type and update IndexedDB schema</name>
  <files>
    frontend/lib/db/types.ts
    frontend/lib/db/offline-db.ts
  </files>
  <action>
1. In types.ts, add ConflictLogEntry interface:
   ```typescript
   export type ConflictResolution = 'local' | 'server' | 'merged';

   export interface ConflictLogEntry {
     id: number; // auto-increment
     entityType: MutationEntityType;
     entityId: string;
     localData: Record<string, unknown>;
     serverData: Record<string, unknown>;
     conflictFields: string[]; // fields that differed
     resolution: ConflictResolution;
     resolvedData?: Record<string, unknown>; // for merged resolution
     timestamp: number; // when conflict occurred
     resolvedAt?: number; // when resolved
   }
   ```

2. Add conflictLog to OfflineDBSchema:
   ```typescript
   conflictLog: {
     key: number;
     value: ConflictLogEntry;
     indexes: {
       entityType: MutationEntityType;
       timestamp: number;
       resolution: ConflictResolution;
     };
   };
   ```

3. In offline-db.ts, bump DB_VERSION to 3 and add migration:
   - Create conflictLog store with keyPath: "id", autoIncrement: true
   - Create indexes: entityType, timestamp, resolution
   - Add in upgrade function under `if (oldVersion < 3)` block
  </action>
  <verify>
    Run `bun run typecheck` - no type errors
    Run `bun run build` - build succeeds
  </verify>
  <done>
    ConflictLogEntry type exported from types.ts, conflictLog store defined in schema, offline-db.ts migrates to version 3 with new store and indexes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create conflict-resolver.ts with detection and resolution logic</name>
  <files>frontend/lib/sync/conflict-resolver.ts</files>
  <action>
Create frontend/lib/sync/conflict-resolver.ts with:

1. CRITICAL_FIELDS constant - fields requiring manual resolution:
   ```typescript
   const CRITICAL_FIELDS: Record<string, string[]> = {
     inventory: ['quantity', 'status'],
     loans: ['quantity', 'returned_at'],
   };
   ```

2. Type definitions:
   ```typescript
   interface ConflictData {
     entityType: MutationEntityType;
     entityId: string;
     localData: Record<string, unknown>;
     serverData: Record<string, unknown>;
     localUpdatedAt: string;
     serverUpdatedAt: string;
   }

   interface ConflictResult {
     hasConflict: boolean;
     isCritical: boolean;
     conflictFields: string[];
     resolution?: ConflictResolution;
     resolvedData?: Record<string, unknown>;
   }
   ```

3. detectConflict(localUpdatedAt: string, serverUpdatedAt: string): boolean
   - Compare ISO timestamps, return true if server is newer

4. findConflictFields(localData, serverData): string[]
   - Compare values for each key, return array of differing field names
   - Skip updated_at, created_at from comparison

5. classifyConflict(entityType: string, conflictFields: string[]): boolean
   - Return true if any conflictFields are in CRITICAL_FIELDS[entityType]

6. resolveWithLastWriteWins(serverData): Record<string, unknown>
   - Return serverData (LWW uses server version)

7. resolveConflict(conflict: ConflictData): ConflictResult
   - Detect conflict using timestamps
   - If no conflict, return { hasConflict: false }
   - Find conflicting fields
   - Classify as critical or not
   - If not critical, auto-resolve with LWW
   - If critical, return without resolution (requires UI)

8. logConflict(entry: Omit<ConflictLogEntry, 'id'>): Promise<number>
   - Insert into conflictLog store
   - Return the auto-generated id

9. getConflictLog(limit?: number): Promise<ConflictLogEntry[]>
   - Get recent conflicts, ordered by timestamp desc
  </action>
  <verify>
    Run `bun run typecheck` - no type errors
    Create a simple test: import functions, call detectConflict with test timestamps
  </verify>
  <done>
    conflict-resolver.ts exports detectConflict, findConflictFields, classifyConflict, resolveConflict, logConflict, getConflictLog. Critical fields defined for inventory and loans entities.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add conflict helper functions for mutation payload enhancement</name>
  <files>frontend/lib/sync/conflict-resolver.ts</files>
  <action>
Add helper functions to conflict-resolver.ts for integration with mutation-queue:

1. getEntityUpdatedAt(entityType: MutationEntityType, entityId: string): Promise<string | null>
   - Read entity from appropriate IndexedDB store (items, inventory, etc.)
   - Return entity.updated_at or null if not found
   - Use getById from offline-db.ts

2. enhanceMutationWithTimestamp(mutation: MutationQueueEntry): Promise<Record<string, unknown>>
   - For 'update' operations, add updated_at to payload
   - Call getEntityUpdatedAt to get current cached timestamp
   - Return enhanced payload with updated_at field
   - For 'create' operations, return payload unchanged

3. parseBatchConflictResponse(result: BatchResult, mutation: MutationQueueEntry): ConflictData | null
   - If result.status !== 'conflict', return null
   - Extract serverData from result.server_data
   - Build ConflictData with local (mutation.payload) and server data
   - Return structured ConflictData for resolution

BatchResult interface (from backend):
```typescript
interface BatchResult {
  index: number;
  status: 'success' | 'error' | 'conflict';
  entity_id?: string;
  has_conflict?: boolean;
  server_data?: Record<string, unknown>;
  error?: string;
  error_code?: string;
}
```
  </action>
  <verify>
    Run `bun run typecheck` - no type errors
    Run `bun run lint` - no lint errors
  </verify>
  <done>
    conflict-resolver.ts has getEntityUpdatedAt, enhanceMutationWithTimestamp, parseBatchConflictResponse functions ready for SyncManager integration
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes with no errors
2. `bun run build` succeeds
3. `bun run lint` passes
4. Manual verification: Open browser DevTools, check IndexedDB shows hws-offline-v1 version 3 with conflictLog store
</verification>

<success_criteria>
- ConflictLogEntry type and ConflictResolution type exported from types.ts
- OfflineDBSchema includes conflictLog store definition
- offline-db.ts version bumped to 3 with proper migration
- conflict-resolver.ts exports all detection, classification, resolution, and logging functions
- Critical fields defined for inventory (quantity, status) and loans (quantity, returned_at)
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-conflict-resolution/03-01-SUMMARY.md`
</output>
