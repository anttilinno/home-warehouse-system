---
phase: 03-conflict-resolution
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - frontend/lib/sync/sync-manager.ts
  - frontend/lib/sync/mutation-queue.ts
  - frontend/components/dashboard/dashboard-shell.tsx
autonomous: true

must_haves:
  truths:
    - "Mutations include updated_at timestamp when syncing updates"
    - "Sync flow detects conflicts from server response"
    - "Non-critical conflicts auto-resolve with LWW and show toast"
    - "Critical conflicts queue for user resolution via dialog"
    - "Resolved conflicts are logged to IndexedDB audit trail"
  artifacts:
    - path: "frontend/lib/sync/sync-manager.ts"
      provides: "Conflict-aware mutation processing"
      contains: "handleConflict"
    - path: "frontend/lib/sync/mutation-queue.ts"
      provides: "Enhanced mutation payload with updated_at"
      contains: "updated_at"
    - path: "frontend/components/dashboard/dashboard-shell.tsx"
      provides: "OfflineProvider, ConflictResolutionProvider and dialog in app shell"
      contains: "ConflictResolutionProvider"
  key_links:
    - from: "frontend/lib/sync/sync-manager.ts"
      to: "frontend/lib/sync/conflict-resolver.ts"
      via: "conflict resolution functions"
      pattern: "import.*from.*conflict-resolver"
    - from: "frontend/components/dashboard/dashboard-shell.tsx"
      to: "frontend/lib/sync/use-conflict-resolution.ts"
      via: "ConflictResolutionProvider"
      pattern: "ConflictResolutionProvider"
    - from: "frontend/components/dashboard/dashboard-shell.tsx"
      to: "frontend/components/conflict-resolution-dialog.tsx"
      via: "ConflictResolutionDialog component"
      pattern: "ConflictResolutionDialog"
    - from: "frontend/components/dashboard/dashboard-shell.tsx"
      to: "frontend/lib/contexts/offline-context.tsx"
      via: "OfflineProvider wrapping SSEProvider"
      pattern: "OfflineProvider"
---

<objective>
Integrate conflict resolution into the sync flow: enhance mutations with timestamps, detect conflicts from responses, route to auto/manual resolution, and wire up the UI.

Purpose: Connects the conflict infrastructure (Plan 01) and UI (Plan 02) into the existing SyncManager. After this plan, the full conflict detection and resolution flow works end-to-end.

Output: SyncManager handles conflicts, mutations include updated_at, dashboard-shell includes providers and dialog.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@frontend/lib/sync/sync-manager.ts
@frontend/lib/sync/mutation-queue.ts
@frontend/components/dashboard/dashboard-shell.tsx
@frontend/lib/contexts/offline-context.tsx
@.planning/phases/03-conflict-resolution/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance mutation queue to include updated_at in payloads</name>
  <files>frontend/lib/sync/mutation-queue.ts</files>
  <action>
Update mutation-queue.ts:

1. Import getEntityUpdatedAt from conflict-resolver (will be available from Plan 01):
   ```typescript
   import { getEntityUpdatedAt } from "./conflict-resolver";
   ```

2. Update QueueMutationParams interface to accept optional updated_at:
   ```typescript
   export interface QueueMutationParams {
     operation: MutationOperation;
     entity: MutationEntityType;
     entityId?: string;
     payload: Record<string, unknown>;
     cachedUpdatedAt?: string; // ISO timestamp from cached entity
   }
   ```

3. Update queueMutation function:
   - If operation is 'update' and cachedUpdatedAt provided, include in entry
   - Add updatedAt field to MutationQueueEntry (optional)

4. Add helper to prepare payload for sync:
   ```typescript
   export function prepareSyncPayload(
     mutation: MutationQueueEntry
   ): Record<string, unknown> {
     if (mutation.operation === 'update' && mutation.updatedAt) {
       return {
         ...mutation.payload,
         updated_at: mutation.updatedAt,
       };
     }
     return mutation.payload;
   }
   ```

Note: The actual timestamp fetch happens at mutation creation time (in the hooks/forms that call queueMutation), not in mutation-queue itself.
  </action>
  <verify>
    Run `bun run typecheck` - no type errors
    Run `bun run lint` - no lint errors
  </verify>
  <done>
    MutationQueueEntry can store updatedAt, prepareSyncPayload adds updated_at to payload for updates
  </done>
</task>

<task type="auto">
  <name>Task 2: Add conflict handling to SyncManager.processMutation</name>
  <files>frontend/lib/sync/sync-manager.ts</files>
  <action>
Update sync-manager.ts:

1. Add imports:
   ```typescript
   import {
     detectConflict,
     classifyConflict,
     findConflictFields,
     resolveWithLastWriteWins,
     logConflict,
   } from "./conflict-resolver";
   import { prepareSyncPayload } from "./mutation-queue";
   ```

2. Add new sync event types:
   ```typescript
   export type SyncEventType =
     | ... existing ...
     | "CONFLICT_DETECTED"
     | "CONFLICT_AUTO_RESOLVED"
     | "CONFLICT_NEEDS_REVIEW";
   ```

3. Add conflict handler fields to payload:
   ```typescript
   export interface SyncEvent {
     type: SyncEventType;
     payload?: {
       ... existing ...
       conflict?: {
         entityType: string;
         entityId: string;
         entityName?: string;
         localData: Record<string, unknown>;
         serverData: Record<string, unknown>;
         conflictFields: string[];
         isCritical: boolean;
       };
     };
   }
   ```

4. Update processMutation to use prepareSyncPayload:
   ```typescript
   body: JSON.stringify(prepareSyncPayload(mutation)),
   ```

5. Add conflict detection for 409 response:
   ```typescript
   if (response.status === 409) {
     const conflictData = await response.json();
     return this.handleConflict(mutation, conflictData);
   }
   ```

6. Add handleConflict method:
   ```typescript
   private async handleConflict(
     mutation: MutationQueueEntry,
     serverResponse: { server_data: Record<string, unknown>; updated_at: string }
   ): Promise<boolean> {
     const localData = mutation.payload;
     const serverData = serverResponse.server_data;
     const conflictFields = findConflictFields(localData, serverData);
     const isCritical = classifyConflict(mutation.entity, conflictFields);

     if (!isCritical) {
       // Auto-resolve with LWW
       const resolved = resolveWithLastWriteWins(serverData);
       await logConflict({
         entityType: mutation.entity,
         entityId: mutation.entityId!,
         localData,
         serverData,
         conflictFields,
         resolution: 'server',
         resolvedData: resolved,
         timestamp: Date.now(),
         resolvedAt: Date.now(),
       });

       // Remove mutation (server version wins)
       await removeMutation(mutation.id);
       this.broadcast({
         type: "CONFLICT_AUTO_RESOLVED",
         payload: {
           mutation,
           conflict: {
             entityType: mutation.entity,
             entityId: mutation.entityId!,
             localData,
             serverData,
             conflictFields,
             isCritical: false,
           },
         },
       });
       return true;
     }

     // Critical conflict - needs user review
     await updateMutationStatus(mutation.id, { status: 'pending' });
     this.broadcast({
       type: "CONFLICT_NEEDS_REVIEW",
       payload: {
         mutation,
         conflict: {
           entityType: mutation.entity,
           entityId: mutation.entityId!,
           localData,
           serverData,
           conflictFields,
           isCritical: true,
         },
       },
     });
     return false;
   }
   ```
  </action>
  <verify>
    Run `bun run typecheck` - no type errors
    Run `bun run lint` - no lint errors
    Run `bun run build` - builds successfully
  </verify>
  <done>
    SyncManager detects 409 conflicts, classifies as critical/non-critical, auto-resolves LWW or broadcasts for UI handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire OfflineProvider, ConflictResolutionProvider and Dialog into dashboard-shell</name>
  <files>frontend/components/dashboard/dashboard-shell.tsx</files>
  <action>
Update frontend/components/dashboard/dashboard-shell.tsx:

1. Add imports:
   ```typescript
   import { OfflineProvider } from "@/lib/contexts/offline-context";
   import { ConflictResolutionProvider } from "@/lib/sync/use-conflict-resolution";
   import { ConflictResolutionDialog } from "@/components/conflict-resolution-dialog";
   ```

2. Wrap the return JSX with the proper provider order (OfflineProvider outermost, then SSEProvider, then ConflictResolutionProvider innermost):
   ```typescript
   return (
     <OfflineProvider>
       <SSEProvider>
         <ConflictResolutionProvider
           onResolve={async (conflict, resolution, resolvedData) => {
             // This callback is handled by the hook - just log for now
             console.log("[DashboardShell] Conflict resolved:", conflict.entityId, resolution);
           }}
         >
           <div className="min-h-screen bg-muted/30">
             {/* existing content */}
             <ConflictResolutionDialog />
           </div>
         </ConflictResolutionProvider>
       </SSEProvider>
     </OfflineProvider>
   );
   ```

3. Place ConflictResolutionDialog inside the ConflictResolutionProvider, at the end of the div
   - Dialog renders itself when currentConflict exists
   - No additional wiring needed

4. Connect SyncManager events to conflict resolution context:
   - OfflineProvider already subscribes to SyncManager events (see offline-context.tsx lines 214-231)
   - Add conflict event handling to the existing switch statement in OfflineContext:
     - On CONFLICT_NEEDS_REVIEW event: The context doesn't need to handle this directly - the ConflictResolutionProvider will have its own subscription
   - OR create a useConflictSync hook that bridges SyncManager events to the conflict resolution context

Note: The OfflineProvider is defined in lib/contexts/offline-context.tsx but was not previously imported in the component tree. Adding it now enables the offline sync features.
  </action>
  <verify>
    Run `bun run typecheck` - no type errors
    Run `bun run build` - builds successfully
    Run `bun run dev` - app starts without errors
  </verify>
  <done>
    Dashboard-shell includes OfflineProvider (outermost), SSEProvider, ConflictResolutionProvider and ConflictResolutionDialog, conflict events from SyncManager trigger UI updates
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes
2. `bun run build` succeeds
3. `bun run dev` starts successfully
4. `bun run lint` passes
5. Manual test flow:
   - Make an offline edit to an item
   - While offline, have the server version change (simulate with different tab or direct DB edit)
   - Go online and trigger sync
   - Verify: Non-critical conflict shows toast, critical conflict shows dialog
</verification>

<success_criteria>
- Mutations for updates include updated_at in sync payload
- SyncManager handles 409 Conflict response from server
- Non-critical conflicts auto-resolve with LWW and log to IndexedDB
- Critical conflicts (inventory quantity/status) emit CONFLICT_NEEDS_REVIEW event
- OfflineProvider wraps the dashboard content (enables offline sync features)
- ConflictResolutionProvider wraps app content inside SSEProvider
- ConflictResolutionDialog renders when critical conflict queued
- Toast notifications show for auto-resolved conflicts
- All conflicts logged to conflictLog store in IndexedDB
</success_criteria>

<output>
After completion, create `.planning/phases/03-conflict-resolution/03-03-SUMMARY.md`
</output>
