---
phase: 41-container-images
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/Dockerfile.server
  - backend/Dockerfile.worker
  - backend/Dockerfile.scheduler
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Server image builds via Dockerfile.server with CGO and libwebp for photo processing"
    - "Worker image builds via Dockerfile.worker without libwebp (pure Go, CGO_ENABLED=0)"
    - "Scheduler image builds via Dockerfile.scheduler with CGO and libwebp"
    - "Frontend image builds via existing Dockerfile unchanged"
    - "docker compose --profile prod config shows each service referencing its correct Dockerfile"
  artifacts:
    - path: "backend/Dockerfile.server"
      provides: "Multi-stage build for server binary only"
      contains: "go build.*cmd/server"
    - path: "backend/Dockerfile.worker"
      provides: "Multi-stage build for worker binary only, no libwebp"
      contains: "CGO_ENABLED=0"
    - path: "backend/Dockerfile.scheduler"
      provides: "Multi-stage build for scheduler binary only with libwebp"
      contains: "go build.*cmd/scheduler"
    - path: "docker-compose.yml"
      provides: "Updated service definitions referencing per-binary Dockerfiles"
      contains: "Dockerfile.server"
  key_links:
    - from: "docker-compose.yml (backend service)"
      to: "backend/Dockerfile.server"
      via: "build.dockerfile field"
      pattern: "dockerfile: Dockerfile\\.server"
    - from: "docker-compose.yml (worker service)"
      to: "backend/Dockerfile.worker"
      via: "build.dockerfile field"
      pattern: "dockerfile: Dockerfile\\.worker"
    - from: "docker-compose.yml (scheduler service)"
      to: "backend/Dockerfile.scheduler"
      via: "build.dockerfile field"
      pattern: "dockerfile: Dockerfile\\.scheduler"
---

<objective>
Split the monolithic backend Dockerfile into per-service Dockerfiles and update docker-compose.yml to reference them.

Purpose: Each service gets its own optimized container image — the worker drops CGO and libwebp entirely (saving ~30MB and build complexity), while server and scheduler retain only what they need.

Output: Three separate backend Dockerfiles and updated compose references.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@backend/Dockerfile
@backend/.dockerignore
@docker-compose.yml
@backend/cmd/worker/main.go
@backend/cmd/scheduler/main.go
@backend/cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create per-service Dockerfiles for server, worker, and scheduler</name>
  <files>backend/Dockerfile.server, backend/Dockerfile.worker, backend/Dockerfile.scheduler</files>
  <action>
Create three Dockerfiles by splitting the current monolithic `backend/Dockerfile`. Delete the original `backend/Dockerfile` after creating the three replacements.

**backend/Dockerfile.server** — Server binary with CGO + libwebp:
```dockerfile
# ---- Builder ----
FROM golang:1.25-alpine AS builder
RUN apk add --no-cache build-base libwebp-dev
WORKDIR /src
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=1 go build -ldflags="-s -w" -o /bin/server ./cmd/server

# ---- Runtime ----
FROM alpine:3.22
RUN apk add --no-cache libwebp ca-certificates tzdata \
    && addgroup -S app && adduser -S app -G app
WORKDIR /app
COPY --from=builder /bin/server ./server
RUN mkdir -p /data/photos && chown -R app:app /app /data/photos
USER app
EXPOSE 8080
CMD ["./server"]
```

**backend/Dockerfile.worker** — Worker binary, pure Go (no CGO, no libwebp):
```dockerfile
# ---- Builder ----
FROM golang:1.25-alpine AS builder
WORKDIR /src
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 go build -ldflags="-s -w" -o /bin/worker ./cmd/worker

# ---- Runtime ----
FROM alpine:3.22
RUN apk add --no-cache ca-certificates tzdata \
    && addgroup -S app && adduser -S app -G app
WORKDIR /app
COPY --from=builder /bin/worker ./worker
USER app
EXPOSE 8081
CMD ["./worker"]
```

Key differences for worker: No `build-base` or `libwebp-dev` in builder, `CGO_ENABLED=0`, no `libwebp` in runtime, no `/data/photos` directory (worker processes CSV imports, not photos), exposes 8081 (health check port).

**backend/Dockerfile.scheduler** — Scheduler binary with CGO + libwebp:
```dockerfile
# ---- Builder ----
FROM golang:1.25-alpine AS builder
RUN apk add --no-cache build-base libwebp-dev
WORKDIR /src
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=1 go build -ldflags="-s -w" -o /bin/scheduler ./cmd/scheduler

# ---- Runtime ----
FROM alpine:3.22
RUN apk add --no-cache libwebp ca-certificates tzdata \
    && addgroup -S app && adduser -S app -G app
WORKDIR /app
COPY --from=builder /bin/scheduler ./scheduler
RUN mkdir -p /data/photos && chown -R app:app /app /data/photos
USER app
CMD ["./scheduler"]
```

Scheduler needs `/data/photos` because it runs thumbnail processing jobs via imageprocessor. No EXPOSE needed (scheduler has no HTTP server — it runs cron jobs).

After creating all three files, delete the original `backend/Dockerfile` with `rm backend/Dockerfile`.
  </action>
  <verify>
Run these commands to verify each Dockerfile is syntactically valid and builds the correct binary:
```bash
# Verify files exist and old one is gone
ls backend/Dockerfile.server backend/Dockerfile.worker backend/Dockerfile.scheduler
test ! -f backend/Dockerfile

# Verify each builds only one binary
grep -c 'go build' backend/Dockerfile.server  # should be 1
grep -c 'go build' backend/Dockerfile.worker   # should be 1
grep -c 'go build' backend/Dockerfile.scheduler # should be 1

# Verify worker has no CGO/libwebp
grep 'CGO_ENABLED=0' backend/Dockerfile.worker
! grep 'libwebp' backend/Dockerfile.worker

# Verify server and scheduler have CGO + libwebp
grep 'CGO_ENABLED=1' backend/Dockerfile.server
grep 'libwebp' backend/Dockerfile.server
grep 'CGO_ENABLED=1' backend/Dockerfile.scheduler
grep 'libwebp' backend/Dockerfile.scheduler
```
  </verify>
  <done>Three Dockerfile variants exist: server (CGO+libwebp), worker (pure Go, no libwebp), scheduler (CGO+libwebp). Original monolithic Dockerfile deleted.</done>
</task>

<task type="auto">
  <name>Task 2: Update docker-compose.yml to reference per-service Dockerfiles</name>
  <files>docker-compose.yml</files>
  <action>
Update the three backend service definitions in `docker-compose.yml` to reference their specific Dockerfiles:

**backend service**: Change `dockerfile: Dockerfile` to `dockerfile: Dockerfile.server`. Remove the `command` override if present (server CMD is already correct in Dockerfile.server).

**worker service**: Change `dockerfile: Dockerfile` to `dockerfile: Dockerfile.worker`. Remove `command: ["./worker"]` since Dockerfile.worker already has `CMD ["./worker"]`.

**scheduler service**: Change `dockerfile: Dockerfile` to `dockerfile: Dockerfile.scheduler`. Remove `command: ["./scheduler"]` since Dockerfile.scheduler already has `CMD ["./scheduler"]`.

The frontend service stays unchanged — it already references `dockerfile: Dockerfile` which is the correct `frontend/Dockerfile`.

No other changes to environment variables, volumes, depends_on, healthchecks, or networks.
  </action>
  <verify>
```bash
# Verify compose references correct Dockerfiles
grep -A2 'context: ./backend' docker-compose.yml | grep 'dockerfile:'
# Should show: Dockerfile.server, Dockerfile.worker, Dockerfile.scheduler

# Verify no leftover command overrides for worker/scheduler
# (backend service should have no command either)

# Validate compose file
docker compose --profile prod config > /dev/null 2>&1 && echo "valid" || echo "invalid"
```
  </verify>
  <done>docker-compose.yml references Dockerfile.server for backend, Dockerfile.worker for worker, Dockerfile.scheduler for scheduler. No command overrides needed since each Dockerfile has the correct CMD.</done>
</task>

</tasks>

<verification>
1. `ls backend/Dockerfile.server backend/Dockerfile.worker backend/Dockerfile.scheduler` — all three exist
2. `test ! -f backend/Dockerfile` — original monolithic Dockerfile deleted
3. `docker compose --profile prod config` — valid compose configuration
4. Each Dockerfile builds exactly one binary (grep confirms single `go build` per file)
5. Worker Dockerfile has no libwebp dependency (CGO_ENABLED=0, no libwebp in apk add)
6. Server and scheduler Dockerfiles include libwebp in both builder and runtime stages
</verification>

<success_criteria>
- Three separate Dockerfiles exist under backend/, each building exactly one binary
- Worker image is lighter: no CGO toolchain in build, no libwebp in runtime
- docker-compose.yml correctly references each per-service Dockerfile
- Original monolithic Dockerfile is removed
- `docker compose --profile prod config` validates without errors
</success_criteria>

<output>
After completion, create `.planning/phases/41-container-images/41-01-SUMMARY.md`
</output>
