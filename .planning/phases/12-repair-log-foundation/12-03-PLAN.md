---
phase: 12-repair-log-foundation
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - frontend/lib/types/repair-log.ts
  - frontend/lib/api/repair-logs.ts
  - frontend/lib/api/index.ts
  - frontend/components/inventory/repair-history.tsx
  - frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx
  - frontend/messages/en.json
  - frontend/messages/fi.json
autonomous: true

must_haves:
  truths:
    - "User can view repair history on inventory detail/list page"
    - "User can create a new repair entry from the UI"
    - "User can transition repair status (start, complete)"
    - "User can update inventory condition when completing a repair"
  artifacts:
    - path: "frontend/lib/types/repair-log.ts"
      provides: "TypeScript types matching API responses"
      exports: ["RepairLog", "RepairStatus", "RepairLogCreate"]
    - path: "frontend/lib/api/repair-logs.ts"
      provides: "API client functions"
      exports: ["repairLogsApi"]
    - path: "frontend/components/inventory/repair-history.tsx"
      provides: "Repair history display and management component"
      min_lines: 100
  key_links:
    - from: "frontend/components/inventory/repair-history.tsx"
      to: "frontend/lib/api/repair-logs.ts"
      via: "fetch and mutate repair logs"
      pattern: "repairLogsApi\\.(list|create|complete)"
    - from: "frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx"
      to: "frontend/components/inventory/repair-history.tsx"
      via: "import and render in row action"
      pattern: "RepairHistory"
---

<objective>
Create the frontend integration for repair log management.

Purpose: Enable users to view and manage repair history for inventory items through a clean UI component integrated into the inventory page.

Output: TypeScript types, API client, repair history component with status transitions, integration into inventory page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-repair-log-foundation/12-RESEARCH.md
@.planning/phases/12-repair-log-foundation/12-02-SUMMARY.md

# Existing patterns to follow
@frontend/lib/types/loans.ts
@frontend/lib/api/loans.ts
@frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx
@frontend/lib/types/inventory.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types and API client</name>
  <files>
    frontend/lib/types/repair-log.ts
    frontend/lib/api/repair-logs.ts
    frontend/lib/api/index.ts
  </files>
  <action>
**frontend/lib/types/repair-log.ts**:

```typescript
export type RepairStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED';

export interface RepairLog {
  id: string;
  workspace_id: string;
  inventory_id: string;
  status: RepairStatus;
  description: string;
  repair_date: string | null;
  cost: number | null;  // in cents
  currency_code: string | null;
  service_provider: string | null;
  completed_at: string | null;
  new_condition: string | null;
  notes: string | null;
  created_at: string;
  updated_at: string;
}

export interface RepairLogListResponse {
  items: RepairLog[];
  total?: number;
  page?: number;
  total_pages?: number;
}

export interface RepairLogCreate {
  inventory_id: string;
  description: string;
  repair_date?: string;
  cost?: number;
  currency_code?: string;
  service_provider?: string;
  notes?: string;
}

export interface RepairLogUpdate {
  description?: string;
  repair_date?: string;
  cost?: number;
  currency_code?: string;
  service_provider?: string;
  notes?: string;
}

export interface RepairLogComplete {
  new_condition?: string;  // InventoryCondition value
}
```

**frontend/lib/api/repair-logs.ts**:

```typescript
import { apiClient } from "./client";
import type {
  RepairLog,
  RepairLogListResponse,
  RepairLogCreate,
  RepairLogUpdate,
  RepairLogComplete,
  RepairStatus,
} from "../types/repair-log";

export const repairLogsApi = {
  /**
   * List all repair logs in workspace
   */
  list: async (
    workspaceId: string,
    params?: { page?: number; limit?: number; status?: RepairStatus }
  ): Promise<RepairLogListResponse> => {
    const queryParams = new URLSearchParams();
    if (params?.page) queryParams.append("page", params.page.toString());
    if (params?.limit) queryParams.append("limit", params.limit.toString());
    if (params?.status) queryParams.append("status", params.status);

    const url = `/workspaces/${workspaceId}/repairs${queryParams.toString() ? `?${queryParams.toString()}` : ""}`;
    return apiClient.get<RepairLogListResponse>(url);
  },

  /**
   * Get repair logs for a specific inventory item
   */
  listByInventory: async (
    workspaceId: string,
    inventoryId: string
  ): Promise<RepairLog[]> => {
    const response = await apiClient.get<RepairLogListResponse>(
      `/workspaces/${workspaceId}/inventory/${inventoryId}/repairs`
    );
    return response.items;
  },

  /**
   * Get a single repair log by ID
   */
  get: async (workspaceId: string, id: string): Promise<RepairLog> => {
    return apiClient.get<RepairLog>(`/workspaces/${workspaceId}/repairs/${id}`);
  },

  /**
   * Create a new repair log
   */
  create: async (workspaceId: string, data: RepairLogCreate): Promise<RepairLog> => {
    return apiClient.post<RepairLog>(`/workspaces/${workspaceId}/repairs`, data);
  },

  /**
   * Update repair log details
   */
  update: async (
    workspaceId: string,
    id: string,
    data: RepairLogUpdate
  ): Promise<RepairLog> => {
    return apiClient.patch<RepairLog>(`/workspaces/${workspaceId}/repairs/${id}`, data);
  },

  /**
   * Start a repair (pending -> in_progress)
   */
  start: async (workspaceId: string, id: string): Promise<RepairLog> => {
    return apiClient.post<RepairLog>(`/workspaces/${workspaceId}/repairs/${id}/start`);
  },

  /**
   * Complete a repair (in_progress -> completed)
   */
  complete: async (
    workspaceId: string,
    id: string,
    data?: RepairLogComplete
  ): Promise<RepairLog> => {
    return apiClient.post<RepairLog>(
      `/workspaces/${workspaceId}/repairs/${id}/complete`,
      data || {}
    );
  },

  /**
   * Delete a repair log
   */
  delete: async (workspaceId: string, id: string): Promise<void> => {
    await apiClient.delete(`/workspaces/${workspaceId}/repairs/${id}`);
  },
};
```

**frontend/lib/api/index.ts**: Add export:
```typescript
export { repairLogsApi } from "./repair-logs";
```
  </action>
  <verify>
    - `cd frontend && bun run typecheck` passes
    - Types match backend API response structure
  </verify>
  <done>
    TypeScript types and API client created and exported. Types match backend RepairLogResponse structure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create repair history component</name>
  <files>
    frontend/components/inventory/repair-history.tsx
    frontend/messages/en.json
    frontend/messages/fi.json
  </files>
  <action>
Create RepairHistory component that shows repair history for an inventory item and allows creating/managing repairs.

**frontend/components/inventory/repair-history.tsx**:

Component props:
- inventoryId: string
- workspaceId: string
- onRepairComplete?: (newCondition?: string) => void (callback when repair completed)

State:
- repairs: RepairLog[]
- loading: boolean
- creating: boolean
- createDialogOpen: boolean
- form fields for new repair

Features:

1. List view:
   - Show table/list of repairs for this inventory
   - Columns: Description, Status (badge), Date, Cost, Service Provider, Actions
   - Status badges with colors: PENDING (yellow), IN_PROGRESS (blue), COMPLETED (green)
   - Empty state when no repairs

2. Create dialog:
   - Button "Add Repair" opens dialog
   - Form fields: description (required), repair_date (date picker), cost (number), currency_code (select EUR/USD/etc), service_provider (text), notes (textarea)
   - Submit calls repairLogsApi.create
   - Toast on success/error

3. Status transitions:
   - For PENDING repairs: "Start Repair" button -> calls repairLogsApi.start
   - For IN_PROGRESS repairs: "Complete" button -> opens dialog with optional new_condition select
   - Complete dialog has InventoryCondition dropdown (NEW, EXCELLENT, GOOD, FAIR, POOR, DAMAGED, FOR_REPAIR)
   - On complete, call repairLogsApi.complete with new_condition if selected
   - Call onRepairComplete callback to refresh parent

4. Actions menu (dropdown):
   - Edit (opens edit dialog)
   - Delete (with confirmation)

Use existing UI components:
- Card, CardHeader, CardContent from @/components/ui/card
- Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter from @/components/ui/dialog
- Button from @/components/ui/button
- Badge from @/components/ui/badge
- Input, Label, Textarea from @/components/ui
- Select, SelectTrigger, SelectValue, SelectContent, SelectItem
- DropdownMenu for actions
- Table for list view
- Skeleton for loading state
- EmptyState for no repairs

Import InventoryCondition type from @/lib/types/inventory for the condition select.

Use sonner toast for success/error messages.

Fetch repairs on mount and after mutations using useEffect.

**messages/en.json**: Add translations under "repairs" key:
```json
"repairs": {
  "title": "Repair History",
  "add": "Add Repair",
  "description": "Description",
  "status": "Status",
  "date": "Repair Date",
  "cost": "Cost",
  "serviceProvider": "Service Provider",
  "notes": "Notes",
  "newCondition": "Update Item Condition",
  "pending": "Pending",
  "inProgress": "In Progress",
  "completed": "Completed",
  "startRepair": "Start Repair",
  "completeRepair": "Complete Repair",
  "noRepairs": "No repair history",
  "noRepairsDescription": "Repair entries will appear here when added",
  "createSuccess": "Repair log created",
  "startSuccess": "Repair started",
  "completeSuccess": "Repair completed",
  "deleteSuccess": "Repair deleted",
  "error": "An error occurred"
}
```

**messages/fi.json**: Add Finnish translations for repairs key.
  </action>
  <verify>
    - `cd frontend && bun run typecheck` passes
    - `cd frontend && bun run build` succeeds
    - Component renders without errors (manual check in browser)
  </verify>
  <done>
    RepairHistory component displays repairs, supports create/start/complete actions, and shows status badges with proper colors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate repair history into inventory page</name>
  <files>
    frontend/app/[locale]/(dashboard)/dashboard/inventory/page.tsx
  </files>
  <action>
Add repair history access to the inventory page.

1. Add import at top:
   ```typescript
   import { RepairHistory } from "@/components/inventory/repair-history";
   import { Wrench } from "lucide-react";
   ```

2. Add state for repair history dialog:
   ```typescript
   const [repairDialogOpen, setRepairDialogOpen] = useState(false);
   const [repairInventoryId, setRepairInventoryId] = useState<string | null>(null);
   ```

3. Add "Repair History" option to the row actions dropdown menu (after Move, before separator):
   ```typescript
   <DropdownMenuItem onClick={() => {
     setRepairInventoryId(inventory.id);
     setRepairDialogOpen(true);
   }}>
     <Wrench className="mr-2 h-4 w-4" />
     Repair History
   </DropdownMenuItem>
   ```

4. Add RepairHistory dialog at the bottom of the component (after other dialogs):
   ```typescript
   {/* Repair History Dialog */}
   <Dialog open={repairDialogOpen} onOpenChange={setRepairDialogOpen}>
     <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
       <DialogHeader>
         <DialogTitle>Repair History</DialogTitle>
       </DialogHeader>
       {repairInventoryId && workspaceId && (
         <RepairHistory
           inventoryId={repairInventoryId}
           workspaceId={workspaceId}
           onRepairComplete={() => {
             // Refresh inventory list to reflect condition change
             refetch();
           }}
         />
       )}
     </DialogContent>
   </Dialog>
   ```

5. Ensure Dialog import includes DialogHeader, DialogTitle if not already imported.

The integration should:
- Show "Repair History" in row actions for each inventory item
- Open a dialog with the RepairHistory component
- Refresh the inventory list when a repair is completed (in case condition changed)
  </action>
  <verify>
    - `cd frontend && bun run typecheck` passes
    - `cd frontend && bun run build` succeeds
    - Navigate to /dashboard/inventory, click row actions, see "Repair History" option
    - Click "Repair History" opens dialog with repair history component
  </verify>
  <done>
    Inventory page has "Repair History" action that opens repair management dialog. User can view, create, and manage repairs from the inventory list.
  </done>
</task>

</tasks>

<verification>
1. Frontend builds: `cd frontend && bun run build`
2. TypeScript passes: `cd frontend && bun run typecheck`
3. Manual testing:
   - Navigate to inventory page
   - Click row actions on any inventory item
   - Select "Repair History"
   - Dialog opens with repair history
   - Can add a new repair
   - Can start and complete repairs
   - Condition updates when completing with new condition
</verification>

<success_criteria>
- TypeScript types match backend API responses
- API client provides all repair log operations
- RepairHistory component displays repairs with status badges
- Users can create, start, and complete repairs from the UI
- Users can optionally update inventory condition when completing
- Translations added for English and Finnish
- Component integrated into inventory page via row actions
- All TypeScript checks pass
- Frontend builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/12-repair-log-foundation/12-03-SUMMARY.md`
</output>
