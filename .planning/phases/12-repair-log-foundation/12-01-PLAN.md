---
phase: 12-repair-log-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/db/migrations/003_repair_logs.sql
  - backend/db/queries/repair_logs.sql
  - backend/internal/domain/warehouse/repairlog/entity.go
  - backend/internal/domain/warehouse/repairlog/entity_test.go
  - backend/internal/domain/warehouse/repairlog/errors.go
  - backend/internal/domain/warehouse/repairlog/repository.go
  - backend/internal/infra/postgres/repairlog_repository.go
autonomous: true

must_haves:
  truths:
    - "Repair log database schema exists with status enum and all required fields"
    - "Domain entity validates status transitions (pending -> in_progress -> completed)"
    - "Repository can create, read, update repair logs with workspace isolation"
  artifacts:
    - path: "backend/db/migrations/003_repair_logs.sql"
      provides: "repair_status_enum and repair_logs table"
      contains: "CREATE TYPE warehouse.repair_status_enum"
    - path: "backend/internal/domain/warehouse/repairlog/entity.go"
      provides: "RepairLog domain entity with status workflow"
      exports: ["RepairLog", "NewRepairLog", "Reconstruct", "StatusPending", "StatusInProgress", "StatusCompleted"]
    - path: "backend/internal/infra/postgres/repairlog_repository.go"
      provides: "PostgreSQL repository implementation"
      min_lines: 80
  key_links:
    - from: "backend/internal/infra/postgres/repairlog_repository.go"
      to: "backend/internal/domain/warehouse/repairlog/repository.go"
      via: "implements Repository interface"
      pattern: "func.*Repository.*FindByID"
---

<objective>
Create the database schema and backend domain layer for repair log tracking.

Purpose: Establish the data model and core domain logic for tracking repairs on inventory items, following the loan domain pattern for status workflow and inventory relationship.

Output: Migration file, sqlc queries, domain entity with status transitions, repository interface and implementation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-repair-log-foundation/12-RESEARCH.md

# Existing patterns to follow
@backend/db/migrations/001_initial_schema.sql
@backend/db/queries/loans.sql
@backend/internal/domain/warehouse/loan/entity.go
@backend/internal/domain/warehouse/loan/errors.go
@backend/internal/domain/warehouse/loan/repository.go
@backend/internal/infra/postgres/loan_repository.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration and sqlc queries</name>
  <files>
    backend/db/migrations/003_repair_logs.sql
    backend/db/queries/repair_logs.sql
  </files>
  <action>
Create migration `003_repair_logs.sql` with:

1. ENUM type `warehouse.repair_status_enum` with values: 'PENDING', 'IN_PROGRESS', 'COMPLETED'

2. Table `warehouse.repair_logs` with columns:
   - id uuid DEFAULT uuidv7() PRIMARY KEY
   - workspace_id uuid NOT NULL REFERENCES auth.workspaces(id) ON DELETE CASCADE
   - inventory_id uuid NOT NULL REFERENCES warehouse.inventory(id) ON DELETE CASCADE
   - status warehouse.repair_status_enum NOT NULL DEFAULT 'PENDING'
   - description TEXT NOT NULL
   - repair_date DATE (nullable - when repair started/scheduled)
   - cost INTEGER (nullable - in cents)
   - currency_code VARCHAR(3) DEFAULT 'EUR'
   - service_provider VARCHAR(200) (nullable)
   - completed_at TIMESTAMPTZ (nullable - set when status becomes COMPLETED)
   - new_condition warehouse.item_condition_enum (nullable - condition to set on inventory when completed)
   - notes TEXT (nullable)
   - created_at TIMESTAMPTZ DEFAULT now()
   - updated_at TIMESTAMPTZ DEFAULT now()

3. Indexes:
   - ix_repair_logs_workspace ON (workspace_id)
   - ix_repair_logs_inventory ON (inventory_id)
   - ix_repair_logs_status ON (workspace_id, status)

Create sqlc queries `repair_logs.sql` with:
- GetRepairLog: Get by id + workspace_id
- CreateRepairLog: Insert with all fields, RETURNING *
- UpdateRepairLog: Update description, repair_date, cost, currency_code, service_provider, notes
- UpdateRepairLogStatus: Update status + updated_at
- CompleteRepairLog: Set status='COMPLETED', completed_at=now(), new_condition
- DeleteRepairLog: Hard delete by id
- ListRepairLogsByInventory: By workspace_id + inventory_id, ORDER BY created_at DESC
- ListRepairLogsByWorkspace: By workspace_id with pagination, ORDER BY created_at DESC
- ListRepairLogsByStatus: By workspace_id + status with pagination
- CountRepairLogsByInventory: Count for an inventory item

Run `mise run sqlc` to generate Go code after creating the queries.
  </action>
  <verify>
    - `mise run migrate` succeeds
    - `mise run sqlc` generates code without errors
    - Check backend/internal/infra/queries/repair_logs.sql.go exists
  </verify>
  <done>
    Database has repair_logs table with proper schema, indexes, and enum. sqlc has generated type-safe query functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create domain entity with status workflow</name>
  <files>
    backend/internal/domain/warehouse/repairlog/entity.go
    backend/internal/domain/warehouse/repairlog/entity_test.go
    backend/internal/domain/warehouse/repairlog/errors.go
    backend/internal/domain/warehouse/repairlog/repository.go
  </files>
  <action>
Create `repairlog` package following loan domain pattern.

**errors.go**: Define domain errors:
- ErrRepairLogNotFound
- ErrInvalidStatusTransition (for invalid state machine transitions)
- ErrRepairAlreadyCompleted
- ErrInvalidDescription (empty description)

**entity.go**: Create RepairLog struct with private fields:
- id, workspaceID, inventoryID uuid.UUID
- status RepairStatus (type alias for string with constants)
- description string
- repairDate *time.Time
- cost *int (cents)
- currencyCode *string
- serviceProvider *string
- completedAt *time.Time
- newCondition *string (inventory condition enum value)
- notes *string
- createdAt, updatedAt time.Time

Constants: StatusPending, StatusInProgress, StatusCompleted

NewRepairLog constructor:
- Validates workspaceID, inventoryID are non-nil UUIDs
- Validates description is non-empty
- Sets status to StatusPending
- Generates new UUIDv7 for id

Reconstruct function for loading from database (no validation)

Getters for all fields

Status transition methods:
- StartRepair() error: Pending -> InProgress, validates current status
- Complete(newCondition *string) error: InProgress -> Completed, sets completedAt, validates current status

Update methods:
- UpdateDetails(description string, repairDate *time.Time, cost *int, currencyCode *string, serviceProvider *string, notes *string) error

**entity_test.go**: Test status transitions:
- TestNewRepairLog_ValidInput
- TestNewRepairLog_EmptyDescription
- TestStartRepair_FromPending
- TestStartRepair_FromInProgress_Fails
- TestStartRepair_FromCompleted_Fails
- TestComplete_FromInProgress
- TestComplete_FromPending_Fails
- TestComplete_SetsCompletedAt

**repository.go**: Define Repository interface:
- Save(ctx, *RepairLog) error
- FindByID(ctx, id, workspaceID uuid.UUID) (*RepairLog, error)
- FindByInventory(ctx, workspaceID, inventoryID uuid.UUID) ([]*RepairLog, error)
- FindByWorkspace(ctx, workspaceID uuid.UUID, pagination shared.Pagination) ([]*RepairLog, int, error)
- FindByStatus(ctx, workspaceID uuid.UUID, status RepairStatus, pagination shared.Pagination) ([]*RepairLog, error)
- CountByInventory(ctx, workspaceID, inventoryID uuid.UUID) (int, error)
- Delete(ctx, id uuid.UUID) error
  </action>
  <verify>
    - `cd backend && go build ./...` succeeds
    - `cd backend && go test ./internal/domain/warehouse/repairlog/...` passes all tests
  </verify>
  <done>
    RepairLog entity enforces valid status transitions. All entity tests pass. Repository interface defined.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement PostgreSQL repository</name>
  <files>
    backend/internal/infra/postgres/repairlog_repository.go
  </files>
  <action>
Create RepairLogRepository implementing the domain Repository interface.

Follow loan_repository.go pattern:
- Constructor NewRepairLogRepository(pool *pgxpool.Pool) returning *RepairLogRepository
- Store pool and queries.New(pool)

Save method:
- Check if repair log exists by ID
- If exists: determine what changed (status transition vs detail update)
  - If status changed to COMPLETED: use CompleteRepairLog query
  - If status changed otherwise: use UpdateRepairLogStatus query
  - Otherwise: use UpdateRepairLog query
- If not exists: use CreateRepairLog query

FindByID:
- Use GetRepairLog query
- Return shared.ErrNotFound if pgx.ErrNoRows
- Convert row to domain entity using helper

FindByInventory:
- Use ListRepairLogsByInventory query
- Convert rows to domain entities

FindByWorkspace:
- Use ListRepairLogsByWorkspace query with pagination
- Return entities and count

FindByStatus:
- Use ListRepairLogsByStatus query with pagination

CountByInventory:
- Use CountRepairLogsByInventory query

Delete:
- Use DeleteRepairLog query

Helper rowToRepairLog:
- Convert queries.WarehouseRepairLog to *repairlog.RepairLog
- Handle nullable fields (pgtype.Date, pgtype.Int4, etc.)
- Use repairlog.Reconstruct
  </action>
  <verify>
    - `cd backend && go build ./...` succeeds
    - Repository compiles and implements the interface correctly
  </verify>
  <done>
    PostgreSQL repository fully implements the domain Repository interface with proper null handling and entity reconstruction.
  </done>
</task>

</tasks>

<verification>
1. Database schema is correct:
   ```sql
   \d warehouse.repair_logs
   ```
2. All Go code compiles: `cd backend && go build ./...`
3. Entity tests pass: `cd backend && go test ./internal/domain/warehouse/repairlog/...`
4. sqlc generated code exists in backend/internal/infra/queries/
</verification>

<success_criteria>
- Migration 003_repair_logs.sql creates repair_status_enum and repair_logs table
- sqlc queries generate type-safe Go code
- RepairLog entity validates status transitions (pending -> in_progress -> completed)
- Entity tests cover all status transition cases
- Repository interface defined and PostgreSQL implementation complete
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-repair-log-foundation/12-01-SUMMARY.md`
</output>
