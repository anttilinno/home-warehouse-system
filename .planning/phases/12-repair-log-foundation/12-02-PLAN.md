---
phase: 12-repair-log-foundation
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - backend/internal/domain/warehouse/repairlog/service.go
  - backend/internal/domain/warehouse/repairlog/service_test.go
  - backend/internal/domain/warehouse/repairlog/handler.go
  - backend/internal/api/router.go
autonomous: true

must_haves:
  truths:
    - "Service coordinates repair completion with inventory condition update"
    - "HTTP handlers expose CRUD operations for repair logs"
    - "SSE events published on repair create/update/complete"
    - "API routes registered in router.go"
  artifacts:
    - path: "backend/internal/domain/warehouse/repairlog/service.go"
      provides: "Business logic with inventory condition coordination"
      exports: ["Service", "ServiceInterface", "NewService"]
    - path: "backend/internal/domain/warehouse/repairlog/handler.go"
      provides: "HTTP handlers with Huma framework"
      exports: ["RegisterRoutes"]
    - path: "backend/internal/api/router.go"
      provides: "Route registration"
      contains: "repairlog.RegisterRoutes"
  key_links:
    - from: "backend/internal/domain/warehouse/repairlog/handler.go"
      to: "backend/internal/domain/warehouse/repairlog/service.go"
      via: "handler calls service methods"
      pattern: "svc\\.(Create|Complete|StartRepair)"
    - from: "backend/internal/domain/warehouse/repairlog/service.go"
      to: "backend/internal/domain/warehouse/inventory"
      via: "inventory condition update on completion"
      pattern: "inventoryRepo.*Save"
---

<objective>
Create the service layer with business logic and HTTP handlers for repair log management.

Purpose: Expose repair log CRUD operations via REST API, coordinate repair completion with inventory condition updates, and publish SSE events for real-time updates.

Output: Service with status transitions and inventory updates, HTTP handlers with proper validation and error handling, SSE integration, routes registered in main router.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-repair-log-foundation/12-RESEARCH.md
@.planning/phases/12-repair-log-foundation/12-01-SUMMARY.md

# Existing patterns to follow
@backend/internal/domain/warehouse/loan/service.go
@backend/internal/domain/warehouse/loan/handler.go
@backend/internal/api/router.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create service with business logic</name>
  <files>
    backend/internal/domain/warehouse/repairlog/service.go
    backend/internal/domain/warehouse/repairlog/service_test.go
  </files>
  <action>
Create Service struct following loan service pattern.

**service.go**:

ServiceInterface with methods:
- Create(ctx, CreateInput) (*RepairLog, error)
- GetByID(ctx, id, workspaceID uuid.UUID) (*RepairLog, error)
- Update(ctx, id, workspaceID uuid.UUID, input UpdateInput) (*RepairLog, error)
- StartRepair(ctx, id, workspaceID uuid.UUID) (*RepairLog, error)
- Complete(ctx, id, workspaceID uuid.UUID, newCondition *string) (*RepairLog, error)
- Delete(ctx, id, workspaceID uuid.UUID) error
- ListByInventory(ctx, workspaceID, inventoryID uuid.UUID) ([]*RepairLog, error)
- ListByWorkspace(ctx, workspaceID uuid.UUID, pagination shared.Pagination) ([]*RepairLog, int, error)
- ListByStatus(ctx, workspaceID uuid.UUID, status RepairStatus, pagination shared.Pagination) ([]*RepairLog, error)

Service struct with:
- repo Repository
- inventoryRepo inventory.Repository

NewService(repo Repository, inventoryRepo inventory.Repository) *Service

CreateInput struct:
- WorkspaceID, InventoryID uuid.UUID
- Description string
- RepairDate *time.Time
- Cost *int
- CurrencyCode *string
- ServiceProvider *string
- Notes *string

UpdateInput struct:
- Description *string
- RepairDate *time.Time
- Cost *int
- CurrencyCode *string
- ServiceProvider *string
- Notes *string

Create method:
- Validate inventory exists via inventoryRepo.FindByID
- Create new RepairLog entity
- Save via repo.Save
- Return created repair log

StartRepair method:
- Get repair log by ID
- Call entity.StartRepair()
- Save via repo.Save
- Return updated repair log

Complete method (KEY BUSINESS LOGIC):
- Get repair log by ID
- Call entity.Complete(newCondition)
- If newCondition is provided:
  - Get inventory via inventoryRepo.FindByID
  - Update inventory condition (inv.UpdateCondition)
  - Save inventory via inventoryRepo.Save
- Save repair log via repo.Save
- Return completed repair log

**service_test.go**: Unit tests with mock repositories:
- TestCreate_Success
- TestCreate_InventoryNotFound
- TestStartRepair_Success
- TestStartRepair_InvalidTransition
- TestComplete_Success
- TestComplete_UpdatesInventoryCondition
- TestComplete_InvalidTransition
  </action>
  <verify>
    - `cd backend && go build ./...` succeeds
    - `cd backend && go test ./internal/domain/warehouse/repairlog/...` passes
  </verify>
  <done>
    Service implements all repair log operations. Complete method coordinates inventory condition update. All service tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP handlers with Huma framework</name>
  <files>
    backend/internal/domain/warehouse/repairlog/handler.go
  </files>
  <action>
Create handler.go following loan handler pattern.

RegisterRoutes function:
- Takes api huma.API, svc ServiceInterface, broadcaster *events.Broadcaster

Endpoints:

1. POST /repairs - Create repair log
   - Input: CreateRepairLogInput with body containing inventory_id, description, repair_date?, cost?, currency_code?, service_provider?, notes?
   - Validate workspace context
   - Call svc.Create
   - Publish SSE event "repairlog.created" with id, inventory_id, status
   - Return 201 with RepairLogResponse

2. GET /repairs - List repair logs in workspace
   - Query params: page, limit, status (optional filter)
   - If status provided, call svc.ListByStatus
   - Otherwise call svc.ListByWorkspace
   - Return RepairLogListResponse with items array

3. GET /repairs/{id} - Get single repair log
   - Path param: id
   - Call svc.GetByID
   - Return RepairLogResponse or 404

4. PATCH /repairs/{id} - Update repair log details
   - Path param: id
   - Body: description?, repair_date?, cost?, currency_code?, service_provider?, notes?
   - Call svc.Update
   - Publish SSE event "repairlog.updated"
   - Return RepairLogResponse

5. POST /repairs/{id}/start - Start repair (pending -> in_progress)
   - Path param: id
   - Call svc.StartRepair
   - Publish SSE event "repairlog.started"
   - Return RepairLogResponse

6. POST /repairs/{id}/complete - Complete repair
   - Path param: id
   - Body: new_condition? (optional inventory condition to set)
   - Call svc.Complete
   - Publish SSE event "repairlog.completed" with new_condition if set
   - Return RepairLogResponse

7. DELETE /repairs/{id} - Delete repair log
   - Path param: id
   - Call svc.Delete
   - Publish SSE event "repairlog.deleted"
   - Return 204

8. GET /inventory/{inventory_id}/repairs - List repairs for inventory
   - Path param: inventory_id
   - Call svc.ListByInventory
   - Return RepairLogListResponse

Request/Response types:

RepairLogResponse struct with JSON tags:
- id, workspace_id, inventory_id (uuid)
- status (string)
- description (string)
- repair_date (string, nullable)
- cost (int, nullable)
- currency_code (string, nullable)
- service_provider (string, nullable)
- completed_at (string, nullable)
- new_condition (string, nullable)
- notes (string, nullable)
- created_at, updated_at (time.Time)

toLoanResponse helper to convert entity to response.

Handle domain errors:
- ErrRepairLogNotFound -> 404
- ErrInvalidStatusTransition -> 400
- ErrRepairAlreadyCompleted -> 400
- shared.ErrNotFound -> 404
  </action>
  <verify>
    - `cd backend && go build ./...` succeeds
    - Handler compiles with all endpoints
  </verify>
  <done>
    All HTTP endpoints implemented with proper validation, SSE publishing, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register routes in main router</name>
  <files>
    backend/internal/api/router.go
  </files>
  <action>
Update router.go to register repair log routes.

1. Add import:
   ```go
   "github.com/antti/home-warehouse/go-backend/internal/domain/warehouse/repairlog"
   ```

2. Add repository initialization (after loanRepo):
   ```go
   repairLogRepo := postgres.NewRepairLogRepository(pool)
   ```

3. Add service initialization (after loanSvc):
   ```go
   repairLogSvc := repairlog.NewService(repairLogRepo, inventoryRepo)
   ```

4. Register routes in workspace-scoped section (after loan.RegisterRoutes):
   ```go
   // Register repair log routes
   repairlog.RegisterRoutes(wsAPI, repairLogSvc, broadcaster)
   ```

Place the registration after the loan routes since they're related domains (both reference inventory).
  </action>
  <verify>
    - `cd backend && go build ./...` succeeds
    - `mise run dev` starts server without errors
    - `curl http://localhost:8000/api/v1/workspaces/{id}/repairs` returns 200 (empty list or requires auth)
  </verify>
  <done>
    Repair log routes registered and accessible. Server starts successfully.
  </done>
</task>

</tasks>

<verification>
1. All Go code compiles: `cd backend && go build ./...`
2. Service tests pass: `cd backend && go test ./internal/domain/warehouse/repairlog/...`
3. Server starts: `mise run dev` (check logs for errors)
4. API endpoints accessible (manual test with curl or Swagger UI at /docs)
</verification>

<success_criteria>
- Service coordinates repair completion with inventory condition update
- All HTTP endpoints return correct status codes and responses
- SSE events published for create/update/start/complete/delete operations
- Routes registered in router.go
- Server starts without errors
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-repair-log-foundation/12-02-SUMMARY.md`
</output>
