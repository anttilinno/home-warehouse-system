---
phase: 06-infrastructure-borrowers
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx
  - frontend/e2e/offline/offline-borrowers.spec.ts
autonomous: true

must_haves:
  truths:
    - "User can create a borrower while offline and see it appear immediately with pending badge"
    - "User can update borrower details while offline and see changes immediately with pending badge"
    - "When online, borrower mutations sync and pending indicator disappears"
    - "Global sync status indicator includes borrower pending count"
  artifacts:
    - path: "frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx"
      provides: "Offline mutation support for borrowers"
      contains: "useOfflineMutation"
    - path: "frontend/e2e/offline/offline-borrowers.spec.ts"
      provides: "E2E tests for offline borrower mutations"
      contains: "Offline Borrower Mutations"
  key_links:
    - from: "frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx"
      to: "frontend/lib/hooks/use-offline-mutation.ts"
      via: "useOfflineMutation hook"
      pattern: "useOfflineMutation"
    - from: "frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx"
      to: "frontend/lib/sync/sync-manager.ts"
      via: "syncManager.subscribe for sync events"
      pattern: "syncManager\\.subscribe"
---

<objective>
Implement offline create/update support for borrowers entity.

Purpose: Borrowers is the simplest entity (no foreign keys, no hierarchy) and serves as validation that the infrastructure from Plan 01 works correctly. Users can create and edit borrowers while offline, see them immediately with a "Pending" badge, and have them sync when back online.

Output: Borrowers page with offline mutation support, pending indicators, and E2E tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-infrastructure-borrowers/06-RESEARCH.md

# Prior work from this phase
@.planning/phases/06-infrastructure-borrowers/06-01-SUMMARY.md

# Pattern reference - items page with offline support
@frontend/app/[locale]/(dashboard)/dashboard/items/page.tsx

# Files to modify
@frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx
@frontend/lib/types/borrowers.ts
@frontend/lib/hooks/use-offline-mutation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add offline mutation support to borrowers page</name>
  <files>frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx</files>
  <action>
Modify the borrowers page to support offline create/update mutations. Follow the pattern established in items/page.tsx.

1. Add imports at the top:
   ```typescript
   import { Cloud } from "lucide-react";
   import { cn } from "@/lib/utils";
   import { useOfflineMutation } from "@/lib/hooks/use-offline-mutation";
   import { syncManager } from "@/lib/sync/sync-manager";
   import type { SyncEvent } from "@/lib/sync/sync-manager";
   ```

2. Add optimistic state after existing state declarations (around line 147):
   ```typescript
   // Optimistic borrowers for offline mutations
   const [optimisticBorrowers, setOptimisticBorrowers] = useState<(Borrower & { _pending?: boolean })[]>([]);
   ```

3. Add offline mutation hooks after the useInfiniteScroll hook (around line 170):
   ```typescript
   // Offline mutation hooks
   const { mutate: createBorrowerOffline } = useOfflineMutation<Record<string, unknown>>({
     entity: 'borrowers',
     operation: 'create',
     onMutate: (payload, tempId) => {
       const optimisticBorrower: Borrower & { _pending: boolean } = {
         id: tempId,
         workspace_id: workspaceId!,
         name: (payload.name as string) || '',
         email: (payload.email as string) || null,
         phone: (payload.phone as string) || null,
         notes: (payload.notes as string) || null,
         is_archived: false,
         created_at: new Date().toISOString(),
         updated_at: new Date().toISOString(),
         _pending: true,
       };
       setOptimisticBorrowers(prev => [...prev, optimisticBorrower]);
     },
   });

   const { mutate: updateBorrowerOffline } = useOfflineMutation<Record<string, unknown>>({
     entity: 'borrowers',
     operation: 'update',
     onMutate: (payload, _tempId) => {
       // For updates, mark the existing borrower as pending
       const entityId = payload._entityId as string;
       if (entityId) {
         setOptimisticBorrowers(prev => {
           // Check if already in optimistic list
           const existing = prev.find(b => b.id === entityId);
           if (existing) {
             return prev.map(b => b.id === entityId ? { ...b, ...payload, _pending: true } : b);
           }
           // Find in fetched borrowers and add to optimistic with updates
           const fromFetched = borrowers.find(b => b.id === entityId);
           if (fromFetched) {
             return [...prev, { ...fromFetched, ...payload, _pending: true }];
           }
           return prev;
         });
       }
     },
   });
   ```

4. Add sync event subscription after the SSE subscription useEffect (around line 202):
   ```typescript
   // Subscribe to sync events for offline mutation completion
   useEffect(() => {
     if (!syncManager) return;

     const handleSyncEvent = (event: SyncEvent) => {
       if (event.type === 'MUTATION_SYNCED' && event.payload?.mutation?.entity === 'borrowers') {
         const syncedKey = event.payload.mutation.idempotencyKey;
         const entityId = event.payload.mutation.entityId;

         // Remove from optimistic list
         setOptimisticBorrowers(prev =>
           prev.filter(b => b.id !== syncedKey && b.id !== entityId)
         );

         // Refetch to get server data
         refetch();
       }

       if (event.type === 'MUTATION_FAILED' && event.payload?.mutation?.entity === 'borrowers') {
         toast.error('Failed to sync borrower', {
           description: event.payload.mutation.lastError || 'Please try again',
         });
       }
     };

     return syncManager.subscribe(handleSyncEvent);
   }, [refetch]);
   ```

5. Create merged borrowers list with useMemo (after the filteredBorrowers memo, around line 221):
   ```typescript
   // Merge fetched borrowers with optimistic borrowers
   const mergedBorrowers = useMemo(() => {
     const fetchedIds = new Set(borrowers.map(b => b.id));

     // Start with fetched borrowers, overlay pending updates
     const merged = borrowers.map(b => {
       const optimistic = optimisticBorrowers.find(o => o.id === b.id);
       if (optimistic) {
         return { ...b, ...optimistic, _pending: true };
       }
       return b;
     });

     // Add new optimistic creates (not yet in fetched)
     const newOptimistic = optimisticBorrowers.filter(o => !fetchedIds.has(o.id));

     return [...merged, ...newOptimistic];
   }, [borrowers, optimisticBorrowers]);
   ```

6. Update filteredBorrowers to use mergedBorrowers instead of borrowers:
   Change the `useMemo` for `filteredBorrowers` to filter `mergedBorrowers`:
   ```typescript
   const filteredBorrowers = useMemo(() => {
     return mergedBorrowers.filter((borrower) => {
       // ... existing filter logic unchanged ...
     });
   }, [mergedBorrowers, debouncedSearchQuery]);
   ```

7. Modify handleSave to use offline mutations (replace the existing handleSave function around line 268):
   ```typescript
   const handleSave = async () => {
     if (!workspaceId) return;

     if (!formName.trim()) {
       toast.error("Please fill in required fields", {
         description: "Name is required",
       });
       return;
     }

     // Basic email validation
     if (formEmail && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formEmail)) {
       toast.error("Invalid email address", {
         description: "Please enter a valid email address",
       });
       return;
     }

     setIsSaving(true);

     try {
       if (editingBorrower) {
         // Update existing borrower - use offline mutation
         const updatePayload: Record<string, unknown> = {
           name: formName,
           email: formEmail || null,
           phone: formPhone || null,
           notes: formNotes || null,
           _entityId: editingBorrower.id, // Track which entity we're updating
         };

         await updateBorrowerOffline(updatePayload, editingBorrower.id);
         toast.success("Borrower update queued");
       } else {
         // Create new borrower - use offline mutation
         const createPayload: Record<string, unknown> = {
           name: formName,
           email: formEmail || null,
           phone: formPhone || null,
           notes: formNotes || null,
         };

         await createBorrowerOffline(createPayload);
         toast.success("Borrower created");
       }

       setDialogOpen(false);
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : "Failed to save borrower";
       toast.error("Failed to save borrower", {
         description: errorMessage,
       });
     } finally {
       setIsSaving(false);
     }
   };
   ```

8. Update inline edit handlers to use offline mutations:
   ```typescript
   const handleUpdateField = async (
     borrowerId: string,
     field: keyof BorrowerUpdate,
     value: string
   ) => {
     try {
       const updatePayload: Record<string, unknown> = {
         [field]: value,
         _entityId: borrowerId,
       };
       await updateBorrowerOffline(updatePayload, borrowerId);
       toast.success("Update queued");
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : "Failed to update";
       toast.error("Update failed", { description: errorMessage });
       throw error;
     }
   };
   ```

9. Add pending indicator to table rows. Find the TableRow component in the map (around line 601) and update it:
   ```typescript
   <TableRow
     className={cn(
       '_pending' in borrower && borrower._pending && "bg-amber-50/50 dark:bg-amber-900/10"
     )}
   >
   ```

10. Add pending badge next to borrower name. In the TableCell for name (around line 616), after the InlineEditCell for name:
    ```typescript
    <div className="flex-1 min-w-0">
      <div className="flex items-center gap-2">
        <InlineEditCell
          value={borrower.name}
          onSave={(newValue) =>
            handleUpdateField(borrower.id, "name", newValue)
          }
          className="font-medium"
          placeholder="Borrower name"
        />
        {'_pending' in borrower && borrower._pending && (
          <Badge variant="outline" className="text-xs text-amber-600 border-amber-300 shrink-0">
            <Cloud className="w-3 h-3 mr-1 animate-pulse" />
            Pending
          </Badge>
        )}
      </div>
      {borrower.notes && (
        <div className="text-sm text-muted-foreground line-clamp-1">
          {borrower.notes}
        </div>
      )}
    </div>
    ```

Note: The Cloud icon is already imported (added in step 1). The Badge component is already imported from shadcn.
  </action>
  <verify>
- `grep -n "useOfflineMutation" frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx` shows hook usage
- `grep -n "optimisticBorrowers" frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx` shows state
- `grep -n "syncManager.subscribe" frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx` shows subscription
- `grep -n "_pending" frontend/app/[locale]/(dashboard)/dashboard/borrowers/page.tsx` shows pending checks
- `npm run typecheck` passes (from frontend directory)
- Manual test: Open borrowers page, verify no console errors
  </verify>
  <done>
Borrowers page uses useOfflineMutation for create and update operations, shows pending badge on unsynced borrowers, and subscribes to sync events to clean up optimistic state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add E2E tests for offline borrower mutations</name>
  <files>frontend/e2e/offline/offline-borrowers.spec.ts</files>
  <action>
Create E2E test file following the pattern from offline-mutations.spec.ts:

```typescript
import { test, expect } from "../fixtures/authenticated";

/**
 * Offline borrower mutation E2E tests.
 *
 * Tests the full offline create/update flow for borrowers:
 * - Create borrower while offline
 * - Optimistic borrower appears immediately with pending indicator
 * - Borrower syncs when back online
 * - Pending indicator disappears after sync
 *
 * Chromium only: WebKit and Firefox have inconsistent offline simulation.
 */
test.describe("Offline Borrower Mutations", () => {
  test.skip(({ browserName }) => browserName !== "chromium", "Chromium only");

  // Run tests serially to avoid auth state conflicts
  test.describe.configure({ mode: "serial" });

  test.beforeEach(async ({ page }) => {
    // Navigate to borrowers page and wait for it to load
    await page.goto("/en/dashboard/borrowers");
    await page.waitForLoadState("domcontentloaded");
    await expect(page.locator("main")).toBeVisible({ timeout: 15000 });
  });

  test("creates borrower while offline with pending indicator", async ({ page, context }) => {
    // Generate unique name to avoid conflicts
    const uniqueName = `Offline Borrower ${Date.now()}`;
    const testEmail = `test-${Date.now()}@example.com`;

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));

    // Verify offline indicator appears
    const offlineIndicator = page.locator('[data-testid="offline-indicator"]');
    await expect(offlineIndicator).toBeVisible({ timeout: 5000 });

    // Click Add Borrower button
    await page.getByRole("button", { name: /Add Borrower/i }).click();

    // Wait for dialog to open
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    // Fill the form
    await page.getByLabel(/^Name/i).fill(uniqueName);
    await page.getByLabel(/Email/i).fill(testEmail);

    // Submit the form
    await page.getByRole("button", { name: /Create/i }).click();

    // Dialog should close
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify optimistic borrower appears with pending indicator
    await expect(page.getByText(uniqueName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText("Pending")).toBeVisible({ timeout: 5000 });

    // Verify the row has pending styling
    const borrowerRow = page.locator("tr").filter({ hasText: uniqueName });
    await expect(borrowerRow).toBeVisible();

    // Go back online
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for sync - pending indicator should disappear
    await expect(page.getByText("Pending")).not.toBeVisible({ timeout: 15000 });

    // Borrower should still be visible after sync
    await expect(page.getByText(uniqueName)).toBeVisible();
  });

  test("updates borrower while offline with pending indicator", async ({ page, context }) => {
    // First, find an existing borrower to update
    // Wait for borrowers table to load
    await expect(page.getByRole("table")).toBeVisible({ timeout: 10000 });

    // Check if we have any borrowers
    const rows = page.locator("tbody tr");
    const rowCount = await rows.count();

    if (rowCount === 0) {
      // Create a borrower first (online)
      await page.getByRole("button", { name: /Add Borrower/i }).click();
      await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });
      await page.getByLabel(/^Name/i).fill(`Test Borrower ${Date.now()}`);
      await page.getByRole("button", { name: /Create/i }).click();
      await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });
      // Wait for borrower to appear
      await expect(page.locator("tbody tr")).toHaveCount(1, { timeout: 10000 });
    }

    // Get the first borrower's name for reference
    const firstRow = rows.first();
    await expect(firstRow).toBeVisible({ timeout: 5000 });

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));
    await expect(page.locator('[data-testid="offline-indicator"]')).toBeVisible({ timeout: 5000 });

    // Click the first borrower's edit button
    await firstRow.getByRole("button", { name: /Actions/i }).click();
    await page.getByRole("menuitem", { name: /Edit/i }).click();

    // Wait for dialog
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    // Update the name
    const updatedName = `Updated Borrower ${Date.now()}`;
    await page.getByLabel(/^Name/i).clear();
    await page.getByLabel(/^Name/i).fill(updatedName);

    // Submit
    await page.getByRole("button", { name: /Update/i }).click();

    // Dialog should close
    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify updated borrower appears with pending indicator
    await expect(page.getByText(updatedName)).toBeVisible({ timeout: 5000 });
    await expect(page.getByText("Pending")).toBeVisible({ timeout: 5000 });

    // Go back online
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for sync
    await expect(page.getByText("Pending")).not.toBeVisible({ timeout: 15000 });

    // Updated name should still be visible
    await expect(page.getByText(updatedName)).toBeVisible();
  });

  test("borrower pending count reflected in sync status", async ({ page, context }) => {
    const uniqueName = `Queue Count Borrower ${Date.now()}`;

    // Go offline
    await context.setOffline(true);
    await page.evaluate(() => window.dispatchEvent(new Event("offline")));

    // Create borrower offline
    await page.getByRole("button", { name: /Add Borrower/i }).click();
    await expect(page.getByRole("dialog")).toBeVisible({ timeout: 5000 });

    await page.getByLabel(/^Name/i).fill(uniqueName);
    await page.getByRole("button", { name: /Create/i }).click();

    await expect(page.getByRole("dialog")).not.toBeVisible({ timeout: 5000 });

    // Verify pending indicator is shown
    await expect(page.getByText("Pending")).toBeVisible({ timeout: 5000 });

    // Go online to sync
    await context.setOffline(false);
    await page.evaluate(() => window.dispatchEvent(new Event("online")));

    // Wait for sync
    await expect(page.getByText("Pending")).not.toBeVisible({ timeout: 15000 });
  });
});
```
  </action>
  <verify>
- File exists at `frontend/e2e/offline/offline-borrowers.spec.ts`
- Run E2E tests: `cd frontend && npx playwright test offline-borrowers.spec.ts --project=chromium`
- All tests pass
  </verify>
  <done>
E2E tests verify offline borrower create and update operations work correctly with pending indicators and sync behavior.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cd frontend && npm run typecheck` - No type errors
2. `cd frontend && npm run dev` - Start dev server
3. Manual testing:
   - Open borrowers page
   - Go offline (DevTools -> Network -> Offline)
   - Create a borrower - should appear immediately with "Pending" badge
   - Edit a borrower - should show "Pending" badge
   - Go online - pending indicators should disappear
4. `cd frontend && npx playwright test offline-borrowers.spec.ts --project=chromium` - E2E tests pass
</verification>

<success_criteria>
- [ ] Borrowers page imports and uses useOfflineMutation hook
- [ ] Create borrower works offline with optimistic UI
- [ ] Update borrower works offline with optimistic UI
- [ ] Pending borrowers show amber background and "Pending" badge
- [ ] Sync events trigger optimistic state cleanup
- [ ] Toast notifications for queue success and sync failure
- [ ] E2E tests for offline create pass
- [ ] E2E tests for offline update pass
- [ ] TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-infrastructure-borrowers/06-02-SUMMARY.md`
</output>
