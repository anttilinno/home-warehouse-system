---
phase: 06-infrastructure-borrowers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/db/types.ts
  - frontend/lib/sync/mutation-queue.ts
  - frontend/lib/sync/sync-manager.ts
autonomous: true

must_haves:
  truths:
    - "Mutations sync in entity-type order (categories before locations before containers before items)"
    - "When a parent mutation fails, dependent mutations show cascaded failure status"
    - "MutationQueueEntry supports optional dependsOn field for prerequisite tracking"
  artifacts:
    - path: "frontend/lib/db/types.ts"
      provides: "MutationQueueEntry with dependsOn field"
      contains: "dependsOn?: string[]"
    - path: "frontend/lib/sync/sync-manager.ts"
      provides: "Entity-ordered queue processing and cascade failure handling"
      contains: "ENTITY_SYNC_ORDER"
    - path: "frontend/lib/sync/mutation-queue.ts"
      provides: "queueMutation with dependsOn support"
      contains: "dependsOn"
  key_links:
    - from: "frontend/lib/sync/sync-manager.ts"
      to: "frontend/lib/sync/mutation-queue.ts"
      via: "getMutationByIdempotencyKey for dependency checking"
      pattern: "getMutationByIdempotencyKey"
    - from: "frontend/lib/sync/sync-manager.ts"
      to: "frontend/lib/db/types.ts"
      via: "ENTITY_SYNC_ORDER for ordering"
      pattern: "ENTITY_SYNC_ORDER"
---

<objective>
Establish dependency-aware sync infrastructure for multi-entity offline mutations.

Purpose: Enable proper sync ordering so that parent entities (categories, locations) sync before child entities (containers, items, inventory) to prevent foreign key violations. Add cascade failure handling so users see clear errors when parent mutations fail.

Output: Extended MutationQueueEntry type, entity-ordered sync processing in SyncManager, cascade failure handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-infrastructure-borrowers/06-RESEARCH.md

# Key files to modify
@frontend/lib/db/types.ts
@frontend/lib/sync/mutation-queue.ts
@frontend/lib/sync/sync-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend MutationQueueEntry with dependsOn field</name>
  <files>
    - frontend/lib/db/types.ts
    - frontend/lib/sync/mutation-queue.ts
  </files>
  <action>
1. In `frontend/lib/db/types.ts`, add optional `dependsOn` field to `MutationQueueEntry` interface:
   ```typescript
   /** Optional array of idempotency keys this mutation depends on */
   dependsOn?: string[];
   ```
   Place it after the `updatedAt` field.

2. In `frontend/lib/sync/mutation-queue.ts`:
   - Update `QueueMutationParams` interface to include optional `dependsOn?: string[]`
   - Update `queueMutation` function to pass `dependsOn` to the entry:
     ```typescript
     const entry: Omit<MutationQueueEntry, "id"> = {
       // ... existing fields ...
       dependsOn: params.dependsOn, // Add this line
     };
     ```

Note: The `getMutationByIdempotencyKey` helper already exists in mutation-queue.ts (line 401), so no need to add it.
  </action>
  <verify>
- `grep -n "dependsOn" frontend/lib/db/types.ts` shows the field in MutationQueueEntry
- `grep -n "dependsOn" frontend/lib/sync/mutation-queue.ts` shows it in QueueMutationParams and queueMutation
- `npm run typecheck` passes (run from frontend directory)
  </verify>
  <done>
MutationQueueEntry interface includes optional dependsOn field, and queueMutation accepts and stores dependsOn parameter.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add entity-ordered sync processing to SyncManager</name>
  <files>frontend/lib/sync/sync-manager.ts</files>
  <action>
1. Add entity sync order constant at top of file (after type imports, before SyncManager class):
   ```typescript
   /**
    * Entity sync order - process entities with no dependencies first.
    * Categories and borrowers have no FK dependencies.
    * Locations have self-referential hierarchy (handled by topological sort in Phase 7+).
    * Containers depend on locations.
    * Items depend on categories (optional).
    * Inventory depends on items, locations, containers.
    * Loans depend on inventory, borrowers.
    */
   const ENTITY_SYNC_ORDER: MutationEntityType[] = [
     'categories',
     'locations',
     'borrowers',
     'containers',
     'items',
     'inventory',
     'loans',
   ];
   ```

2. Add import for MutationEntityType at top:
   ```typescript
   import type { MutationQueueEntry, MutationEntityType } from "@/lib/db/types";
   ```

3. Add import for getMutationByIdempotencyKey:
   ```typescript
   import {
     getPendingMutations,
     updateMutationStatus,
     removeMutation,
     calculateRetryDelay,
     shouldRetry,
     getPendingMutationCount,
     RETRY_CONFIG,
     prepareSyncPayload,
     getMutationByIdempotencyKey, // Add this
   } from "./mutation-queue";
   ```

4. Replace the `processQueue` method body (keep signature) with entity-ordered processing:
   ```typescript
   async processQueue(): Promise<void> {
     // Prevent concurrent processing
     if (this.isProcessing) {
       console.log("[SyncManager] Already processing, skipping");
       return;
     }

     // Skip if offline
     if (typeof navigator !== "undefined" && !navigator.onLine) {
       console.log("[SyncManager] Offline, skipping queue processing");
       return;
     }

     this.isProcessing = true;
     this.broadcast({ type: "SYNC_STARTED" });

     try {
       const pending = await getPendingMutations();
       console.log(`[SyncManager] Processing ${pending.length} pending mutations`);

       // Group mutations by entity type
       const byEntity = new Map<MutationEntityType, MutationQueueEntry[]>();
       for (const mutation of pending) {
         const list = byEntity.get(mutation.entity) || [];
         list.push(mutation);
         byEntity.set(mutation.entity, list);
       }

       // Process in entity dependency order
       for (const entityType of ENTITY_SYNC_ORDER) {
         const mutations = byEntity.get(entityType) || [];
         if (mutations.length === 0) continue;

         console.log(`[SyncManager] Processing ${mutations.length} ${entityType} mutations`);

         // TODO: For hierarchical entities (locations, categories), apply topological sort (Phase 7+)

         for (const mutation of mutations) {
           // Skip if dependencies not yet synced
           if (mutation.dependsOn?.length) {
             const allSynced = await this.areDependenciesSynced(mutation.dependsOn);
             if (!allSynced) {
               console.log(`[SyncManager] Skipping ${mutation.idempotencyKey} - dependencies pending`);
               continue;
             }
           }

           const success = await this.processMutation(mutation);

           if (!success && mutation.retries >= RETRY_CONFIG.maxRetries) {
             // Max retries reached, mark as failed and cascade to dependents
             await updateMutationStatus(mutation.id, { status: "failed" });
             await this.handleCascadeFailure(mutation);
             this.broadcast({ type: "MUTATION_FAILED", payload: { mutation } });
           }
         }
       }

       const queueLength = await this.getPendingCount();
       this.broadcast({ type: "SYNC_COMPLETE", payload: { queueLength } });
     } catch (error) {
       console.error("[SyncManager] Queue processing error:", error);
       this.broadcast({
         type: "SYNC_ERROR",
         payload: { error: String(error) },
       });
     } finally {
       this.isProcessing = false;
     }
   }
   ```

5. Add helper method `areDependenciesSynced` to the SyncManager class (after `handleConflict` method):
   ```typescript
   /**
    * Check if all dependencies have been synced (no longer in queue).
    * A dependency is synced when getMutationByIdempotencyKey returns undefined.
    */
   private async areDependenciesSynced(keys: string[]): Promise<boolean> {
     for (const key of keys) {
       const mutation = await getMutationByIdempotencyKey(key);
       if (mutation) {
         // Still in queue = not yet synced
         return false;
       }
     }
     return true;
   }
   ```

6. Add cascade failure handler method (after `areDependenciesSynced`):
   ```typescript
   /**
    * Handle cascade failure when a mutation fails permanently.
    * Finds all mutations that depend on the failed mutation and marks them as failed too.
    */
   private async handleCascadeFailure(failed: MutationQueueEntry): Promise<void> {
     const allPending = await getPendingMutations();
     const dependents = allPending.filter(m =>
       m.dependsOn?.includes(failed.idempotencyKey)
     );

     if (dependents.length === 0) return;

     console.log(`[SyncManager] Cascading failure to ${dependents.length} dependent mutations`);

     for (const dep of dependents) {
       await updateMutationStatus(dep.id, {
         status: 'failed',
         lastError: `Parent mutation failed: ${failed.entity}/${failed.idempotencyKey.slice(0, 8)}...`,
       });

       // Broadcast individual failure
       this.broadcast({
         type: 'MUTATION_FAILED',
         payload: {
           mutation: dep,
           error: `Parent mutation failed`,
         },
       });

       // Recursively cascade to this mutation's dependents
       await this.handleCascadeFailure(dep);
     }
   }
   ```
  </action>
  <verify>
- `grep -n "ENTITY_SYNC_ORDER" frontend/lib/sync/sync-manager.ts` shows the constant
- `grep -n "areDependenciesSynced" frontend/lib/sync/sync-manager.ts` shows the method
- `grep -n "handleCascadeFailure" frontend/lib/sync/sync-manager.ts` shows the cascade handler
- `grep -n "byEntity" frontend/lib/sync/sync-manager.ts` shows entity grouping in processQueue
- `npm run typecheck` passes (run from frontend directory)
  </verify>
  <done>
SyncManager processes mutations in entity-type order, checks dependencies before processing each mutation, and cascades failure to dependent mutations when a parent fails.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for entity ordering and cascade failure</name>
  <files>frontend/lib/sync/__tests__/sync-manager-ordering.test.ts</files>
  <action>
Create a new test file `frontend/lib/sync/__tests__/sync-manager-ordering.test.ts`:

```typescript
/**
 * Tests for entity-ordered sync processing and cascade failure handling.
 * These tests verify the infrastructure changes from Phase 6.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mock IndexedDB before importing modules that use it
vi.mock('@/lib/db/offline-db', () => ({
  getDB: vi.fn(),
  put: vi.fn(),
}));

// Import after mocking
import type { MutationQueueEntry, MutationEntityType } from '@/lib/db/types';

describe('Entity Sync Order', () => {
  // Test the ENTITY_SYNC_ORDER constant (imported from sync-manager)
  it('defines correct entity dependency order', async () => {
    // Dynamically import to get the constant
    const { ENTITY_SYNC_ORDER } = await import('../sync-manager');

    // Verify order: categories before items, locations before containers, etc.
    const categoryIndex = ENTITY_SYNC_ORDER.indexOf('categories');
    const locationIndex = ENTITY_SYNC_ORDER.indexOf('locations');
    const borrowerIndex = ENTITY_SYNC_ORDER.indexOf('borrowers');
    const containerIndex = ENTITY_SYNC_ORDER.indexOf('containers');
    const itemIndex = ENTITY_SYNC_ORDER.indexOf('items');
    const inventoryIndex = ENTITY_SYNC_ORDER.indexOf('inventory');
    const loanIndex = ENTITY_SYNC_ORDER.indexOf('loans');

    // Categories and locations should come before items
    expect(categoryIndex).toBeLessThan(itemIndex);
    expect(locationIndex).toBeLessThan(containerIndex);

    // Containers should come before inventory
    expect(containerIndex).toBeLessThan(inventoryIndex);

    // Items should come before inventory
    expect(itemIndex).toBeLessThan(inventoryIndex);

    // Borrowers should come before loans
    expect(borrowerIndex).toBeLessThan(loanIndex);

    // Inventory should come before loans
    expect(inventoryIndex).toBeLessThan(loanIndex);
  });

  it('includes all mutation entity types', async () => {
    const { ENTITY_SYNC_ORDER } = await import('../sync-manager');

    const expectedEntities: MutationEntityType[] = [
      'categories',
      'locations',
      'borrowers',
      'containers',
      'items',
      'inventory',
      'loans',
    ];

    expect(ENTITY_SYNC_ORDER).toHaveLength(expectedEntities.length);
    expectedEntities.forEach(entity => {
      expect(ENTITY_SYNC_ORDER).toContain(entity);
    });
  });
});

describe('MutationQueueEntry dependsOn field', () => {
  it('allows optional dependsOn array in mutation entry', () => {
    const entryWithDeps: Partial<MutationQueueEntry> = {
      id: 1,
      idempotencyKey: 'test-key',
      operation: 'create',
      entity: 'containers',
      payload: { name: 'Test Container' },
      timestamp: Date.now(),
      retries: 0,
      status: 'pending',
      dependsOn: ['parent-location-key'],
    };

    expect(entryWithDeps.dependsOn).toEqual(['parent-location-key']);
  });

  it('allows mutation entry without dependsOn', () => {
    const entryWithoutDeps: Partial<MutationQueueEntry> = {
      id: 1,
      idempotencyKey: 'test-key',
      operation: 'create',
      entity: 'borrowers',
      payload: { name: 'Test Borrower' },
      timestamp: Date.now(),
      retries: 0,
      status: 'pending',
    };

    expect(entryWithoutDeps.dependsOn).toBeUndefined();
  });
});
```

Note: This is a minimal test file that verifies the type structure and constant definition. Full integration tests for sync ordering will be added as E2E tests when we have multiple entity types with offline support.
  </action>
  <verify>
- File exists at `frontend/lib/sync/__tests__/sync-manager-ordering.test.ts`
- Run tests: `cd frontend && npm test -- --run sync-manager-ordering`
- Tests pass
  </verify>
  <done>
Unit tests verify ENTITY_SYNC_ORDER constant has correct dependency ordering and MutationQueueEntry type supports optional dependsOn field.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cd frontend && npm run typecheck` - No type errors
2. `cd frontend && npm test -- --run sync-manager-ordering` - Unit tests pass
3. Review sync-manager.ts to confirm entity ordering logic is in place
4. Verify ENTITY_SYNC_ORDER matches the order from research (categories -> locations -> borrowers -> containers -> items -> inventory -> loans)
</verification>

<success_criteria>
- [ ] MutationQueueEntry has optional dependsOn: string[] field
- [ ] queueMutation accepts and stores dependsOn parameter
- [ ] ENTITY_SYNC_ORDER constant defines correct entity processing order
- [ ] SyncManager.processQueue groups mutations by entity and processes in order
- [ ] SyncManager skips mutations whose dependencies haven't synced yet
- [ ] SyncManager cascades failure to dependent mutations when parent fails
- [ ] Unit tests verify entity ordering and type definitions
- [ ] TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-infrastructure-borrowers/06-01-SUMMARY.md`
</output>
