// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package queries

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AuthNotificationTypeEnum string

const (
	AuthNotificationTypeEnumLOANDUESOON     AuthNotificationTypeEnum = "LOAN_DUE_SOON"
	AuthNotificationTypeEnumLOANOVERDUE     AuthNotificationTypeEnum = "LOAN_OVERDUE"
	AuthNotificationTypeEnumLOANRETURNED    AuthNotificationTypeEnum = "LOAN_RETURNED"
	AuthNotificationTypeEnumREPAIRREMINDER  AuthNotificationTypeEnum = "REPAIR_REMINDER"
	AuthNotificationTypeEnumLOWSTOCK        AuthNotificationTypeEnum = "LOW_STOCK"
	AuthNotificationTypeEnumWORKSPACEINVITE AuthNotificationTypeEnum = "WORKSPACE_INVITE"
	AuthNotificationTypeEnumMEMBERJOINED    AuthNotificationTypeEnum = "MEMBER_JOINED"
	AuthNotificationTypeEnumSYSTEM          AuthNotificationTypeEnum = "SYSTEM"
)

func (e *AuthNotificationTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthNotificationTypeEnum(s)
	case string:
		*e = AuthNotificationTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthNotificationTypeEnum: %T", src)
	}
	return nil
}

type NullAuthNotificationTypeEnum struct {
	AuthNotificationTypeEnum AuthNotificationTypeEnum `json:"auth_notification_type_enum"`
	Valid                    bool                     `json:"valid"` // Valid is true if AuthNotificationTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthNotificationTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.AuthNotificationTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthNotificationTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthNotificationTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthNotificationTypeEnum), nil
}

type AuthWorkspaceRoleEnum string

const (
	AuthWorkspaceRoleEnumOwner  AuthWorkspaceRoleEnum = "owner"
	AuthWorkspaceRoleEnumAdmin  AuthWorkspaceRoleEnum = "admin"
	AuthWorkspaceRoleEnumMember AuthWorkspaceRoleEnum = "member"
	AuthWorkspaceRoleEnumViewer AuthWorkspaceRoleEnum = "viewer"
)

func (e *AuthWorkspaceRoleEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthWorkspaceRoleEnum(s)
	case string:
		*e = AuthWorkspaceRoleEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthWorkspaceRoleEnum: %T", src)
	}
	return nil
}

type NullAuthWorkspaceRoleEnum struct {
	AuthWorkspaceRoleEnum AuthWorkspaceRoleEnum `json:"auth_workspace_role_enum"`
	Valid                 bool                  `json:"valid"` // Valid is true if AuthWorkspaceRoleEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthWorkspaceRoleEnum) Scan(value interface{}) error {
	if value == nil {
		ns.AuthWorkspaceRoleEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthWorkspaceRoleEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthWorkspaceRoleEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthWorkspaceRoleEnum), nil
}

type WarehouseActivityActionEnum string

const (
	WarehouseActivityActionEnumCREATE WarehouseActivityActionEnum = "CREATE"
	WarehouseActivityActionEnumUPDATE WarehouseActivityActionEnum = "UPDATE"
	WarehouseActivityActionEnumDELETE WarehouseActivityActionEnum = "DELETE"
	WarehouseActivityActionEnumMOVE   WarehouseActivityActionEnum = "MOVE"
	WarehouseActivityActionEnumLOAN   WarehouseActivityActionEnum = "LOAN"
	WarehouseActivityActionEnumRETURN WarehouseActivityActionEnum = "RETURN"
)

func (e *WarehouseActivityActionEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseActivityActionEnum(s)
	case string:
		*e = WarehouseActivityActionEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseActivityActionEnum: %T", src)
	}
	return nil
}

type NullWarehouseActivityActionEnum struct {
	WarehouseActivityActionEnum WarehouseActivityActionEnum `json:"warehouse_activity_action_enum"`
	Valid                       bool                        `json:"valid"` // Valid is true if WarehouseActivityActionEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseActivityActionEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseActivityActionEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseActivityActionEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseActivityActionEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseActivityActionEnum), nil
}

type WarehouseActivityEntityEnum string

const (
	WarehouseActivityEntityEnumITEM      WarehouseActivityEntityEnum = "ITEM"
	WarehouseActivityEntityEnumINVENTORY WarehouseActivityEntityEnum = "INVENTORY"
	WarehouseActivityEntityEnumLOCATION  WarehouseActivityEntityEnum = "LOCATION"
	WarehouseActivityEntityEnumCONTAINER WarehouseActivityEntityEnum = "CONTAINER"
	WarehouseActivityEntityEnumCATEGORY  WarehouseActivityEntityEnum = "CATEGORY"
	WarehouseActivityEntityEnumLABEL     WarehouseActivityEntityEnum = "LABEL"
	WarehouseActivityEntityEnumLOAN      WarehouseActivityEntityEnum = "LOAN"
	WarehouseActivityEntityEnumBORROWER  WarehouseActivityEntityEnum = "BORROWER"
)

func (e *WarehouseActivityEntityEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseActivityEntityEnum(s)
	case string:
		*e = WarehouseActivityEntityEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseActivityEntityEnum: %T", src)
	}
	return nil
}

type NullWarehouseActivityEntityEnum struct {
	WarehouseActivityEntityEnum WarehouseActivityEntityEnum `json:"warehouse_activity_entity_enum"`
	Valid                       bool                        `json:"valid"` // Valid is true if WarehouseActivityEntityEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseActivityEntityEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseActivityEntityEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseActivityEntityEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseActivityEntityEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseActivityEntityEnum), nil
}

type WarehouseAttachmentTypeEnum string

const (
	WarehouseAttachmentTypeEnumPHOTO    WarehouseAttachmentTypeEnum = "PHOTO"
	WarehouseAttachmentTypeEnumMANUAL   WarehouseAttachmentTypeEnum = "MANUAL"
	WarehouseAttachmentTypeEnumRECEIPT  WarehouseAttachmentTypeEnum = "RECEIPT"
	WarehouseAttachmentTypeEnumWARRANTY WarehouseAttachmentTypeEnum = "WARRANTY"
	WarehouseAttachmentTypeEnumOTHER    WarehouseAttachmentTypeEnum = "OTHER"
)

func (e *WarehouseAttachmentTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseAttachmentTypeEnum(s)
	case string:
		*e = WarehouseAttachmentTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseAttachmentTypeEnum: %T", src)
	}
	return nil
}

type NullWarehouseAttachmentTypeEnum struct {
	WarehouseAttachmentTypeEnum WarehouseAttachmentTypeEnum `json:"warehouse_attachment_type_enum"`
	Valid                       bool                        `json:"valid"` // Valid is true if WarehouseAttachmentTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseAttachmentTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseAttachmentTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseAttachmentTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseAttachmentTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseAttachmentTypeEnum), nil
}

type WarehouseFavoriteTypeEnum string

const (
	WarehouseFavoriteTypeEnumITEM      WarehouseFavoriteTypeEnum = "ITEM"
	WarehouseFavoriteTypeEnumLOCATION  WarehouseFavoriteTypeEnum = "LOCATION"
	WarehouseFavoriteTypeEnumCONTAINER WarehouseFavoriteTypeEnum = "CONTAINER"
)

func (e *WarehouseFavoriteTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseFavoriteTypeEnum(s)
	case string:
		*e = WarehouseFavoriteTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseFavoriteTypeEnum: %T", src)
	}
	return nil
}

type NullWarehouseFavoriteTypeEnum struct {
	WarehouseFavoriteTypeEnum WarehouseFavoriteTypeEnum `json:"warehouse_favorite_type_enum"`
	Valid                     bool                      `json:"valid"` // Valid is true if WarehouseFavoriteTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseFavoriteTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseFavoriteTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseFavoriteTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseFavoriteTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseFavoriteTypeEnum), nil
}

type WarehouseImportEntityEnum string

const (
	WarehouseImportEntityEnumItems      WarehouseImportEntityEnum = "items"
	WarehouseImportEntityEnumInventory  WarehouseImportEntityEnum = "inventory"
	WarehouseImportEntityEnumLocations  WarehouseImportEntityEnum = "locations"
	WarehouseImportEntityEnumContainers WarehouseImportEntityEnum = "containers"
	WarehouseImportEntityEnumCategories WarehouseImportEntityEnum = "categories"
	WarehouseImportEntityEnumBorrowers  WarehouseImportEntityEnum = "borrowers"
)

func (e *WarehouseImportEntityEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseImportEntityEnum(s)
	case string:
		*e = WarehouseImportEntityEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseImportEntityEnum: %T", src)
	}
	return nil
}

type NullWarehouseImportEntityEnum struct {
	WarehouseImportEntityEnum WarehouseImportEntityEnum `json:"warehouse_import_entity_enum"`
	Valid                     bool                      `json:"valid"` // Valid is true if WarehouseImportEntityEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseImportEntityEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseImportEntityEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseImportEntityEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseImportEntityEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseImportEntityEnum), nil
}

type WarehouseImportStatusEnum string

const (
	WarehouseImportStatusEnumPending    WarehouseImportStatusEnum = "pending"
	WarehouseImportStatusEnumProcessing WarehouseImportStatusEnum = "processing"
	WarehouseImportStatusEnumCompleted  WarehouseImportStatusEnum = "completed"
	WarehouseImportStatusEnumFailed     WarehouseImportStatusEnum = "failed"
	WarehouseImportStatusEnumCancelled  WarehouseImportStatusEnum = "cancelled"
)

func (e *WarehouseImportStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseImportStatusEnum(s)
	case string:
		*e = WarehouseImportStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseImportStatusEnum: %T", src)
	}
	return nil
}

type NullWarehouseImportStatusEnum struct {
	WarehouseImportStatusEnum WarehouseImportStatusEnum `json:"warehouse_import_status_enum"`
	Valid                     bool                      `json:"valid"` // Valid is true if WarehouseImportStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseImportStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseImportStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseImportStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseImportStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseImportStatusEnum), nil
}

type WarehouseItemConditionEnum string

const (
	WarehouseItemConditionEnumNEW       WarehouseItemConditionEnum = "NEW"
	WarehouseItemConditionEnumEXCELLENT WarehouseItemConditionEnum = "EXCELLENT"
	WarehouseItemConditionEnumGOOD      WarehouseItemConditionEnum = "GOOD"
	WarehouseItemConditionEnumFAIR      WarehouseItemConditionEnum = "FAIR"
	WarehouseItemConditionEnumPOOR      WarehouseItemConditionEnum = "POOR"
	WarehouseItemConditionEnumDAMAGED   WarehouseItemConditionEnum = "DAMAGED"
	WarehouseItemConditionEnumFORREPAIR WarehouseItemConditionEnum = "FOR_REPAIR"
)

func (e *WarehouseItemConditionEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseItemConditionEnum(s)
	case string:
		*e = WarehouseItemConditionEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseItemConditionEnum: %T", src)
	}
	return nil
}

type NullWarehouseItemConditionEnum struct {
	WarehouseItemConditionEnum WarehouseItemConditionEnum `json:"warehouse_item_condition_enum"`
	Valid                      bool                       `json:"valid"` // Valid is true if WarehouseItemConditionEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseItemConditionEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseItemConditionEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseItemConditionEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseItemConditionEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseItemConditionEnum), nil
}

type WarehouseItemStatusEnum string

const (
	WarehouseItemStatusEnumAVAILABLE WarehouseItemStatusEnum = "AVAILABLE"
	WarehouseItemStatusEnumINUSE     WarehouseItemStatusEnum = "IN_USE"
	WarehouseItemStatusEnumRESERVED  WarehouseItemStatusEnum = "RESERVED"
	WarehouseItemStatusEnumONLOAN    WarehouseItemStatusEnum = "ON_LOAN"
	WarehouseItemStatusEnumINTRANSIT WarehouseItemStatusEnum = "IN_TRANSIT"
	WarehouseItemStatusEnumDISPOSED  WarehouseItemStatusEnum = "DISPOSED"
	WarehouseItemStatusEnumMISSING   WarehouseItemStatusEnum = "MISSING"
)

func (e *WarehouseItemStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseItemStatusEnum(s)
	case string:
		*e = WarehouseItemStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseItemStatusEnum: %T", src)
	}
	return nil
}

type NullWarehouseItemStatusEnum struct {
	WarehouseItemStatusEnum WarehouseItemStatusEnum `json:"warehouse_item_status_enum"`
	Valid                   bool                    `json:"valid"` // Valid is true if WarehouseItemStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseItemStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseItemStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseItemStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseItemStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseItemStatusEnum), nil
}

type WarehousePendingChangeActionEnum string

const (
	WarehousePendingChangeActionEnumCreate WarehousePendingChangeActionEnum = "create"
	WarehousePendingChangeActionEnumUpdate WarehousePendingChangeActionEnum = "update"
	WarehousePendingChangeActionEnumDelete WarehousePendingChangeActionEnum = "delete"
)

func (e *WarehousePendingChangeActionEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehousePendingChangeActionEnum(s)
	case string:
		*e = WarehousePendingChangeActionEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehousePendingChangeActionEnum: %T", src)
	}
	return nil
}

type NullWarehousePendingChangeActionEnum struct {
	WarehousePendingChangeActionEnum WarehousePendingChangeActionEnum `json:"warehouse_pending_change_action_enum"`
	Valid                            bool                             `json:"valid"` // Valid is true if WarehousePendingChangeActionEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehousePendingChangeActionEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehousePendingChangeActionEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehousePendingChangeActionEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehousePendingChangeActionEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehousePendingChangeActionEnum), nil
}

type WarehousePendingChangeStatusEnum string

const (
	WarehousePendingChangeStatusEnumPending  WarehousePendingChangeStatusEnum = "pending"
	WarehousePendingChangeStatusEnumApproved WarehousePendingChangeStatusEnum = "approved"
	WarehousePendingChangeStatusEnumRejected WarehousePendingChangeStatusEnum = "rejected"
)

func (e *WarehousePendingChangeStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehousePendingChangeStatusEnum(s)
	case string:
		*e = WarehousePendingChangeStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehousePendingChangeStatusEnum: %T", src)
	}
	return nil
}

type NullWarehousePendingChangeStatusEnum struct {
	WarehousePendingChangeStatusEnum WarehousePendingChangeStatusEnum `json:"warehouse_pending_change_status_enum"`
	Valid                            bool                             `json:"valid"` // Valid is true if WarehousePendingChangeStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehousePendingChangeStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehousePendingChangeStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehousePendingChangeStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehousePendingChangeStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehousePendingChangeStatusEnum), nil
}

type WarehouseRepairPhotoTypeEnum string

const (
	WarehouseRepairPhotoTypeEnumBEFORE WarehouseRepairPhotoTypeEnum = "BEFORE"
	WarehouseRepairPhotoTypeEnumDURING WarehouseRepairPhotoTypeEnum = "DURING"
	WarehouseRepairPhotoTypeEnumAFTER  WarehouseRepairPhotoTypeEnum = "AFTER"
)

func (e *WarehouseRepairPhotoTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseRepairPhotoTypeEnum(s)
	case string:
		*e = WarehouseRepairPhotoTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseRepairPhotoTypeEnum: %T", src)
	}
	return nil
}

type NullWarehouseRepairPhotoTypeEnum struct {
	WarehouseRepairPhotoTypeEnum WarehouseRepairPhotoTypeEnum `json:"warehouse_repair_photo_type_enum"`
	Valid                        bool                         `json:"valid"` // Valid is true if WarehouseRepairPhotoTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseRepairPhotoTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseRepairPhotoTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseRepairPhotoTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseRepairPhotoTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseRepairPhotoTypeEnum), nil
}

type WarehouseRepairStatusEnum string

const (
	WarehouseRepairStatusEnumPENDING    WarehouseRepairStatusEnum = "PENDING"
	WarehouseRepairStatusEnumINPROGRESS WarehouseRepairStatusEnum = "IN_PROGRESS"
	WarehouseRepairStatusEnumCOMPLETED  WarehouseRepairStatusEnum = "COMPLETED"
)

func (e *WarehouseRepairStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseRepairStatusEnum(s)
	case string:
		*e = WarehouseRepairStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseRepairStatusEnum: %T", src)
	}
	return nil
}

type NullWarehouseRepairStatusEnum struct {
	WarehouseRepairStatusEnum WarehouseRepairStatusEnum `json:"warehouse_repair_status_enum"`
	Valid                     bool                      `json:"valid"` // Valid is true if WarehouseRepairStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseRepairStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseRepairStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseRepairStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseRepairStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseRepairStatusEnum), nil
}

type WarehouseTagTypeEnum string

const (
	WarehouseTagTypeEnumRFID WarehouseTagTypeEnum = "RFID"
	WarehouseTagTypeEnumNFC  WarehouseTagTypeEnum = "NFC"
	WarehouseTagTypeEnumQR   WarehouseTagTypeEnum = "QR"
)

func (e *WarehouseTagTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WarehouseTagTypeEnum(s)
	case string:
		*e = WarehouseTagTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WarehouseTagTypeEnum: %T", src)
	}
	return nil
}

type NullWarehouseTagTypeEnum struct {
	WarehouseTagTypeEnum WarehouseTagTypeEnum `json:"warehouse_tag_type_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if WarehouseTagTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWarehouseTagTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WarehouseTagTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WarehouseTagTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWarehouseTagTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WarehouseTagTypeEnum), nil
}

// User notifications for various events in the system.
type AuthNotification struct {
	ID               uuid.UUID                `json:"id"`
	UserID           uuid.UUID                `json:"user_id"`
	WorkspaceID      pgtype.UUID              `json:"workspace_id"`
	NotificationType AuthNotificationTypeEnum `json:"notification_type"`
	Title            string                   `json:"title"`
	Message          string                   `json:"message"`
	IsRead           *bool                    `json:"is_read"`
	ReadAt           pgtype.Timestamptz       `json:"read_at"`
	// Additional data like entity IDs, links, etc. stored as JSON.
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Password reset tokens with expiration and one-time use.
type AuthPasswordResetToken struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt time.Time          `json:"expires_at"`
	UsedAt    pgtype.Timestamptz `json:"used_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Web Push API subscriptions for sending push notifications to user devices.
type AuthPushSubscription struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
	// The push service URL where messages should be sent.
	Endpoint string `json:"endpoint"`
	// The client public key for message encryption (P-256 curve, base64 encoded).
	P256dh string `json:"p256dh"`
	// The authentication secret for message encryption (base64 encoded).
	Auth string `json:"auth"`
	// User agent string to identify the device/browser.
	UserAgent *string            `json:"user_agent"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type AuthUser struct {
	ID           uuid.UUID `json:"id"`
	Email        string    `json:"email"`
	FullName     string    `json:"full_name"`
	PasswordHash string    `json:"password_hash"`
	IsActive     *bool     `json:"is_active"`
	IsSuperuser  *bool     `json:"is_superuser"`
	// User's preferred date format for display (e.g., DD.MM.YYYY, MM/DD/YYYY, YYYY-MM-DD)
	DateFormat *string `json:"date_format"`
	// User's preferred language code (e.g., en, fi, de)
	Language string `json:"language"`
	// User's preferred UI theme: light, dark, or system
	Theme     string             `json:"theme"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// External OAuth provider accounts linked to local users for SSO.
type AuthUserOauthAccount struct {
	ID             uuid.UUID `json:"id"`
	UserID         uuid.UUID `json:"user_id"`
	Provider       string    `json:"provider"`
	ProviderUserID string    `json:"provider_user_id"`
	Email          *string   `json:"email"`
	DisplayName    *string   `json:"display_name"`
	AvatarUrl      *string   `json:"avatar_url"`
	// OAuth access token. Must be encrypted at application layer.
	AccessToken    *string            `json:"access_token"`
	RefreshToken   *string            `json:"refresh_token"`
	TokenExpiresAt pgtype.Timestamptz `json:"token_expires_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Isolated environments for organizing inventory. Each workspace has its own locations, items, etc.
type AuthWorkspace struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
	// URL-friendly identifier (e.g., "my-home", "office"). Used in URLs like /w/my-home/items
	Slug        string  `json:"slug"`
	Description *string `json:"description"`
	// Whether this is a user's personal workspace created during registration.
	IsPersonal bool               `json:"is_personal"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// Per-workspace Docspell integration configuration. Each workspace can connect to a different Docspell instance.
type AuthWorkspaceDocspellSetting struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
	BaseUrl     string    `json:"base_url"`
	// Docspell collective name - equivalent to a tenant/organization in Docspell.
	CollectiveName string `json:"collective_name"`
	Username       string `json:"username"`
	// Encrypted password for Docspell authentication. Encrypted at application layer using Fernet.
	PasswordEncrypted string             `json:"password_encrypted"`
	SyncTagsEnabled   *bool              `json:"sync_tags_enabled"`
	IsEnabled         *bool              `json:"is_enabled"`
	LastSyncAt        pgtype.Timestamptz `json:"last_sync_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Audit log of workspace data exports for backup or migration.
type AuthWorkspaceExport struct {
	ID            uuid.UUID   `json:"id"`
	WorkspaceID   uuid.UUID   `json:"workspace_id"`
	ExportedBy    pgtype.UUID `json:"exported_by"`
	Format        string      `json:"format"`
	FileSizeBytes *int64      `json:"file_size_bytes"`
	// Snapshot of how many records were exported per table, stored as JSON.
	RecordCounts []byte             `json:"record_counts"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Links users to workspaces with role-based access control.
type AuthWorkspaceMember struct {
	ID          uuid.UUID             `json:"id"`
	WorkspaceID uuid.UUID             `json:"workspace_id"`
	UserID      uuid.UUID             `json:"user_id"`
	Role        AuthWorkspaceRoleEnum `json:"role"`
	InvitedBy   pgtype.UUID           `json:"invited_by"`
	CreatedAt   pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz    `json:"updated_at"`
}

// Audit trail of all changes to warehouse data.
type WarehouseActivityLog struct {
	ID          uuid.UUID                   `json:"id"`
	WorkspaceID uuid.UUID                   `json:"workspace_id"`
	UserID      pgtype.UUID                 `json:"user_id"`
	Action      WarehouseActivityActionEnum `json:"action"`
	EntityType  WarehouseActivityEntityEnum `json:"entity_type"`
	EntityID    uuid.UUID                   `json:"entity_id"`
	// Cached name of entity for display even after deletion.
	EntityName *string `json:"entity_name"`
	// JSON object with changed fields: {"field": {"old": "value", "new": "value"}}
	Changes   []byte             `json:"changes"`
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type WarehouseAttachment struct {
	ID             uuid.UUID                   `json:"id"`
	ItemID         uuid.UUID                   `json:"item_id"`
	FileID         pgtype.UUID                 `json:"file_id"`
	AttachmentType WarehouseAttachmentTypeEnum `json:"attachment_type"`
	// Optional short description. Falls back to file.original_name if not provided.
	Title     *string `json:"title"`
	IsPrimary *bool   `json:"is_primary"`
	// Reference to Docspell item ID. When set, document is managed by Docspell and file_id may be NULL.
	DocspellItemID *string            `json:"docspell_item_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

type WarehouseBorrower struct {
	ID           uuid.UUID          `json:"id"`
	WorkspaceID  uuid.UUID          `json:"workspace_id"`
	Name         string             `json:"name"`
	Email        *string            `json:"email"`
	Phone        *string            `json:"phone"`
	Notes        *string            `json:"notes"`
	IsArchived   bool               `json:"is_archived"`
	SearchVector interface{}        `json:"search_vector"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

type WarehouseCategory struct {
	ID               uuid.UUID          `json:"id"`
	WorkspaceID      uuid.UUID          `json:"workspace_id"`
	Name             string             `json:"name"`
	ParentCategoryID pgtype.UUID        `json:"parent_category_id"`
	Description      *string            `json:"description"`
	IsArchived       bool               `json:"is_archived"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

type WarehouseCompany struct {
	ID          uuid.UUID          `json:"id"`
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	Name        string             `json:"name"`
	Website     *string            `json:"website"`
	Notes       *string            `json:"notes"`
	IsArchived  bool               `json:"is_archived"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type WarehouseContainer struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Name        string    `json:"name"`
	LocationID  uuid.UUID `json:"location_id"`
	Description *string   `json:"description"`
	Capacity    *string   `json:"capacity"`
	// Short alphanumeric code for QR labels. Unique within workspace. Auto-generated if not provided.
	ShortCode    string             `json:"short_code"`
	IsArchived   bool               `json:"is_archived"`
	SearchVector interface{}        `json:"search_vector"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

type WarehouseContainerTag struct {
	ID          uuid.UUID            `json:"id"`
	ContainerID uuid.UUID            `json:"container_id"`
	TagType     WarehouseTagTypeEnum `json:"tag_type"`
	TagValue    string               `json:"tag_value"`
	CreatedAt   pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz   `json:"updated_at"`
}

// Tombstone table tracking hard-deleted records for PWA offline sync.
type WarehouseDeletedRecord struct {
	ID          uuid.UUID                   `json:"id"`
	WorkspaceID uuid.UUID                   `json:"workspace_id"`
	EntityType  WarehouseActivityEntityEnum `json:"entity_type"`
	EntityID    uuid.UUID                   `json:"entity_id"`
	DeletedAt   time.Time                   `json:"deleted_at"`
	DeletedBy   pgtype.UUID                 `json:"deleted_by"`
}

// User-pinned items, locations, or containers for quick access.
type WarehouseFavorite struct {
	ID           uuid.UUID                 `json:"id"`
	UserID       uuid.UUID                 `json:"user_id"`
	WorkspaceID  uuid.UUID                 `json:"workspace_id"`
	FavoriteType WarehouseFavoriteTypeEnum `json:"favorite_type"`
	ItemID       pgtype.UUID               `json:"item_id"`
	LocationID   pgtype.UUID               `json:"location_id"`
	ContainerID  pgtype.UUID               `json:"container_id"`
	CreatedAt    pgtype.Timestamptz        `json:"created_at"`
}

type WarehouseFile struct {
	ID           uuid.UUID `json:"id"`
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	OriginalName string    `json:"original_name"`
	Extension    *string   `json:"extension"`
	MimeType     *string   `json:"mime_type"`
	SizeBytes    *int64    `json:"size_bytes"`
	Checksum     *string   `json:"checksum"`
	// Storage backend reference (S3 key, filesystem path, etc.)
	StorageKey *string            `json:"storage_key"`
	UploadedBy pgtype.UUID        `json:"uploaded_by"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

type WarehouseImportError struct {
	ID           uuid.UUID `json:"id"`
	ImportJobID  uuid.UUID `json:"import_job_id"`
	RowNumber    int32     `json:"row_number"`
	FieldName    *string   `json:"field_name"`
	ErrorMessage string    `json:"error_message"`
	RowData      []byte    `json:"row_data"`
	CreatedAt    time.Time `json:"created_at"`
}

type WarehouseImportJob struct {
	ID            uuid.UUID                 `json:"id"`
	WorkspaceID   uuid.UUID                 `json:"workspace_id"`
	UserID        uuid.UUID                 `json:"user_id"`
	EntityType    WarehouseImportEntityEnum `json:"entity_type"`
	Status        WarehouseImportStatusEnum `json:"status"`
	FileName      string                    `json:"file_name"`
	FilePath      string                    `json:"file_path"`
	FileSizeBytes int64                     `json:"file_size_bytes"`
	TotalRows     *int32                    `json:"total_rows"`
	ProcessedRows int32                     `json:"processed_rows"`
	SuccessCount  int32                     `json:"success_count"`
	ErrorCount    int32                     `json:"error_count"`
	StartedAt     pgtype.Timestamptz        `json:"started_at"`
	CompletedAt   pgtype.Timestamptz        `json:"completed_at"`
	CreatedAt     time.Time                 `json:"created_at"`
	UpdatedAt     time.Time                 `json:"updated_at"`
	ErrorMessage  *string                   `json:"error_message"`
}

type WarehouseInventory struct {
	ID              uuid.UUID                      `json:"id"`
	WorkspaceID     uuid.UUID                      `json:"workspace_id"`
	ItemID          uuid.UUID                      `json:"item_id"`
	LocationID      uuid.UUID                      `json:"location_id"`
	ContainerID     pgtype.UUID                    `json:"container_id"`
	Quantity        int32                          `json:"quantity"`
	Condition       NullWarehouseItemConditionEnum `json:"condition"`
	Status          NullWarehouseItemStatusEnum    `json:"status"`
	DateAcquired    pgtype.Date                    `json:"date_acquired"`
	PurchasePrice   *int32                         `json:"purchase_price"`
	CurrencyCode    *string                        `json:"currency_code"`
	WarrantyExpires pgtype.Date                    `json:"warranty_expires"`
	ExpirationDate  pgtype.Date                    `json:"expiration_date"`
	Notes           *string                        `json:"notes"`
	IsArchived      bool                           `json:"is_archived"`
	CreatedAt       pgtype.Timestamptz             `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz             `json:"updated_at"`
	// Timestamp when this inventory was last marked as "used". Used for declutter assistant. Defaults to created_at for existing records.
	LastUsedAt pgtype.Timestamptz `json:"last_used_at"`
}

type WarehouseInventoryMovement struct {
	ID              uuid.UUID          `json:"id"`
	WorkspaceID     uuid.UUID          `json:"workspace_id"`
	InventoryID     uuid.UUID          `json:"inventory_id"`
	FromLocationID  pgtype.UUID        `json:"from_location_id"`
	FromContainerID pgtype.UUID        `json:"from_container_id"`
	ToLocationID    pgtype.UUID        `json:"to_location_id"`
	ToContainerID   pgtype.UUID        `json:"to_container_id"`
	Quantity        int32              `json:"quantity"`
	MovedBy         pgtype.UUID        `json:"moved_by"`
	Reason          *string            `json:"reason"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

type WarehouseItem struct {
	ID           uuid.UUID   `json:"id"`
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	Sku          string      `json:"sku"`
	Name         string      `json:"name"`
	Description  *string     `json:"description"`
	CategoryID   pgtype.UUID `json:"category_id"`
	Brand        *string     `json:"brand"`
	Model        *string     `json:"model"`
	ImageUrl     *string     `json:"image_url"`
	SerialNumber *string     `json:"serial_number"`
	Manufacturer *string     `json:"manufacturer"`
	// UPC/EAN/other product barcode for scanning.
	Barcode          *string     `json:"barcode"`
	IsInsured        *bool       `json:"is_insured"`
	IsArchived       *bool       `json:"is_archived"`
	LifetimeWarranty *bool       `json:"lifetime_warranty"`
	WarrantyDetails  *string     `json:"warranty_details"`
	PurchasedFrom    pgtype.UUID `json:"purchased_from"`
	// Threshold for LOW_STOCK notifications. When total inventory falls below this, trigger alert.
	MinStockLevel int32 `json:"min_stock_level"`
	// Short alphanumeric code for QR labels. Unique within workspace. Auto-generated if not provided.
	ShortCode string `json:"short_code"`
	// Local path to Obsidian vault for linking notes.
	ObsidianVaultPath *string `json:"obsidian_vault_path"`
	// Relative path to note within vault.
	ObsidianNotePath *string            `json:"obsidian_note_path"`
	SearchVector     interface{}        `json:"search_vector"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

type WarehouseItemLabel struct {
	ItemID  uuid.UUID `json:"item_id"`
	LabelID uuid.UUID `json:"label_id"`
}

type WarehouseItemPhoto struct {
	ID            uuid.UUID `json:"id"`
	ItemID        uuid.UUID `json:"item_id"`
	WorkspaceID   uuid.UUID `json:"workspace_id"`
	Filename      string    `json:"filename"`
	StoragePath   string    `json:"storage_path"`
	ThumbnailPath string    `json:"thumbnail_path"`
	FileSize      int64     `json:"file_size"`
	MimeType      string    `json:"mime_type"`
	Width         int32     `json:"width"`
	Height        int32     `json:"height"`
	DisplayOrder  int32     `json:"display_order"`
	IsPrimary     bool      `json:"is_primary"`
	Caption       *string   `json:"caption"`
	UploadedBy    uuid.UUID `json:"uploaded_by"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	// Thumbnail generation status: pending (not started), processing (in queue), complete (ready), failed (max retries exceeded)
	ThumbnailStatus string `json:"thumbnail_status"`
	// Path to 150px thumbnail (used for lists/grids)
	ThumbnailSmallPath *string `json:"thumbnail_small_path"`
	// Path to 400px thumbnail (used for detail views)
	ThumbnailMediumPath *string `json:"thumbnail_medium_path"`
	// Path to 800px thumbnail (used for lightbox/preview)
	ThumbnailLargePath *string `json:"thumbnail_large_path"`
	// Number of thumbnail generation attempts (max 5 before marked failed)
	ThumbnailAttempts int32 `json:"thumbnail_attempts"`
	// Last error message if thumbnail generation failed
	ThumbnailError *string `json:"thumbnail_error"`
}

type WarehouseLabel struct {
	ID          uuid.UUID          `json:"id"`
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	Name        string             `json:"name"`
	Color       *string            `json:"color"`
	Description *string            `json:"description"`
	IsArchived  bool               `json:"is_archived"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type WarehouseLoan struct {
	ID          uuid.UUID          `json:"id"`
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	InventoryID uuid.UUID          `json:"inventory_id"`
	BorrowerID  uuid.UUID          `json:"borrower_id"`
	Quantity    int32              `json:"quantity"`
	LoanedAt    pgtype.Timestamptz `json:"loaned_at"`
	DueDate     pgtype.Date        `json:"due_date"`
	ReturnedAt  pgtype.Timestamptz `json:"returned_at"`
	Notes       *string            `json:"notes"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type WarehouseLocation struct {
	ID             uuid.UUID   `json:"id"`
	WorkspaceID    uuid.UUID   `json:"workspace_id"`
	Name           string      `json:"name"`
	ParentLocation pgtype.UUID `json:"parent_location"`
	Description    *string     `json:"description"`
	// Short alphanumeric code for QR labels. Unique within workspace. Auto-generated if not provided.
	ShortCode    string             `json:"short_code"`
	IsArchived   bool               `json:"is_archived"`
	SearchVector interface{}        `json:"search_vector"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

type WarehousePendingChange struct {
	ID              uuid.UUID                        `json:"id"`
	WorkspaceID     uuid.UUID                        `json:"workspace_id"`
	RequesterID     uuid.UUID                        `json:"requester_id"`
	EntityType      string                           `json:"entity_type"`
	EntityID        pgtype.UUID                      `json:"entity_id"`
	Action          WarehousePendingChangeActionEnum `json:"action"`
	Payload         []byte                           `json:"payload"`
	Status          WarehousePendingChangeStatusEnum `json:"status"`
	ReviewedBy      pgtype.UUID                      `json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz               `json:"reviewed_at"`
	RejectionReason *string                          `json:"rejection_reason"`
	CreatedAt       time.Time                        `json:"created_at"`
	UpdatedAt       time.Time                        `json:"updated_at"`
}

// Links repair logs to uploaded files (receipts, invoices, warranty documents).
type WarehouseRepairAttachment struct {
	ID             uuid.UUID                   `json:"id"`
	RepairLogID    uuid.UUID                   `json:"repair_log_id"`
	WorkspaceID    uuid.UUID                   `json:"workspace_id"`
	FileID         uuid.UUID                   `json:"file_id"`
	AttachmentType WarehouseAttachmentTypeEnum `json:"attachment_type"`
	Title          *string                     `json:"title"`
	CreatedAt      time.Time                   `json:"created_at"`
	UpdatedAt      time.Time                   `json:"updated_at"`
}

// Tracks repair history for inventory items. Status workflow: PENDING -> IN_PROGRESS -> COMPLETED.
type WarehouseRepairLog struct {
	ID          uuid.UUID                 `json:"id"`
	WorkspaceID uuid.UUID                 `json:"workspace_id"`
	InventoryID uuid.UUID                 `json:"inventory_id"`
	Status      WarehouseRepairStatusEnum `json:"status"`
	Description string                    `json:"description"`
	RepairDate  pgtype.Date               `json:"repair_date"`
	// Repair cost in cents for the specified currency.
	Cost            *int32  `json:"cost"`
	CurrencyCode    *string `json:"currency_code"`
	ServiceProvider *string `json:"service_provider"`
	// Timestamp when the repair status was set to COMPLETED.
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	// The condition to set on the inventory item when the repair is completed.
	NewCondition NullWarehouseItemConditionEnum `json:"new_condition"`
	Notes        *string                        `json:"notes"`
	CreatedAt    pgtype.Timestamptz             `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz             `json:"updated_at"`
	// Whether this repair was covered under warranty.
	IsWarrantyClaim bool `json:"is_warranty_claim"`
	// Optional future date for maintenance reminder notification.
	ReminderDate pgtype.Date `json:"reminder_date"`
	// Whether the reminder notification has been sent.
	ReminderSent bool `json:"reminder_sent"`
}

// Photos attached to repair logs, categorized by when they were taken (before/during/after repair).
type WarehouseRepairPhoto struct {
	ID          uuid.UUID `json:"id"`
	RepairLogID uuid.UUID `json:"repair_log_id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
	// Categorizes when the photo was taken: BEFORE repair, DURING the repair process, or AFTER completion.
	PhotoType     WarehouseRepairPhotoTypeEnum `json:"photo_type"`
	Filename      string                       `json:"filename"`
	StoragePath   string                       `json:"storage_path"`
	ThumbnailPath string                       `json:"thumbnail_path"`
	FileSize      int64                        `json:"file_size"`
	MimeType      string                       `json:"mime_type"`
	Width         int32                        `json:"width"`
	Height        int32                        `json:"height"`
	DisplayOrder  int32                        `json:"display_order"`
	Caption       *string                      `json:"caption"`
	UploadedBy    uuid.UUID                    `json:"uploaded_by"`
	CreatedAt     time.Time                    `json:"created_at"`
	UpdatedAt     time.Time                    `json:"updated_at"`
}

// All soft-deleted records across entity types for restoration UI.
type WarehouseVArchivedRecord struct {
	EntityType  string             `json:"entity_type"`
	ID          uuid.UUID          `json:"id"`
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	Name        string             `json:"name"`
	ArchivedAt  pgtype.Timestamptz `json:"archived_at"`
}
