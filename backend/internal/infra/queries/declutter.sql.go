// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: declutter.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUnusedInventory = `-- name: CountUnusedInventory :one
SELECT COUNT(*)::int as total
FROM warehouse.inventory inv
WHERE inv.workspace_id = $1
  AND inv.is_archived = false
  AND COALESCE(inv.last_used_at, inv.created_at) < NOW() - make_interval(days => $2)
`

type CountUnusedInventoryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Days        int32     `json:"days"`
}

// Counts total unused inventory for pagination
func (q *Queries) CountUnusedInventory(ctx context.Context, arg CountUnusedInventoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, countUnusedInventory, arg.WorkspaceID, arg.Days)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const getMaxInventoryValue = `-- name: GetMaxInventoryValue :one
SELECT COALESCE(MAX(purchase_price), 0)::int as max_value
FROM warehouse.inventory
WHERE workspace_id = $1 AND is_archived = false
`

// Returns the maximum purchase price in workspace for percentile calculation
func (q *Queries) GetMaxInventoryValue(ctx context.Context, workspaceID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getMaxInventoryValue, workspaceID)
	var max_value int32
	err := row.Scan(&max_value)
	return max_value, err
}

const getUnusedInventoryCounts = `-- name: GetUnusedInventoryCounts :one
SELECT
    COUNT(*) FILTER (WHERE COALESCE(last_used_at, created_at) < NOW() - interval '90 days')::int as unused_90,
    COUNT(*) FILTER (WHERE COALESCE(last_used_at, created_at) < NOW() - interval '180 days')::int as unused_180,
    COUNT(*) FILTER (WHERE COALESCE(last_used_at, created_at) < NOW() - interval '365 days')::int as unused_365,
    COALESCE(SUM(purchase_price) FILTER (WHERE COALESCE(last_used_at, created_at) < NOW() - interval '90 days'), 0)::bigint as value_90,
    COALESCE(SUM(purchase_price) FILTER (WHERE COALESCE(last_used_at, created_at) < NOW() - interval '180 days'), 0)::bigint as value_180,
    COALESCE(SUM(purchase_price) FILTER (WHERE COALESCE(last_used_at, created_at) < NOW() - interval '365 days'), 0)::bigint as value_365
FROM warehouse.inventory
WHERE workspace_id = $1 AND is_archived = false
`

type GetUnusedInventoryCountsRow struct {
	Unused90  int32 `json:"unused_90"`
	Unused180 int32 `json:"unused_180"`
	Unused365 int32 `json:"unused_365"`
	Value90   int64 `json:"value_90"`
	Value180  int64 `json:"value_180"`
	Value365  int64 `json:"value_365"`
}

// Returns summary counts for different thresholds (90/180/365 days)
// Used for dashboard summary display
func (q *Queries) GetUnusedInventoryCounts(ctx context.Context, workspaceID uuid.UUID) (GetUnusedInventoryCountsRow, error) {
	row := q.db.QueryRow(ctx, getUnusedInventoryCounts, workspaceID)
	var i GetUnusedInventoryCountsRow
	err := row.Scan(
		&i.Unused90,
		&i.Unused180,
		&i.Unused365,
		&i.Value90,
		&i.Value180,
		&i.Value365,
	)
	return i, err
}

const listUnusedInventory = `-- name: ListUnusedInventory :many

SELECT
    inv.id,
    inv.workspace_id,
    inv.item_id,
    inv.location_id,
    inv.container_id,
    inv.quantity,
    inv.condition,
    inv.status,
    inv.purchase_price,
    inv.currency_code,
    inv.last_used_at,
    inv.created_at,
    inv.updated_at,
    it.name as item_name,
    it.sku as item_sku,
    l.name as location_name,
    c.name as category_name,
    c.id as category_id,
    EXTRACT(DAY FROM (NOW() - COALESCE(inv.last_used_at, inv.created_at)))::int as days_unused
FROM warehouse.inventory inv
JOIN warehouse.items it ON inv.item_id = it.id
JOIN warehouse.locations l ON inv.location_id = l.id
LEFT JOIN warehouse.categories c ON it.category_id = c.id
WHERE inv.workspace_id = $1
  AND inv.is_archived = false
  AND COALESCE(inv.last_used_at, inv.created_at) < NOW() - make_interval(days => $2)
ORDER BY
    CASE WHEN $5::text = 'category' THEN c.name END NULLS LAST,
    CASE WHEN $5::text = 'location' THEN l.name END NULLS LAST,
    days_unused DESC
LIMIT $3 OFFSET $4
`

type ListUnusedInventoryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Days        int32     `json:"days"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
	GroupBy     string    `json:"group_by"`
}

type ListUnusedInventoryRow struct {
	ID            uuid.UUID                      `json:"id"`
	WorkspaceID   uuid.UUID                      `json:"workspace_id"`
	ItemID        uuid.UUID                      `json:"item_id"`
	LocationID    uuid.UUID                      `json:"location_id"`
	ContainerID   pgtype.UUID                    `json:"container_id"`
	Quantity      int32                          `json:"quantity"`
	Condition     NullWarehouseItemConditionEnum `json:"condition"`
	Status        NullWarehouseItemStatusEnum    `json:"status"`
	PurchasePrice *int32                         `json:"purchase_price"`
	CurrencyCode  *string                        `json:"currency_code"`
	LastUsedAt    pgtype.Timestamptz             `json:"last_used_at"`
	CreatedAt     pgtype.Timestamptz             `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz             `json:"updated_at"`
	ItemName      string                         `json:"item_name"`
	ItemSku       string                         `json:"item_sku"`
	LocationName  string                         `json:"location_name"`
	CategoryName  *string                        `json:"category_name"`
	CategoryID    pgtype.UUID                    `json:"category_id"`
	DaysUnused    int32                          `json:"days_unused"`
}

// Declutter Assistant Queries
// These queries support the declutter feature for identifying unused inventory
// Lists inventory items unused for specified threshold days
// Supports grouping by category or location for organized display
func (q *Queries) ListUnusedInventory(ctx context.Context, arg ListUnusedInventoryParams) ([]ListUnusedInventoryRow, error) {
	rows, err := q.db.Query(ctx, listUnusedInventory,
		arg.WorkspaceID,
		arg.Days,
		arg.Limit,
		arg.Offset,
		arg.GroupBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUnusedInventoryRow{}
	for rows.Next() {
		var i ListUnusedInventoryRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ItemID,
			&i.LocationID,
			&i.ContainerID,
			&i.Quantity,
			&i.Condition,
			&i.Status,
			&i.PurchasePrice,
			&i.CurrencyCode,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ItemName,
			&i.ItemSku,
			&i.LocationName,
			&i.CategoryName,
			&i.CategoryID,
			&i.DaysUnused,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInventoryUsed = `-- name: MarkInventoryUsed :one
UPDATE warehouse.inventory
SET last_used_at = NOW(), updated_at = NOW()
WHERE id = $1 AND workspace_id = $2
RETURNING id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at, last_used_at
`

type MarkInventoryUsedParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

// Atomically updates last_used_at to current time
func (q *Queries) MarkInventoryUsed(ctx context.Context, arg MarkInventoryUsedParams) (WarehouseInventory, error) {
	row := q.db.QueryRow(ctx, markInventoryUsed, arg.ID, arg.WorkspaceID)
	var i WarehouseInventory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.Quantity,
		&i.Condition,
		&i.Status,
		&i.DateAcquired,
		&i.PurchasePrice,
		&i.CurrencyCode,
		&i.WarrantyExpires,
		&i.ExpirationDate,
		&i.Notes,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}
