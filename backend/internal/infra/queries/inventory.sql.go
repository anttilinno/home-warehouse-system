// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const archiveInventory = `-- name: ArchiveInventory :exec
UPDATE warehouse.inventory
SET is_archived = true, updated_at = now()
WHERE id = $1
`

func (q *Queries) ArchiveInventory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, archiveInventory, id)
	return err
}

const createInventory = `-- name: CreateInventory :one
INSERT INTO warehouse.inventory (
    id, workspace_id, item_id, location_id, container_id, quantity,
    condition, status, date_acquired, purchase_price, currency_code,
    warranty_expires, expiration_date, notes
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at
`

type CreateInventoryParams struct {
	ID              uuid.UUID                      `json:"id"`
	WorkspaceID     uuid.UUID                      `json:"workspace_id"`
	ItemID          uuid.UUID                      `json:"item_id"`
	LocationID      uuid.UUID                      `json:"location_id"`
	ContainerID     pgtype.UUID                    `json:"container_id"`
	Quantity        int32                          `json:"quantity"`
	Condition       NullWarehouseItemConditionEnum `json:"condition"`
	Status          NullWarehouseItemStatusEnum    `json:"status"`
	DateAcquired    pgtype.Date                    `json:"date_acquired"`
	PurchasePrice   *int32                         `json:"purchase_price"`
	CurrencyCode    *string                        `json:"currency_code"`
	WarrantyExpires pgtype.Date                    `json:"warranty_expires"`
	ExpirationDate  pgtype.Date                    `json:"expiration_date"`
	Notes           *string                        `json:"notes"`
}

func (q *Queries) CreateInventory(ctx context.Context, arg CreateInventoryParams) (WarehouseInventory, error) {
	row := q.db.QueryRow(ctx, createInventory,
		arg.ID,
		arg.WorkspaceID,
		arg.ItemID,
		arg.LocationID,
		arg.ContainerID,
		arg.Quantity,
		arg.Condition,
		arg.Status,
		arg.DateAcquired,
		arg.PurchasePrice,
		arg.CurrencyCode,
		arg.WarrantyExpires,
		arg.ExpirationDate,
		arg.Notes,
	)
	var i WarehouseInventory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.Quantity,
		&i.Condition,
		&i.Status,
		&i.DateAcquired,
		&i.PurchasePrice,
		&i.CurrencyCode,
		&i.WarrantyExpires,
		&i.ExpirationDate,
		&i.Notes,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAvailableInventory = `-- name: GetAvailableInventory :many
SELECT id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at FROM warehouse.inventory
WHERE workspace_id = $1 AND item_id = $2 AND status = 'AVAILABLE' AND is_archived = false
`

type GetAvailableInventoryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	ItemID      uuid.UUID `json:"item_id"`
}

func (q *Queries) GetAvailableInventory(ctx context.Context, arg GetAvailableInventoryParams) ([]WarehouseInventory, error) {
	rows, err := q.db.Query(ctx, getAvailableInventory, arg.WorkspaceID, arg.ItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseInventory{}
	for rows.Next() {
		var i WarehouseInventory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ItemID,
			&i.LocationID,
			&i.ContainerID,
			&i.Quantity,
			&i.Condition,
			&i.Status,
			&i.DateAcquired,
			&i.PurchasePrice,
			&i.CurrencyCode,
			&i.WarrantyExpires,
			&i.ExpirationDate,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventory = `-- name: GetInventory :one
SELECT id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at FROM warehouse.inventory
WHERE id = $1 AND workspace_id = $2
`

type GetInventoryParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetInventory(ctx context.Context, arg GetInventoryParams) (WarehouseInventory, error) {
	row := q.db.QueryRow(ctx, getInventory, arg.ID, arg.WorkspaceID)
	var i WarehouseInventory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.Quantity,
		&i.Condition,
		&i.Status,
		&i.DateAcquired,
		&i.PurchasePrice,
		&i.CurrencyCode,
		&i.WarrantyExpires,
		&i.ExpirationDate,
		&i.Notes,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryWithDetails = `-- name: GetInventoryWithDetails :one
SELECT i.id, i.workspace_id, i.item_id, i.location_id, i.container_id, i.quantity, i.condition, i.status, i.date_acquired, i.purchase_price, i.currency_code, i.warranty_expires, i.expiration_date, i.notes, i.is_archived, i.created_at, i.updated_at, it.name as item_name, it.sku, l.name as location_name, c.name as container_name
FROM warehouse.inventory i
JOIN warehouse.items it ON i.item_id = it.id
JOIN warehouse.locations l ON i.location_id = l.id
LEFT JOIN warehouse.containers c ON i.container_id = c.id
WHERE i.id = $1 AND i.workspace_id = $2
`

type GetInventoryWithDetailsParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type GetInventoryWithDetailsRow struct {
	ID              uuid.UUID                      `json:"id"`
	WorkspaceID     uuid.UUID                      `json:"workspace_id"`
	ItemID          uuid.UUID                      `json:"item_id"`
	LocationID      uuid.UUID                      `json:"location_id"`
	ContainerID     pgtype.UUID                    `json:"container_id"`
	Quantity        int32                          `json:"quantity"`
	Condition       NullWarehouseItemConditionEnum `json:"condition"`
	Status          NullWarehouseItemStatusEnum    `json:"status"`
	DateAcquired    pgtype.Date                    `json:"date_acquired"`
	PurchasePrice   *int32                         `json:"purchase_price"`
	CurrencyCode    *string                        `json:"currency_code"`
	WarrantyExpires pgtype.Date                    `json:"warranty_expires"`
	ExpirationDate  pgtype.Date                    `json:"expiration_date"`
	Notes           *string                        `json:"notes"`
	IsArchived      bool                           `json:"is_archived"`
	CreatedAt       pgtype.Timestamptz             `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz             `json:"updated_at"`
	ItemName        string                         `json:"item_name"`
	Sku             string                         `json:"sku"`
	LocationName    string                         `json:"location_name"`
	ContainerName   *string                        `json:"container_name"`
}

func (q *Queries) GetInventoryWithDetails(ctx context.Context, arg GetInventoryWithDetailsParams) (GetInventoryWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getInventoryWithDetails, arg.ID, arg.WorkspaceID)
	var i GetInventoryWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.Quantity,
		&i.Condition,
		&i.Status,
		&i.DateAcquired,
		&i.PurchasePrice,
		&i.CurrencyCode,
		&i.WarrantyExpires,
		&i.ExpirationDate,
		&i.Notes,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ItemName,
		&i.Sku,
		&i.LocationName,
		&i.ContainerName,
	)
	return i, err
}

const getLowStockItems = `-- name: GetLowStockItems :many
SELECT i.id, i.name, i.min_stock_level, COALESCE(SUM(inv.quantity), 0)::int as current_stock
FROM warehouse.items i
LEFT JOIN warehouse.inventory inv ON i.id = inv.item_id AND inv.is_archived = false
WHERE i.workspace_id = $1 AND i.is_archived = false AND i.min_stock_level > 0
GROUP BY i.id, i.name, i.min_stock_level
HAVING COALESCE(SUM(inv.quantity), 0) < i.min_stock_level
`

type GetLowStockItemsRow struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	MinStockLevel int32     `json:"min_stock_level"`
	CurrentStock  int32     `json:"current_stock"`
}

func (q *Queries) GetLowStockItems(ctx context.Context, workspaceID uuid.UUID) ([]GetLowStockItemsRow, error) {
	rows, err := q.db.Query(ctx, getLowStockItems, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLowStockItemsRow{}
	for rows.Next() {
		var i GetLowStockItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MinStockLevel,
			&i.CurrentStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutOfStockItems = `-- name: GetOutOfStockItems :many
SELECT i.id, i.name, i.sku, i.min_stock_level, c.id as category_id, c.name as category_name
FROM warehouse.items i
LEFT JOIN warehouse.inventory inv ON i.id = inv.item_id AND inv.is_archived = false
LEFT JOIN warehouse.categories c ON i.category_id = c.id
WHERE i.workspace_id = $1 AND i.is_archived = false
GROUP BY i.id, i.name, i.sku, i.min_stock_level, c.id, c.name
HAVING COALESCE(SUM(inv.quantity), 0) = 0
`

type GetOutOfStockItemsRow struct {
	ID            uuid.UUID   `json:"id"`
	Name          string      `json:"name"`
	Sku           string      `json:"sku"`
	MinStockLevel int32       `json:"min_stock_level"`
	CategoryID    pgtype.UUID `json:"category_id"`
	CategoryName  *string     `json:"category_name"`
}

// Returns items that are completely out of stock (total quantity = 0)
// These are consumables that need restocking
func (q *Queries) GetOutOfStockItems(ctx context.Context, workspaceID uuid.UUID) ([]GetOutOfStockItemsRow, error) {
	rows, err := q.db.Query(ctx, getOutOfStockItems, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOutOfStockItemsRow{}
	for rows.Next() {
		var i GetOutOfStockItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.MinStockLevel,
			&i.CategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalQuantityByItem = `-- name: GetTotalQuantityByItem :one
SELECT COALESCE(SUM(quantity), 0)::int as total
FROM warehouse.inventory
WHERE workspace_id = $1 AND item_id = $2 AND is_archived = false
`

type GetTotalQuantityByItemParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	ItemID      uuid.UUID `json:"item_id"`
}

func (q *Queries) GetTotalQuantityByItem(ctx context.Context, arg GetTotalQuantityByItemParams) (int32, error) {
	row := q.db.QueryRow(ctx, getTotalQuantityByItem, arg.WorkspaceID, arg.ItemID)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const listInventoryByContainer = `-- name: ListInventoryByContainer :many
SELECT id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at FROM warehouse.inventory
WHERE workspace_id = $1 AND container_id = $2 AND is_archived = false
ORDER BY created_at DESC
`

type ListInventoryByContainerParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	ContainerID pgtype.UUID `json:"container_id"`
}

func (q *Queries) ListInventoryByContainer(ctx context.Context, arg ListInventoryByContainerParams) ([]WarehouseInventory, error) {
	rows, err := q.db.Query(ctx, listInventoryByContainer, arg.WorkspaceID, arg.ContainerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseInventory{}
	for rows.Next() {
		var i WarehouseInventory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ItemID,
			&i.LocationID,
			&i.ContainerID,
			&i.Quantity,
			&i.Condition,
			&i.Status,
			&i.DateAcquired,
			&i.PurchasePrice,
			&i.CurrencyCode,
			&i.WarrantyExpires,
			&i.ExpirationDate,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryByItem = `-- name: ListInventoryByItem :many
SELECT id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at FROM warehouse.inventory
WHERE workspace_id = $1 AND item_id = $2 AND is_archived = false
ORDER BY created_at DESC
`

type ListInventoryByItemParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	ItemID      uuid.UUID `json:"item_id"`
}

func (q *Queries) ListInventoryByItem(ctx context.Context, arg ListInventoryByItemParams) ([]WarehouseInventory, error) {
	rows, err := q.db.Query(ctx, listInventoryByItem, arg.WorkspaceID, arg.ItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseInventory{}
	for rows.Next() {
		var i WarehouseInventory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ItemID,
			&i.LocationID,
			&i.ContainerID,
			&i.Quantity,
			&i.Condition,
			&i.Status,
			&i.DateAcquired,
			&i.PurchasePrice,
			&i.CurrencyCode,
			&i.WarrantyExpires,
			&i.ExpirationDate,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryByLocation = `-- name: ListInventoryByLocation :many
SELECT id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at FROM warehouse.inventory
WHERE workspace_id = $1 AND location_id = $2 AND is_archived = false
ORDER BY created_at DESC
`

type ListInventoryByLocationParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	LocationID  uuid.UUID `json:"location_id"`
}

func (q *Queries) ListInventoryByLocation(ctx context.Context, arg ListInventoryByLocationParams) ([]WarehouseInventory, error) {
	rows, err := q.db.Query(ctx, listInventoryByLocation, arg.WorkspaceID, arg.LocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseInventory{}
	for rows.Next() {
		var i WarehouseInventory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ItemID,
			&i.LocationID,
			&i.ContainerID,
			&i.Quantity,
			&i.Condition,
			&i.Status,
			&i.DateAcquired,
			&i.PurchasePrice,
			&i.CurrencyCode,
			&i.WarrantyExpires,
			&i.ExpirationDate,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryWithDetails = `-- name: ListInventoryWithDetails :many
SELECT i.id, i.workspace_id, i.item_id, i.location_id, i.container_id, i.quantity, i.condition, i.status, i.date_acquired, i.purchase_price, i.currency_code, i.warranty_expires, i.expiration_date, i.notes, i.is_archived, i.created_at, i.updated_at, it.name as item_name, it.sku, l.name as location_name, c.name as container_name
FROM warehouse.inventory i
JOIN warehouse.items it ON i.item_id = it.id
JOIN warehouse.locations l ON i.location_id = l.id
LEFT JOIN warehouse.containers c ON i.container_id = c.id
WHERE i.workspace_id = $1 AND i.is_archived = false
ORDER BY it.name
LIMIT $2 OFFSET $3
`

type ListInventoryWithDetailsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListInventoryWithDetailsRow struct {
	ID              uuid.UUID                      `json:"id"`
	WorkspaceID     uuid.UUID                      `json:"workspace_id"`
	ItemID          uuid.UUID                      `json:"item_id"`
	LocationID      uuid.UUID                      `json:"location_id"`
	ContainerID     pgtype.UUID                    `json:"container_id"`
	Quantity        int32                          `json:"quantity"`
	Condition       NullWarehouseItemConditionEnum `json:"condition"`
	Status          NullWarehouseItemStatusEnum    `json:"status"`
	DateAcquired    pgtype.Date                    `json:"date_acquired"`
	PurchasePrice   *int32                         `json:"purchase_price"`
	CurrencyCode    *string                        `json:"currency_code"`
	WarrantyExpires pgtype.Date                    `json:"warranty_expires"`
	ExpirationDate  pgtype.Date                    `json:"expiration_date"`
	Notes           *string                        `json:"notes"`
	IsArchived      bool                           `json:"is_archived"`
	CreatedAt       pgtype.Timestamptz             `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz             `json:"updated_at"`
	ItemName        string                         `json:"item_name"`
	Sku             string                         `json:"sku"`
	LocationName    string                         `json:"location_name"`
	ContainerName   *string                        `json:"container_name"`
}

func (q *Queries) ListInventoryWithDetails(ctx context.Context, arg ListInventoryWithDetailsParams) ([]ListInventoryWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listInventoryWithDetails, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInventoryWithDetailsRow{}
	for rows.Next() {
		var i ListInventoryWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ItemID,
			&i.LocationID,
			&i.ContainerID,
			&i.Quantity,
			&i.Condition,
			&i.Status,
			&i.DateAcquired,
			&i.PurchasePrice,
			&i.CurrencyCode,
			&i.WarrantyExpires,
			&i.ExpirationDate,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ItemName,
			&i.Sku,
			&i.LocationName,
			&i.ContainerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveInventory = `-- name: MoveInventory :one
UPDATE warehouse.inventory
SET location_id = $2, container_id = $3, updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at
`

type MoveInventoryParams struct {
	ID          uuid.UUID   `json:"id"`
	LocationID  uuid.UUID   `json:"location_id"`
	ContainerID pgtype.UUID `json:"container_id"`
}

func (q *Queries) MoveInventory(ctx context.Context, arg MoveInventoryParams) (WarehouseInventory, error) {
	row := q.db.QueryRow(ctx, moveInventory, arg.ID, arg.LocationID, arg.ContainerID)
	var i WarehouseInventory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.Quantity,
		&i.Condition,
		&i.Status,
		&i.DateAcquired,
		&i.PurchasePrice,
		&i.CurrencyCode,
		&i.WarrantyExpires,
		&i.ExpirationDate,
		&i.Notes,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const restoreInventory = `-- name: RestoreInventory :exec
UPDATE warehouse.inventory
SET is_archived = false, updated_at = now()
WHERE id = $1
`

func (q *Queries) RestoreInventory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, restoreInventory, id)
	return err
}

const updateInventory = `-- name: UpdateInventory :one
UPDATE warehouse.inventory
SET location_id = $2, container_id = $3, quantity = $4, condition = $5,
    date_acquired = $6, purchase_price = $7, currency_code = $8,
    warranty_expires = $9, expiration_date = $10, notes = $11, updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at
`

type UpdateInventoryParams struct {
	ID              uuid.UUID                      `json:"id"`
	LocationID      uuid.UUID                      `json:"location_id"`
	ContainerID     pgtype.UUID                    `json:"container_id"`
	Quantity        int32                          `json:"quantity"`
	Condition       NullWarehouseItemConditionEnum `json:"condition"`
	DateAcquired    pgtype.Date                    `json:"date_acquired"`
	PurchasePrice   *int32                         `json:"purchase_price"`
	CurrencyCode    *string                        `json:"currency_code"`
	WarrantyExpires pgtype.Date                    `json:"warranty_expires"`
	ExpirationDate  pgtype.Date                    `json:"expiration_date"`
	Notes           *string                        `json:"notes"`
}

func (q *Queries) UpdateInventory(ctx context.Context, arg UpdateInventoryParams) (WarehouseInventory, error) {
	row := q.db.QueryRow(ctx, updateInventory,
		arg.ID,
		arg.LocationID,
		arg.ContainerID,
		arg.Quantity,
		arg.Condition,
		arg.DateAcquired,
		arg.PurchasePrice,
		arg.CurrencyCode,
		arg.WarrantyExpires,
		arg.ExpirationDate,
		arg.Notes,
	)
	var i WarehouseInventory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.Quantity,
		&i.Condition,
		&i.Status,
		&i.DateAcquired,
		&i.PurchasePrice,
		&i.CurrencyCode,
		&i.WarrantyExpires,
		&i.ExpirationDate,
		&i.Notes,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInventoryQuantity = `-- name: UpdateInventoryQuantity :one
UPDATE warehouse.inventory
SET quantity = $2, updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at
`

type UpdateInventoryQuantityParams struct {
	ID       uuid.UUID `json:"id"`
	Quantity int32     `json:"quantity"`
}

func (q *Queries) UpdateInventoryQuantity(ctx context.Context, arg UpdateInventoryQuantityParams) (WarehouseInventory, error) {
	row := q.db.QueryRow(ctx, updateInventoryQuantity, arg.ID, arg.Quantity)
	var i WarehouseInventory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.Quantity,
		&i.Condition,
		&i.Status,
		&i.DateAcquired,
		&i.PurchasePrice,
		&i.CurrencyCode,
		&i.WarrantyExpires,
		&i.ExpirationDate,
		&i.Notes,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInventoryStatus = `-- name: UpdateInventoryStatus :one
UPDATE warehouse.inventory
SET status = $2, updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at
`

type UpdateInventoryStatusParams struct {
	ID     uuid.UUID                   `json:"id"`
	Status NullWarehouseItemStatusEnum `json:"status"`
}

func (q *Queries) UpdateInventoryStatus(ctx context.Context, arg UpdateInventoryStatusParams) (WarehouseInventory, error) {
	row := q.db.QueryRow(ctx, updateInventoryStatus, arg.ID, arg.Status)
	var i WarehouseInventory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.Quantity,
		&i.Condition,
		&i.Status,
		&i.DateAcquired,
		&i.PurchasePrice,
		&i.CurrencyCode,
		&i.WarrantyExpires,
		&i.ExpirationDate,
		&i.Notes,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
