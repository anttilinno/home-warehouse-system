// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync.sql

package queries

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countCategoriesModifiedSince = `-- name: CountCategoriesModifiedSince :one
SELECT COUNT(*)::int FROM warehouse.categories
WHERE workspace_id = $1 AND updated_at > $2
`

type CountCategoriesModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CountCategoriesModifiedSince(ctx context.Context, arg CountCategoriesModifiedSinceParams) (int32, error) {
	row := q.db.QueryRow(ctx, countCategoriesModifiedSince, arg.WorkspaceID, arg.UpdatedAt)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countContainersModifiedSince = `-- name: CountContainersModifiedSince :one
SELECT COUNT(*)::int FROM warehouse.containers
WHERE workspace_id = $1 AND updated_at > $2
`

type CountContainersModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CountContainersModifiedSince(ctx context.Context, arg CountContainersModifiedSinceParams) (int32, error) {
	row := q.db.QueryRow(ctx, countContainersModifiedSince, arg.WorkspaceID, arg.UpdatedAt)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countInventoryModifiedSince = `-- name: CountInventoryModifiedSince :one
SELECT COUNT(*)::int FROM warehouse.inventory
WHERE workspace_id = $1 AND updated_at > $2
`

type CountInventoryModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CountInventoryModifiedSince(ctx context.Context, arg CountInventoryModifiedSinceParams) (int32, error) {
	row := q.db.QueryRow(ctx, countInventoryModifiedSince, arg.WorkspaceID, arg.UpdatedAt)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countItemsModifiedSince = `-- name: CountItemsModifiedSince :one
SELECT COUNT(*)::int FROM warehouse.items
WHERE workspace_id = $1 AND updated_at > $2
`

type CountItemsModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CountItemsModifiedSince(ctx context.Context, arg CountItemsModifiedSinceParams) (int32, error) {
	row := q.db.QueryRow(ctx, countItemsModifiedSince, arg.WorkspaceID, arg.UpdatedAt)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countLabelsModifiedSince = `-- name: CountLabelsModifiedSince :one
SELECT COUNT(*)::int FROM warehouse.labels
WHERE workspace_id = $1 AND updated_at > $2
`

type CountLabelsModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CountLabelsModifiedSince(ctx context.Context, arg CountLabelsModifiedSinceParams) (int32, error) {
	row := q.db.QueryRow(ctx, countLabelsModifiedSince, arg.WorkspaceID, arg.UpdatedAt)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countLocationsModifiedSince = `-- name: CountLocationsModifiedSince :one
SELECT COUNT(*)::int FROM warehouse.locations
WHERE workspace_id = $1 AND updated_at > $2
`

type CountLocationsModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CountLocationsModifiedSince(ctx context.Context, arg CountLocationsModifiedSinceParams) (int32, error) {
	row := q.db.QueryRow(ctx, countLocationsModifiedSince, arg.WorkspaceID, arg.UpdatedAt)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const listBorrowersModifiedSince = `-- name: ListBorrowersModifiedSince :many
SELECT id, workspace_id, name, email, phone, notes, is_archived, created_at, updated_at, search_vector FROM warehouse.borrowers
WHERE workspace_id = $1 
  AND updated_at > $2
ORDER BY updated_at ASC
LIMIT $3
`

type ListBorrowersModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListBorrowersModifiedSince(ctx context.Context, arg ListBorrowersModifiedSinceParams) ([]WarehouseBorrower, error) {
	rows, err := q.db.Query(ctx, listBorrowersModifiedSince, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseBorrower{}
	for rows.Next() {
		var i WarehouseBorrower
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriesModifiedSince = `-- name: ListCategoriesModifiedSince :many
SELECT id, workspace_id, name, parent_category_id, description, is_archived, created_at, updated_at FROM warehouse.categories
WHERE workspace_id = $1 
  AND updated_at > $2
ORDER BY updated_at ASC
LIMIT $3
`

type ListCategoriesModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListCategoriesModifiedSince(ctx context.Context, arg ListCategoriesModifiedSinceParams) ([]WarehouseCategory, error) {
	rows, err := q.db.Query(ctx, listCategoriesModifiedSince, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseCategory{}
	for rows.Next() {
		var i WarehouseCategory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.ParentCategoryID,
			&i.Description,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompaniesModifiedSince = `-- name: ListCompaniesModifiedSince :many
SELECT id, workspace_id, name, website, notes, is_archived, created_at, updated_at FROM warehouse.companies
WHERE workspace_id = $1 
  AND updated_at > $2
ORDER BY updated_at ASC
LIMIT $3
`

type ListCompaniesModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListCompaniesModifiedSince(ctx context.Context, arg ListCompaniesModifiedSinceParams) ([]WarehouseCompany, error) {
	rows, err := q.db.Query(ctx, listCompaniesModifiedSince, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseCompany{}
	for rows.Next() {
		var i WarehouseCompany
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Website,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContainersModifiedSince = `-- name: ListContainersModifiedSince :many
SELECT id, workspace_id, name, location_id, description, capacity, short_code, is_archived, search_vector, created_at, updated_at FROM warehouse.containers
WHERE workspace_id = $1 
  AND updated_at > $2
ORDER BY updated_at ASC
LIMIT $3
`

type ListContainersModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListContainersModifiedSince(ctx context.Context, arg ListContainersModifiedSinceParams) ([]WarehouseContainer, error) {
	rows, err := q.db.Query(ctx, listContainersModifiedSince, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseContainer{}
	for rows.Next() {
		var i WarehouseContainer
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.LocationID,
			&i.Description,
			&i.Capacity,
			&i.ShortCode,
			&i.IsArchived,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedRecordsModifiedSince = `-- name: ListDeletedRecordsModifiedSince :many
SELECT id, workspace_id, entity_type, entity_id, deleted_at, deleted_by FROM warehouse.deleted_records
WHERE workspace_id = $1 
  AND deleted_at > $2
ORDER BY deleted_at ASC
LIMIT $3
`

type ListDeletedRecordsModifiedSinceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	DeletedAt   time.Time `json:"deleted_at"`
	Limit       int32     `json:"limit"`
}

func (q *Queries) ListDeletedRecordsModifiedSince(ctx context.Context, arg ListDeletedRecordsModifiedSinceParams) ([]WarehouseDeletedRecord, error) {
	rows, err := q.db.Query(ctx, listDeletedRecordsModifiedSince, arg.WorkspaceID, arg.DeletedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseDeletedRecord{}
	for rows.Next() {
		var i WarehouseDeletedRecord
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.EntityType,
			&i.EntityID,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryModifiedSince = `-- name: ListInventoryModifiedSince :many
SELECT id, workspace_id, item_id, location_id, container_id, quantity, condition, status, date_acquired, purchase_price, currency_code, warranty_expires, expiration_date, notes, is_archived, created_at, updated_at FROM warehouse.inventory
WHERE workspace_id = $1 
  AND updated_at > $2
ORDER BY updated_at ASC
LIMIT $3
`

type ListInventoryModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListInventoryModifiedSince(ctx context.Context, arg ListInventoryModifiedSinceParams) ([]WarehouseInventory, error) {
	rows, err := q.db.Query(ctx, listInventoryModifiedSince, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseInventory{}
	for rows.Next() {
		var i WarehouseInventory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ItemID,
			&i.LocationID,
			&i.ContainerID,
			&i.Quantity,
			&i.Condition,
			&i.Status,
			&i.DateAcquired,
			&i.PurchasePrice,
			&i.CurrencyCode,
			&i.WarrantyExpires,
			&i.ExpirationDate,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsModifiedSince = `-- name: ListItemsModifiedSince :many

SELECT id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at FROM warehouse.items
WHERE workspace_id = $1 
  AND updated_at > $2
ORDER BY updated_at ASC
LIMIT $3
`

type ListItemsModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Limit       int32              `json:"limit"`
}

// Delta Sync Queries
// These queries support PWA offline synchronization by returning records modified since a given timestamp
func (q *Queries) ListItemsModifiedSince(ctx context.Context, arg ListItemsModifiedSinceParams) ([]WarehouseItem, error) {
	rows, err := q.db.Query(ctx, listItemsModifiedSince, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseItem{}
	for rows.Next() {
		var i WarehouseItem
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Brand,
			&i.Model,
			&i.ImageUrl,
			&i.SerialNumber,
			&i.Manufacturer,
			&i.Barcode,
			&i.IsInsured,
			&i.IsArchived,
			&i.LifetimeWarranty,
			&i.WarrantyDetails,
			&i.PurchasedFrom,
			&i.MinStockLevel,
			&i.ShortCode,
			&i.ObsidianVaultPath,
			&i.ObsidianNotePath,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabelsModifiedSince = `-- name: ListLabelsModifiedSince :many
SELECT id, workspace_id, name, color, description, is_archived, created_at, updated_at FROM warehouse.labels
WHERE workspace_id = $1 
  AND updated_at > $2
ORDER BY updated_at ASC
LIMIT $3
`

type ListLabelsModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListLabelsModifiedSince(ctx context.Context, arg ListLabelsModifiedSinceParams) ([]WarehouseLabel, error) {
	rows, err := q.db.Query(ctx, listLabelsModifiedSince, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLabel{}
	for rows.Next() {
		var i WarehouseLabel
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansModifiedSince = `-- name: ListLoansModifiedSince :many
SELECT id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at FROM warehouse.loans
WHERE workspace_id = $1 
  AND updated_at > $2
ORDER BY updated_at ASC
LIMIT $3
`

type ListLoansModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListLoansModifiedSince(ctx context.Context, arg ListLoansModifiedSinceParams) ([]WarehouseLoan, error) {
	rows, err := q.db.Query(ctx, listLoansModifiedSince, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLoan{}
	for rows.Next() {
		var i WarehouseLoan
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.BorrowerID,
			&i.Quantity,
			&i.LoanedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationsModifiedSince = `-- name: ListLocationsModifiedSince :many
SELECT id, workspace_id, name, parent_location, zone, shelf, bin, description, short_code, is_archived, search_vector, created_at, updated_at FROM warehouse.locations
WHERE workspace_id = $1 
  AND updated_at > $2
ORDER BY updated_at ASC
LIMIT $3
`

type ListLocationsModifiedSinceParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListLocationsModifiedSince(ctx context.Context, arg ListLocationsModifiedSinceParams) ([]WarehouseLocation, error) {
	rows, err := q.db.Query(ctx, listLocationsModifiedSince, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLocation{}
	for rows.Next() {
		var i WarehouseLocation
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.ParentLocation,
			&i.Zone,
			&i.Shelf,
			&i.Bin,
			&i.Description,
			&i.ShortCode,
			&i.IsArchived,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
