// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pending_changes.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPendingChangesByWorkspace = `-- name: CountPendingChangesByWorkspace :one
SELECT COUNT(*) FROM warehouse.pending_changes
WHERE workspace_id = $1 AND status = 'pending'
`

func (q *Queries) CountPendingChangesByWorkspace(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingChangesByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPendingChange = `-- name: CreatePendingChange :one
INSERT INTO warehouse.pending_changes (
    id,
    workspace_id,
    requester_id,
    entity_type,
    entity_id,
    action,
    payload,
    status
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, workspace_id, requester_id, entity_type, entity_id, action, payload, status, reviewed_by, reviewed_at, rejection_reason, created_at, updated_at
`

type CreatePendingChangeParams struct {
	ID          uuid.UUID                        `json:"id"`
	WorkspaceID uuid.UUID                        `json:"workspace_id"`
	RequesterID uuid.UUID                        `json:"requester_id"`
	EntityType  string                           `json:"entity_type"`
	EntityID    pgtype.UUID                      `json:"entity_id"`
	Action      WarehousePendingChangeActionEnum `json:"action"`
	Payload     []byte                           `json:"payload"`
	Status      WarehousePendingChangeStatusEnum `json:"status"`
}

func (q *Queries) CreatePendingChange(ctx context.Context, arg CreatePendingChangeParams) (WarehousePendingChange, error) {
	row := q.db.QueryRow(ctx, createPendingChange,
		arg.ID,
		arg.WorkspaceID,
		arg.RequesterID,
		arg.EntityType,
		arg.EntityID,
		arg.Action,
		arg.Payload,
		arg.Status,
	)
	var i WarehousePendingChange
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.RequesterID,
		&i.EntityType,
		&i.EntityID,
		&i.Action,
		&i.Payload,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePendingChange = `-- name: DeletePendingChange :exec
DELETE FROM warehouse.pending_changes
WHERE id = $1
`

func (q *Queries) DeletePendingChange(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePendingChange, id)
	return err
}

const getPendingChangeByID = `-- name: GetPendingChangeByID :one
SELECT id, workspace_id, requester_id, entity_type, entity_id, action, payload, status, reviewed_by, reviewed_at, rejection_reason, created_at, updated_at FROM warehouse.pending_changes
WHERE id = $1
`

func (q *Queries) GetPendingChangeByID(ctx context.Context, id uuid.UUID) (WarehousePendingChange, error) {
	row := q.db.QueryRow(ctx, getPendingChangeByID, id)
	var i WarehousePendingChange
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.RequesterID,
		&i.EntityType,
		&i.EntityID,
		&i.Action,
		&i.Payload,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPendingChangesByEntity = `-- name: ListPendingChangesByEntity :many
SELECT id, workspace_id, requester_id, entity_type, entity_id, action, payload, status, reviewed_by, reviewed_at, rejection_reason, created_at, updated_at FROM warehouse.pending_changes
WHERE entity_type = $1 AND entity_id = $2
ORDER BY created_at DESC
`

type ListPendingChangesByEntityParams struct {
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.UUID `json:"entity_id"`
}

func (q *Queries) ListPendingChangesByEntity(ctx context.Context, arg ListPendingChangesByEntityParams) ([]WarehousePendingChange, error) {
	rows, err := q.db.Query(ctx, listPendingChangesByEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehousePendingChange{}
	for rows.Next() {
		var i WarehousePendingChange
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.RequesterID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Payload,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingChangesByRequester = `-- name: ListPendingChangesByRequester :many
SELECT id, workspace_id, requester_id, entity_type, entity_id, action, payload, status, reviewed_by, reviewed_at, rejection_reason, created_at, updated_at FROM warehouse.pending_changes
WHERE requester_id = $1
  AND ($2::warehouse.pending_change_status_enum IS NULL OR status = $2)
ORDER BY created_at DESC
`

type ListPendingChangesByRequesterParams struct {
	RequesterID uuid.UUID                            `json:"requester_id"`
	Status      NullWarehousePendingChangeStatusEnum `json:"status"`
}

func (q *Queries) ListPendingChangesByRequester(ctx context.Context, arg ListPendingChangesByRequesterParams) ([]WarehousePendingChange, error) {
	rows, err := q.db.Query(ctx, listPendingChangesByRequester, arg.RequesterID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehousePendingChange{}
	for rows.Next() {
		var i WarehousePendingChange
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.RequesterID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Payload,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingChangesByWorkspace = `-- name: ListPendingChangesByWorkspace :many
SELECT id, workspace_id, requester_id, entity_type, entity_id, action, payload, status, reviewed_by, reviewed_at, rejection_reason, created_at, updated_at FROM warehouse.pending_changes
WHERE workspace_id = $1
  AND ($2::warehouse.pending_change_status_enum IS NULL OR status = $2)
ORDER BY created_at DESC
`

type ListPendingChangesByWorkspaceParams struct {
	WorkspaceID uuid.UUID                            `json:"workspace_id"`
	Status      NullWarehousePendingChangeStatusEnum `json:"status"`
}

func (q *Queries) ListPendingChangesByWorkspace(ctx context.Context, arg ListPendingChangesByWorkspaceParams) ([]WarehousePendingChange, error) {
	rows, err := q.db.Query(ctx, listPendingChangesByWorkspace, arg.WorkspaceID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehousePendingChange{}
	for rows.Next() {
		var i WarehousePendingChange
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.RequesterID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Payload,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePendingChangeStatus = `-- name: UpdatePendingChangeStatus :one
UPDATE warehouse.pending_changes
SET
    status = $2,
    reviewed_by = $3,
    reviewed_at = $4,
    rejection_reason = $5,
    updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, requester_id, entity_type, entity_id, action, payload, status, reviewed_by, reviewed_at, rejection_reason, created_at, updated_at
`

type UpdatePendingChangeStatusParams struct {
	ID              uuid.UUID                        `json:"id"`
	Status          WarehousePendingChangeStatusEnum `json:"status"`
	ReviewedBy      pgtype.UUID                      `json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz               `json:"reviewed_at"`
	RejectionReason *string                          `json:"rejection_reason"`
}

func (q *Queries) UpdatePendingChangeStatus(ctx context.Context, arg UpdatePendingChangeStatusParams) (WarehousePendingChange, error) {
	row := q.db.QueryRow(ctx, updatePendingChangeStatus,
		arg.ID,
		arg.Status,
		arg.ReviewedBy,
		arg.ReviewedAt,
		arg.RejectionReason,
	)
	var i WarehousePendingChange
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.RequesterID,
		&i.EntityType,
		&i.EntityID,
		&i.Action,
		&i.Payload,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
