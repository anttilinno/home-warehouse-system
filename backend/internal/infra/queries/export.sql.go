// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: export.sql

package queries

import (
	"context"

	"github.com/google/uuid"
)

const getCategoryByName = `-- name: GetCategoryByName :one
SELECT id, workspace_id, name, parent_category_id, description, is_archived, created_at, updated_at FROM warehouse.categories
WHERE workspace_id = $1 AND name = $2 AND is_archived = false
LIMIT 1
`

type GetCategoryByNameParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Name        string    `json:"name"`
}

func (q *Queries) GetCategoryByName(ctx context.Context, arg GetCategoryByNameParams) (WarehouseCategory, error) {
	row := q.db.QueryRow(ctx, getCategoryByName, arg.WorkspaceID, arg.Name)
	var i WarehouseCategory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.ParentCategoryID,
		&i.Description,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLocationByName = `-- name: GetLocationByName :one
SELECT id, workspace_id, name, parent_location, zone, shelf, bin, description, short_code, is_archived, search_vector, created_at, updated_at FROM warehouse.locations
WHERE workspace_id = $1 AND name = $2 AND is_archived = false
LIMIT 1
`

type GetLocationByNameParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Name        string    `json:"name"`
}

func (q *Queries) GetLocationByName(ctx context.Context, arg GetLocationByNameParams) (WarehouseLocation, error) {
	row := q.db.QueryRow(ctx, getLocationByName, arg.WorkspaceID, arg.Name)
	var i WarehouseLocation
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.ParentLocation,
		&i.Zone,
		&i.Shelf,
		&i.Bin,
		&i.Description,
		&i.ShortCode,
		&i.IsArchived,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllBorrowers = `-- name: ListAllBorrowers :many
SELECT id, workspace_id, name, email, phone, notes, is_archived, created_at, updated_at, search_vector FROM warehouse.borrowers
WHERE workspace_id = $1 
  AND ($2::boolean OR is_archived = false)
ORDER BY name
`

type ListAllBorrowersParams struct {
	WorkspaceID     uuid.UUID `json:"workspace_id"`
	IncludeArchived bool      `json:"include_archived"`
}

func (q *Queries) ListAllBorrowers(ctx context.Context, arg ListAllBorrowersParams) ([]WarehouseBorrower, error) {
	rows, err := q.db.Query(ctx, listAllBorrowers, arg.WorkspaceID, arg.IncludeArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseBorrower{}
	for rows.Next() {
		var i WarehouseBorrower
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllCategories = `-- name: ListAllCategories :many
SELECT id, workspace_id, name, parent_category_id, description, is_archived, created_at, updated_at FROM warehouse.categories
WHERE workspace_id = $1 
  AND ($2::boolean OR is_archived = false)
ORDER BY name
`

type ListAllCategoriesParams struct {
	WorkspaceID     uuid.UUID `json:"workspace_id"`
	IncludeArchived bool      `json:"include_archived"`
}

func (q *Queries) ListAllCategories(ctx context.Context, arg ListAllCategoriesParams) ([]WarehouseCategory, error) {
	rows, err := q.db.Query(ctx, listAllCategories, arg.WorkspaceID, arg.IncludeArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseCategory{}
	for rows.Next() {
		var i WarehouseCategory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.ParentCategoryID,
			&i.Description,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllCompanies = `-- name: ListAllCompanies :many
SELECT id, workspace_id, name, website, notes, is_archived, created_at, updated_at FROM warehouse.companies
WHERE workspace_id = $1 
  AND ($2::boolean OR is_archived = false)
ORDER BY name
`

type ListAllCompaniesParams struct {
	WorkspaceID     uuid.UUID `json:"workspace_id"`
	IncludeArchived bool      `json:"include_archived"`
}

func (q *Queries) ListAllCompanies(ctx context.Context, arg ListAllCompaniesParams) ([]WarehouseCompany, error) {
	rows, err := q.db.Query(ctx, listAllCompanies, arg.WorkspaceID, arg.IncludeArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseCompany{}
	for rows.Next() {
		var i WarehouseCompany
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Website,
			&i.Notes,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllContainers = `-- name: ListAllContainers :many
SELECT id, workspace_id, name, location_id, description, capacity, short_code, is_archived, search_vector, created_at, updated_at FROM warehouse.containers
WHERE workspace_id = $1 
  AND ($2::boolean OR is_archived = false)
ORDER BY name
`

type ListAllContainersParams struct {
	WorkspaceID     uuid.UUID `json:"workspace_id"`
	IncludeArchived bool      `json:"include_archived"`
}

func (q *Queries) ListAllContainers(ctx context.Context, arg ListAllContainersParams) ([]WarehouseContainer, error) {
	rows, err := q.db.Query(ctx, listAllContainers, arg.WorkspaceID, arg.IncludeArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseContainer{}
	for rows.Next() {
		var i WarehouseContainer
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.LocationID,
			&i.Description,
			&i.Capacity,
			&i.ShortCode,
			&i.IsArchived,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllItems = `-- name: ListAllItems :many

SELECT id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at FROM warehouse.items
WHERE workspace_id = $1 
  AND ($2::boolean OR is_archived = false)
ORDER BY name
`

type ListAllItemsParams struct {
	WorkspaceID     uuid.UUID `json:"workspace_id"`
	IncludeArchived bool      `json:"include_archived"`
}

// Export Queries
// These queries support bulk export operations for all entity types
func (q *Queries) ListAllItems(ctx context.Context, arg ListAllItemsParams) ([]WarehouseItem, error) {
	rows, err := q.db.Query(ctx, listAllItems, arg.WorkspaceID, arg.IncludeArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseItem{}
	for rows.Next() {
		var i WarehouseItem
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Brand,
			&i.Model,
			&i.ImageUrl,
			&i.SerialNumber,
			&i.Manufacturer,
			&i.Barcode,
			&i.IsInsured,
			&i.IsArchived,
			&i.LifetimeWarranty,
			&i.WarrantyDetails,
			&i.PurchasedFrom,
			&i.MinStockLevel,
			&i.ShortCode,
			&i.ObsidianVaultPath,
			&i.ObsidianNotePath,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllLabels = `-- name: ListAllLabels :many
SELECT id, workspace_id, name, color, description, is_archived, created_at, updated_at FROM warehouse.labels
WHERE workspace_id = $1 
  AND ($2::boolean OR is_archived = false)
ORDER BY name
`

type ListAllLabelsParams struct {
	WorkspaceID     uuid.UUID `json:"workspace_id"`
	IncludeArchived bool      `json:"include_archived"`
}

func (q *Queries) ListAllLabels(ctx context.Context, arg ListAllLabelsParams) ([]WarehouseLabel, error) {
	rows, err := q.db.Query(ctx, listAllLabels, arg.WorkspaceID, arg.IncludeArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLabel{}
	for rows.Next() {
		var i WarehouseLabel
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllLocations = `-- name: ListAllLocations :many
SELECT id, workspace_id, name, parent_location, zone, shelf, bin, description, short_code, is_archived, search_vector, created_at, updated_at FROM warehouse.locations
WHERE workspace_id = $1 
  AND ($2::boolean OR is_archived = false)
ORDER BY name
`

type ListAllLocationsParams struct {
	WorkspaceID     uuid.UUID `json:"workspace_id"`
	IncludeArchived bool      `json:"include_archived"`
}

func (q *Queries) ListAllLocations(ctx context.Context, arg ListAllLocationsParams) ([]WarehouseLocation, error) {
	rows, err := q.db.Query(ctx, listAllLocations, arg.WorkspaceID, arg.IncludeArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLocation{}
	for rows.Next() {
		var i WarehouseLocation
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.ParentLocation,
			&i.Zone,
			&i.Shelf,
			&i.Bin,
			&i.Description,
			&i.ShortCode,
			&i.IsArchived,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
