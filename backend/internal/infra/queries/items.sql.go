// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: items.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const archiveItem = `-- name: ArchiveItem :exec
UPDATE warehouse.items
SET is_archived = true, updated_at = now()
WHERE id = $1
`

func (q *Queries) ArchiveItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, archiveItem, id)
	return err
}

const attachLabel = `-- name: AttachLabel :exec
INSERT INTO warehouse.item_labels (item_id, label_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AttachLabelParams struct {
	ItemID  uuid.UUID `json:"item_id"`
	LabelID uuid.UUID `json:"label_id"`
}

func (q *Queries) AttachLabel(ctx context.Context, arg AttachLabelParams) error {
	_, err := q.db.Exec(ctx, attachLabel, arg.ItemID, arg.LabelID)
	return err
}

const createItem = `-- name: CreateItem :one
INSERT INTO warehouse.items (
    id, workspace_id, sku, name, description, category_id, brand, model,
    image_url, serial_number, manufacturer, barcode, is_insured,
    lifetime_warranty, warranty_details, purchased_from, min_stock_level,
    short_code, obsidian_vault_path, obsidian_note_path
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
RETURNING id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at
`

type CreateItemParams struct {
	ID                uuid.UUID   `json:"id"`
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	Sku               string      `json:"sku"`
	Name              string      `json:"name"`
	Description       *string     `json:"description"`
	CategoryID        pgtype.UUID `json:"category_id"`
	Brand             *string     `json:"brand"`
	Model             *string     `json:"model"`
	ImageUrl          *string     `json:"image_url"`
	SerialNumber      *string     `json:"serial_number"`
	Manufacturer      *string     `json:"manufacturer"`
	Barcode           *string     `json:"barcode"`
	IsInsured         *bool       `json:"is_insured"`
	LifetimeWarranty  *bool       `json:"lifetime_warranty"`
	WarrantyDetails   *string     `json:"warranty_details"`
	PurchasedFrom     pgtype.UUID `json:"purchased_from"`
	MinStockLevel     int32       `json:"min_stock_level"`
	ShortCode         *string     `json:"short_code"`
	ObsidianVaultPath *string     `json:"obsidian_vault_path"`
	ObsidianNotePath  *string     `json:"obsidian_note_path"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (WarehouseItem, error) {
	row := q.db.QueryRow(ctx, createItem,
		arg.ID,
		arg.WorkspaceID,
		arg.Sku,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.Brand,
		arg.Model,
		arg.ImageUrl,
		arg.SerialNumber,
		arg.Manufacturer,
		arg.Barcode,
		arg.IsInsured,
		arg.LifetimeWarranty,
		arg.WarrantyDetails,
		arg.PurchasedFrom,
		arg.MinStockLevel,
		arg.ShortCode,
		arg.ObsidianVaultPath,
		arg.ObsidianNotePath,
	)
	var i WarehouseItem
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Brand,
		&i.Model,
		&i.ImageUrl,
		&i.SerialNumber,
		&i.Manufacturer,
		&i.Barcode,
		&i.IsInsured,
		&i.IsArchived,
		&i.LifetimeWarranty,
		&i.WarrantyDetails,
		&i.PurchasedFrom,
		&i.MinStockLevel,
		&i.ShortCode,
		&i.ObsidianVaultPath,
		&i.ObsidianNotePath,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const detachLabel = `-- name: DetachLabel :exec
DELETE FROM warehouse.item_labels
WHERE item_id = $1 AND label_id = $2
`

type DetachLabelParams struct {
	ItemID  uuid.UUID `json:"item_id"`
	LabelID uuid.UUID `json:"label_id"`
}

func (q *Queries) DetachLabel(ctx context.Context, arg DetachLabelParams) error {
	_, err := q.db.Exec(ctx, detachLabel, arg.ItemID, arg.LabelID)
	return err
}

const getItem = `-- name: GetItem :one
SELECT id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at FROM warehouse.items
WHERE id = $1 AND workspace_id = $2
`

type GetItemParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetItem(ctx context.Context, arg GetItemParams) (WarehouseItem, error) {
	row := q.db.QueryRow(ctx, getItem, arg.ID, arg.WorkspaceID)
	var i WarehouseItem
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Brand,
		&i.Model,
		&i.ImageUrl,
		&i.SerialNumber,
		&i.Manufacturer,
		&i.Barcode,
		&i.IsInsured,
		&i.IsArchived,
		&i.LifetimeWarranty,
		&i.WarrantyDetails,
		&i.PurchasedFrom,
		&i.MinStockLevel,
		&i.ShortCode,
		&i.ObsidianVaultPath,
		&i.ObsidianNotePath,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItemByBarcode = `-- name: GetItemByBarcode :one
SELECT id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at FROM warehouse.items
WHERE workspace_id = $1 AND barcode = $2
`

type GetItemByBarcodeParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Barcode     *string   `json:"barcode"`
}

func (q *Queries) GetItemByBarcode(ctx context.Context, arg GetItemByBarcodeParams) (WarehouseItem, error) {
	row := q.db.QueryRow(ctx, getItemByBarcode, arg.WorkspaceID, arg.Barcode)
	var i WarehouseItem
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Brand,
		&i.Model,
		&i.ImageUrl,
		&i.SerialNumber,
		&i.Manufacturer,
		&i.Barcode,
		&i.IsInsured,
		&i.IsArchived,
		&i.LifetimeWarranty,
		&i.WarrantyDetails,
		&i.PurchasedFrom,
		&i.MinStockLevel,
		&i.ShortCode,
		&i.ObsidianVaultPath,
		&i.ObsidianNotePath,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItemBySKU = `-- name: GetItemBySKU :one
SELECT id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at FROM warehouse.items
WHERE workspace_id = $1 AND sku = $2
`

type GetItemBySKUParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Sku         string    `json:"sku"`
}

func (q *Queries) GetItemBySKU(ctx context.Context, arg GetItemBySKUParams) (WarehouseItem, error) {
	row := q.db.QueryRow(ctx, getItemBySKU, arg.WorkspaceID, arg.Sku)
	var i WarehouseItem
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Brand,
		&i.Model,
		&i.ImageUrl,
		&i.SerialNumber,
		&i.Manufacturer,
		&i.Barcode,
		&i.IsInsured,
		&i.IsArchived,
		&i.LifetimeWarranty,
		&i.WarrantyDetails,
		&i.PurchasedFrom,
		&i.MinStockLevel,
		&i.ShortCode,
		&i.ObsidianVaultPath,
		&i.ObsidianNotePath,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItemByShortCode = `-- name: GetItemByShortCode :one
SELECT id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at FROM warehouse.items
WHERE workspace_id = $1 AND short_code = $2
`

type GetItemByShortCodeParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	ShortCode   *string   `json:"short_code"`
}

func (q *Queries) GetItemByShortCode(ctx context.Context, arg GetItemByShortCodeParams) (WarehouseItem, error) {
	row := q.db.QueryRow(ctx, getItemByShortCode, arg.WorkspaceID, arg.ShortCode)
	var i WarehouseItem
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Brand,
		&i.Model,
		&i.ImageUrl,
		&i.SerialNumber,
		&i.Manufacturer,
		&i.Barcode,
		&i.IsInsured,
		&i.IsArchived,
		&i.LifetimeWarranty,
		&i.WarrantyDetails,
		&i.PurchasedFrom,
		&i.MinStockLevel,
		&i.ShortCode,
		&i.ObsidianVaultPath,
		&i.ObsidianNotePath,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItemLabels = `-- name: GetItemLabels :many
SELECT l.id, l.workspace_id, l.name, l.color, l.description, l.is_archived, l.created_at, l.updated_at FROM warehouse.labels l
JOIN warehouse.item_labels il ON l.id = il.label_id
WHERE il.item_id = $1
`

func (q *Queries) GetItemLabels(ctx context.Context, itemID uuid.UUID) ([]WarehouseLabel, error) {
	rows, err := q.db.Query(ctx, getItemLabels, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLabel{}
	for rows.Next() {
		var i WarehouseLabel
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemWithDetails = `-- name: GetItemWithDetails :one
SELECT i.id, i.workspace_id, i.sku, i.name, i.description, i.category_id, i.brand, i.model, i.image_url, i.serial_number, i.manufacturer, i.barcode, i.is_insured, i.is_archived, i.lifetime_warranty, i.warranty_details, i.purchased_from, i.min_stock_level, i.short_code, i.obsidian_vault_path, i.obsidian_note_path, i.search_vector, i.created_at, i.updated_at, c.name as category_name, co.name as company_name
FROM warehouse.items i
LEFT JOIN warehouse.categories c ON i.category_id = c.id
LEFT JOIN warehouse.companies co ON i.purchased_from = co.id
WHERE i.id = $1 AND i.workspace_id = $2
`

type GetItemWithDetailsParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type GetItemWithDetailsRow struct {
	ID                uuid.UUID          `json:"id"`
	WorkspaceID       uuid.UUID          `json:"workspace_id"`
	Sku               string             `json:"sku"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	CategoryID        pgtype.UUID        `json:"category_id"`
	Brand             *string            `json:"brand"`
	Model             *string            `json:"model"`
	ImageUrl          *string            `json:"image_url"`
	SerialNumber      *string            `json:"serial_number"`
	Manufacturer      *string            `json:"manufacturer"`
	Barcode           *string            `json:"barcode"`
	IsInsured         *bool              `json:"is_insured"`
	IsArchived        *bool              `json:"is_archived"`
	LifetimeWarranty  *bool              `json:"lifetime_warranty"`
	WarrantyDetails   *string            `json:"warranty_details"`
	PurchasedFrom     pgtype.UUID        `json:"purchased_from"`
	MinStockLevel     int32              `json:"min_stock_level"`
	ShortCode         *string            `json:"short_code"`
	ObsidianVaultPath *string            `json:"obsidian_vault_path"`
	ObsidianNotePath  *string            `json:"obsidian_note_path"`
	SearchVector      interface{}        `json:"search_vector"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CategoryName      *string            `json:"category_name"`
	CompanyName       *string            `json:"company_name"`
}

func (q *Queries) GetItemWithDetails(ctx context.Context, arg GetItemWithDetailsParams) (GetItemWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getItemWithDetails, arg.ID, arg.WorkspaceID)
	var i GetItemWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Brand,
		&i.Model,
		&i.ImageUrl,
		&i.SerialNumber,
		&i.Manufacturer,
		&i.Barcode,
		&i.IsInsured,
		&i.IsArchived,
		&i.LifetimeWarranty,
		&i.WarrantyDetails,
		&i.PurchasedFrom,
		&i.MinStockLevel,
		&i.ShortCode,
		&i.ObsidianVaultPath,
		&i.ObsidianNotePath,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.CompanyName,
	)
	return i, err
}

const itemSKUExists = `-- name: ItemSKUExists :one
SELECT EXISTS(
    SELECT 1 FROM warehouse.items
    WHERE workspace_id = $1 AND sku = $2
)
`

type ItemSKUExistsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Sku         string    `json:"sku"`
}

func (q *Queries) ItemSKUExists(ctx context.Context, arg ItemSKUExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, itemSKUExists, arg.WorkspaceID, arg.Sku)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const itemShortCodeExists = `-- name: ItemShortCodeExists :one
SELECT EXISTS(
    SELECT 1 FROM warehouse.items
    WHERE workspace_id = $1 AND short_code = $2
)
`

type ItemShortCodeExistsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	ShortCode   *string   `json:"short_code"`
}

func (q *Queries) ItemShortCodeExists(ctx context.Context, arg ItemShortCodeExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, itemShortCodeExists, arg.WorkspaceID, arg.ShortCode)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listItems = `-- name: ListItems :many
SELECT id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at FROM warehouse.items
WHERE workspace_id = $1 AND is_archived = false
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListItemsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListItems(ctx context.Context, arg ListItemsParams) ([]WarehouseItem, error) {
	rows, err := q.db.Query(ctx, listItems, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseItem{}
	for rows.Next() {
		var i WarehouseItem
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Brand,
			&i.Model,
			&i.ImageUrl,
			&i.SerialNumber,
			&i.Manufacturer,
			&i.Barcode,
			&i.IsInsured,
			&i.IsArchived,
			&i.LifetimeWarranty,
			&i.WarrantyDetails,
			&i.PurchasedFrom,
			&i.MinStockLevel,
			&i.ShortCode,
			&i.ObsidianVaultPath,
			&i.ObsidianNotePath,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsByCategory = `-- name: ListItemsByCategory :many
SELECT id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at FROM warehouse.items
WHERE workspace_id = $1 AND category_id = $2 AND is_archived = false
ORDER BY name
LIMIT $3 OFFSET $4
`

type ListItemsByCategoryParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	CategoryID  pgtype.UUID `json:"category_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) ListItemsByCategory(ctx context.Context, arg ListItemsByCategoryParams) ([]WarehouseItem, error) {
	rows, err := q.db.Query(ctx, listItemsByCategory,
		arg.WorkspaceID,
		arg.CategoryID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseItem{}
	for rows.Next() {
		var i WarehouseItem
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Brand,
			&i.Model,
			&i.ImageUrl,
			&i.SerialNumber,
			&i.Manufacturer,
			&i.Barcode,
			&i.IsInsured,
			&i.IsArchived,
			&i.LifetimeWarranty,
			&i.WarrantyDetails,
			&i.PurchasedFrom,
			&i.MinStockLevel,
			&i.ShortCode,
			&i.ObsidianVaultPath,
			&i.ObsidianNotePath,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreItem = `-- name: RestoreItem :exec
UPDATE warehouse.items
SET is_archived = false, updated_at = now()
WHERE id = $1
`

func (q *Queries) RestoreItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, restoreItem, id)
	return err
}

const searchItems = `-- name: SearchItems :many
SELECT id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at FROM warehouse.items
WHERE workspace_id = $1
  AND is_archived = false
  AND search_vector @@ plainto_tsquery('english', $2)
ORDER BY ts_rank(search_vector, plainto_tsquery('english', $2)) DESC
LIMIT $3
`

type SearchItemsParams struct {
	WorkspaceID    uuid.UUID `json:"workspace_id"`
	PlaintoTsquery string    `json:"plainto_tsquery"`
	Limit          int32     `json:"limit"`
}

func (q *Queries) SearchItems(ctx context.Context, arg SearchItemsParams) ([]WarehouseItem, error) {
	rows, err := q.db.Query(ctx, searchItems, arg.WorkspaceID, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseItem{}
	for rows.Next() {
		var i WarehouseItem
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Brand,
			&i.Model,
			&i.ImageUrl,
			&i.SerialNumber,
			&i.Manufacturer,
			&i.Barcode,
			&i.IsInsured,
			&i.IsArchived,
			&i.LifetimeWarranty,
			&i.WarrantyDetails,
			&i.PurchasedFrom,
			&i.MinStockLevel,
			&i.ShortCode,
			&i.ObsidianVaultPath,
			&i.ObsidianNotePath,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateItem = `-- name: UpdateItem :one
UPDATE warehouse.items
SET name = $2, description = $3, category_id = $4, brand = $5, model = $6,
    image_url = $7, serial_number = $8, manufacturer = $9, barcode = $10,
    is_insured = $11, lifetime_warranty = $12, warranty_details = $13,
    purchased_from = $14, min_stock_level = $15, obsidian_vault_path = $16,
    obsidian_note_path = $17, updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, sku, name, description, category_id, brand, model, image_url, serial_number, manufacturer, barcode, is_insured, is_archived, lifetime_warranty, warranty_details, purchased_from, min_stock_level, short_code, obsidian_vault_path, obsidian_note_path, search_vector, created_at, updated_at
`

type UpdateItemParams struct {
	ID                uuid.UUID   `json:"id"`
	Name              string      `json:"name"`
	Description       *string     `json:"description"`
	CategoryID        pgtype.UUID `json:"category_id"`
	Brand             *string     `json:"brand"`
	Model             *string     `json:"model"`
	ImageUrl          *string     `json:"image_url"`
	SerialNumber      *string     `json:"serial_number"`
	Manufacturer      *string     `json:"manufacturer"`
	Barcode           *string     `json:"barcode"`
	IsInsured         *bool       `json:"is_insured"`
	LifetimeWarranty  *bool       `json:"lifetime_warranty"`
	WarrantyDetails   *string     `json:"warranty_details"`
	PurchasedFrom     pgtype.UUID `json:"purchased_from"`
	MinStockLevel     int32       `json:"min_stock_level"`
	ObsidianVaultPath *string     `json:"obsidian_vault_path"`
	ObsidianNotePath  *string     `json:"obsidian_note_path"`
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) (WarehouseItem, error) {
	row := q.db.QueryRow(ctx, updateItem,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.Brand,
		arg.Model,
		arg.ImageUrl,
		arg.SerialNumber,
		arg.Manufacturer,
		arg.Barcode,
		arg.IsInsured,
		arg.LifetimeWarranty,
		arg.WarrantyDetails,
		arg.PurchasedFrom,
		arg.MinStockLevel,
		arg.ObsidianVaultPath,
		arg.ObsidianNotePath,
	)
	var i WarehouseItem
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Brand,
		&i.Model,
		&i.ImageUrl,
		&i.SerialNumber,
		&i.Manufacturer,
		&i.Barcode,
		&i.IsInsured,
		&i.IsArchived,
		&i.LifetimeWarranty,
		&i.WarrantyDetails,
		&i.PurchasedFrom,
		&i.MinStockLevel,
		&i.ShortCode,
		&i.ObsidianVaultPath,
		&i.ObsidianNotePath,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
