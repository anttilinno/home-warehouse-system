// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: favorites.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createFavorite = `-- name: CreateFavorite :one
INSERT INTO warehouse.favorites (id, user_id, workspace_id, favorite_type, item_id, location_id, container_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, workspace_id, favorite_type, item_id, location_id, container_id, created_at
`

type CreateFavoriteParams struct {
	ID           uuid.UUID                 `json:"id"`
	UserID       uuid.UUID                 `json:"user_id"`
	WorkspaceID  uuid.UUID                 `json:"workspace_id"`
	FavoriteType WarehouseFavoriteTypeEnum `json:"favorite_type"`
	ItemID       pgtype.UUID               `json:"item_id"`
	LocationID   pgtype.UUID               `json:"location_id"`
	ContainerID  pgtype.UUID               `json:"container_id"`
}

func (q *Queries) CreateFavorite(ctx context.Context, arg CreateFavoriteParams) (WarehouseFavorite, error) {
	row := q.db.QueryRow(ctx, createFavorite,
		arg.ID,
		arg.UserID,
		arg.WorkspaceID,
		arg.FavoriteType,
		arg.ItemID,
		arg.LocationID,
		arg.ContainerID,
	)
	var i WarehouseFavorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WorkspaceID,
		&i.FavoriteType,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteFavorite = `-- name: DeleteFavorite :exec
DELETE FROM warehouse.favorites WHERE id = $1 AND user_id = $2
`

type DeleteFavoriteParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteFavorite(ctx context.Context, arg DeleteFavoriteParams) error {
	_, err := q.db.Exec(ctx, deleteFavorite, arg.ID, arg.UserID)
	return err
}

const deleteFavoriteByTarget = `-- name: DeleteFavoriteByTarget :exec
DELETE FROM warehouse.favorites
WHERE user_id = $1 AND workspace_id = $2 AND favorite_type = $3
  AND ((favorite_type = 'ITEM' AND item_id = $4)
    OR (favorite_type = 'LOCATION' AND location_id = $4)
    OR (favorite_type = 'CONTAINER' AND container_id = $4))
`

type DeleteFavoriteByTargetParams struct {
	UserID       uuid.UUID                 `json:"user_id"`
	WorkspaceID  uuid.UUID                 `json:"workspace_id"`
	FavoriteType WarehouseFavoriteTypeEnum `json:"favorite_type"`
	ItemID       pgtype.UUID               `json:"item_id"`
}

func (q *Queries) DeleteFavoriteByTarget(ctx context.Context, arg DeleteFavoriteByTargetParams) error {
	_, err := q.db.Exec(ctx, deleteFavoriteByTarget,
		arg.UserID,
		arg.WorkspaceID,
		arg.FavoriteType,
		arg.ItemID,
	)
	return err
}

const getFavorite = `-- name: GetFavorite :one
SELECT id, user_id, workspace_id, favorite_type, item_id, location_id, container_id, created_at FROM warehouse.favorites WHERE id = $1
`

func (q *Queries) GetFavorite(ctx context.Context, id uuid.UUID) (WarehouseFavorite, error) {
	row := q.db.QueryRow(ctx, getFavorite, id)
	var i WarehouseFavorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WorkspaceID,
		&i.FavoriteType,
		&i.ItemID,
		&i.LocationID,
		&i.ContainerID,
		&i.CreatedAt,
	)
	return i, err
}

const getFavoriteItems = `-- name: GetFavoriteItems :many
SELECT f.id as favorite_id, f.created_at as favorited_at, i.id, i.workspace_id, i.sku, i.name, i.description, i.category_id, i.brand, i.model, i.image_url, i.serial_number, i.manufacturer, i.barcode, i.is_insured, i.is_archived, i.lifetime_warranty, i.warranty_details, i.purchased_from, i.min_stock_level, i.short_code, i.obsidian_vault_path, i.obsidian_note_path, i.search_vector, i.created_at, i.updated_at
FROM warehouse.favorites f
JOIN warehouse.items i ON f.item_id = i.id
WHERE f.user_id = $1 AND f.workspace_id = $2 AND f.favorite_type = 'ITEM'
ORDER BY f.created_at DESC
`

type GetFavoriteItemsParams struct {
	UserID      uuid.UUID `json:"user_id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type GetFavoriteItemsRow struct {
	FavoriteID        uuid.UUID          `json:"favorite_id"`
	FavoritedAt       pgtype.Timestamptz `json:"favorited_at"`
	ID                uuid.UUID          `json:"id"`
	WorkspaceID       uuid.UUID          `json:"workspace_id"`
	Sku               string             `json:"sku"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	CategoryID        pgtype.UUID        `json:"category_id"`
	Brand             *string            `json:"brand"`
	Model             *string            `json:"model"`
	ImageUrl          *string            `json:"image_url"`
	SerialNumber      *string            `json:"serial_number"`
	Manufacturer      *string            `json:"manufacturer"`
	Barcode           *string            `json:"barcode"`
	IsInsured         *bool              `json:"is_insured"`
	IsArchived        *bool              `json:"is_archived"`
	LifetimeWarranty  *bool              `json:"lifetime_warranty"`
	WarrantyDetails   *string            `json:"warranty_details"`
	PurchasedFrom     pgtype.UUID        `json:"purchased_from"`
	MinStockLevel     int32              `json:"min_stock_level"`
	ShortCode         string             `json:"short_code"`
	ObsidianVaultPath *string            `json:"obsidian_vault_path"`
	ObsidianNotePath  *string            `json:"obsidian_note_path"`
	SearchVector      interface{}        `json:"search_vector"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetFavoriteItems(ctx context.Context, arg GetFavoriteItemsParams) ([]GetFavoriteItemsRow, error) {
	rows, err := q.db.Query(ctx, getFavoriteItems, arg.UserID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFavoriteItemsRow{}
	for rows.Next() {
		var i GetFavoriteItemsRow
		if err := rows.Scan(
			&i.FavoriteID,
			&i.FavoritedAt,
			&i.ID,
			&i.WorkspaceID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Brand,
			&i.Model,
			&i.ImageUrl,
			&i.SerialNumber,
			&i.Manufacturer,
			&i.Barcode,
			&i.IsInsured,
			&i.IsArchived,
			&i.LifetimeWarranty,
			&i.WarrantyDetails,
			&i.PurchasedFrom,
			&i.MinStockLevel,
			&i.ShortCode,
			&i.ObsidianVaultPath,
			&i.ObsidianNotePath,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isFavorite = `-- name: IsFavorite :one
SELECT EXISTS(
    SELECT 1 FROM warehouse.favorites
    WHERE user_id = $1 AND workspace_id = $2 AND favorite_type = $3
      AND ((favorite_type = 'ITEM' AND item_id = $4)
        OR (favorite_type = 'LOCATION' AND location_id = $4)
        OR (favorite_type = 'CONTAINER' AND container_id = $4))
)
`

type IsFavoriteParams struct {
	UserID       uuid.UUID                 `json:"user_id"`
	WorkspaceID  uuid.UUID                 `json:"workspace_id"`
	FavoriteType WarehouseFavoriteTypeEnum `json:"favorite_type"`
	ItemID       pgtype.UUID               `json:"item_id"`
}

func (q *Queries) IsFavorite(ctx context.Context, arg IsFavoriteParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFavorite,
		arg.UserID,
		arg.WorkspaceID,
		arg.FavoriteType,
		arg.ItemID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listFavoritesByUser = `-- name: ListFavoritesByUser :many
SELECT id, user_id, workspace_id, favorite_type, item_id, location_id, container_id, created_at FROM warehouse.favorites
WHERE user_id = $1 AND workspace_id = $2
ORDER BY created_at DESC
`

type ListFavoritesByUserParams struct {
	UserID      uuid.UUID `json:"user_id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) ListFavoritesByUser(ctx context.Context, arg ListFavoritesByUserParams) ([]WarehouseFavorite, error) {
	rows, err := q.db.Query(ctx, listFavoritesByUser, arg.UserID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseFavorite{}
	for rows.Next() {
		var i WarehouseFavorite
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WorkspaceID,
			&i.FavoriteType,
			&i.ItemID,
			&i.LocationID,
			&i.ContainerID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
