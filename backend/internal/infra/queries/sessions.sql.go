// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package queries

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
)

const countUserSessions = `-- name: CountUserSessions :one
SELECT COUNT(*) FROM auth.user_sessions
WHERE user_id = $1 AND expires_at > now()
`

// Counts active sessions for a user (for session limit enforcement)
func (q *Queries) CountUserSessions(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserSessions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO auth.user_sessions (
    user_id, refresh_token_hash, device_info, ip_address, user_agent, expires_at
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, refresh_token_hash, device_info, ip_address, user_agent, last_active_at, expires_at, created_at
`

type CreateSessionParams struct {
	UserID           uuid.UUID   `json:"user_id"`
	RefreshTokenHash string      `json:"refresh_token_hash"`
	DeviceInfo       *string     `json:"device_info"`
	IpAddress        *netip.Addr `json:"ip_address"`
	UserAgent        *string     `json:"user_agent"`
	ExpiresAt        time.Time   `json:"expires_at"`
}

// Creates a new session record when user logs in
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (AuthUserSession, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.RefreshTokenHash,
		arg.DeviceInfo,
		arg.IpAddress,
		arg.UserAgent,
		arg.ExpiresAt,
	)
	var i AuthUserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshTokenHash,
		&i.DeviceInfo,
		&i.IpAddress,
		&i.UserAgent,
		&i.LastActiveAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllSessionsExceptCurrent = `-- name: DeleteAllSessionsExceptCurrent :exec
DELETE FROM auth.user_sessions
WHERE user_id = $1 AND id != $2
`

type DeleteAllSessionsExceptCurrentParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

// Deletes all sessions except the specified one (for "logout all others")
func (q *Queries) DeleteAllSessionsExceptCurrent(ctx context.Context, arg DeleteAllSessionsExceptCurrentParams) error {
	_, err := q.db.Exec(ctx, deleteAllSessionsExceptCurrent, arg.UserID, arg.ID)
	return err
}

const deleteAllUserSessions = `-- name: DeleteAllUserSessions :exec
DELETE FROM auth.user_sessions WHERE user_id = $1
`

// Deletes all sessions for a user (for password change with revoke option)
func (q *Queries) DeleteAllUserSessions(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllUserSessions, userID)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM auth.user_sessions WHERE expires_at < now()
`

// Cleanup job: removes expired sessions
func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM auth.user_sessions WHERE id = $1 AND user_id = $2
`

type DeleteSessionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

// Deletes a specific session (for individual session revocation)
func (q *Queries) DeleteSession(ctx context.Context, arg DeleteSessionParams) error {
	_, err := q.db.Exec(ctx, deleteSession, arg.ID, arg.UserID)
	return err
}

const getSessionByTokenHash = `-- name: GetSessionByTokenHash :one
SELECT id, user_id, refresh_token_hash, device_info, ip_address, user_agent, last_active_at, expires_at, created_at FROM auth.user_sessions
WHERE refresh_token_hash = $1 AND expires_at > now()
`

// Finds a session by its refresh token hash (for token validation)
func (q *Queries) GetSessionByTokenHash(ctx context.Context, refreshTokenHash string) (AuthUserSession, error) {
	row := q.db.QueryRow(ctx, getSessionByTokenHash, refreshTokenHash)
	var i AuthUserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshTokenHash,
		&i.DeviceInfo,
		&i.IpAddress,
		&i.UserAgent,
		&i.LastActiveAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSessions = `-- name: GetUserSessions :many
SELECT id, user_id, device_info, ip_address, last_active_at, created_at
FROM auth.user_sessions
WHERE user_id = $1 AND expires_at > now()
ORDER BY last_active_at DESC
`

type GetUserSessionsRow struct {
	ID           uuid.UUID   `json:"id"`
	UserID       uuid.UUID   `json:"user_id"`
	DeviceInfo   *string     `json:"device_info"`
	IpAddress    *netip.Addr `json:"ip_address"`
	LastActiveAt time.Time   `json:"last_active_at"`
	CreatedAt    time.Time   `json:"created_at"`
}

// Lists all active sessions for a user (for session management UI)
func (q *Queries) GetUserSessions(ctx context.Context, userID uuid.UUID) ([]GetUserSessionsRow, error) {
	rows, err := q.db.Query(ctx, getUserSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserSessionsRow{}
	for rows.Next() {
		var i GetUserSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceInfo,
			&i.IpAddress,
			&i.LastActiveAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSessionActivity = `-- name: UpdateSessionActivity :exec
UPDATE auth.user_sessions
SET last_active_at = now(), refresh_token_hash = $2
WHERE id = $1
`

type UpdateSessionActivityParams struct {
	ID               uuid.UUID `json:"id"`
	RefreshTokenHash string    `json:"refresh_token_hash"`
}

// Updates session's last_active_at and refresh_token_hash on token refresh
func (q *Queries) UpdateSessionActivity(ctx context.Context, arg UpdateSessionActivityParams) error {
	_, err := q.db.Exec(ctx, updateSessionActivity, arg.ID, arg.RefreshTokenHash)
	return err
}
