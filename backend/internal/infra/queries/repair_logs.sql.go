// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: repair_logs.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeRepairLog = `-- name: CompleteRepairLog :one
UPDATE warehouse.repair_logs
SET
    status = 'COMPLETED',
    completed_at = now(),
    new_condition = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at
`

type CompleteRepairLogParams struct {
	ID           uuid.UUID                      `json:"id"`
	NewCondition NullWarehouseItemConditionEnum `json:"new_condition"`
}

func (q *Queries) CompleteRepairLog(ctx context.Context, arg CompleteRepairLogParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, completeRepairLog, arg.ID, arg.NewCondition)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countRepairLogsByInventory = `-- name: CountRepairLogsByInventory :one
SELECT COUNT(*)::int FROM warehouse.repair_logs
WHERE workspace_id = $1 AND inventory_id = $2
`

type CountRepairLogsByInventoryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	InventoryID uuid.UUID `json:"inventory_id"`
}

func (q *Queries) CountRepairLogsByInventory(ctx context.Context, arg CountRepairLogsByInventoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, countRepairLogsByInventory, arg.WorkspaceID, arg.InventoryID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createRepairLog = `-- name: CreateRepairLog :one
INSERT INTO warehouse.repair_logs (
    id, workspace_id, inventory_id, status, description,
    repair_date, cost, currency_code, service_provider, notes
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at
`

type CreateRepairLogParams struct {
	ID              uuid.UUID                 `json:"id"`
	WorkspaceID     uuid.UUID                 `json:"workspace_id"`
	InventoryID     uuid.UUID                 `json:"inventory_id"`
	Status          WarehouseRepairStatusEnum `json:"status"`
	Description     string                    `json:"description"`
	RepairDate      pgtype.Date               `json:"repair_date"`
	Cost            *int32                    `json:"cost"`
	CurrencyCode    *string                   `json:"currency_code"`
	ServiceProvider *string                   `json:"service_provider"`
	Notes           *string                   `json:"notes"`
}

func (q *Queries) CreateRepairLog(ctx context.Context, arg CreateRepairLogParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, createRepairLog,
		arg.ID,
		arg.WorkspaceID,
		arg.InventoryID,
		arg.Status,
		arg.Description,
		arg.RepairDate,
		arg.Cost,
		arg.CurrencyCode,
		arg.ServiceProvider,
		arg.Notes,
	)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRepairLog = `-- name: DeleteRepairLog :exec
DELETE FROM warehouse.repair_logs
WHERE id = $1
`

func (q *Queries) DeleteRepairLog(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRepairLog, id)
	return err
}

const getRepairLog = `-- name: GetRepairLog :one
SELECT id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at FROM warehouse.repair_logs
WHERE id = $1 AND workspace_id = $2
`

type GetRepairLogParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetRepairLog(ctx context.Context, arg GetRepairLogParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, getRepairLog, arg.ID, arg.WorkspaceID)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRepairLogsByInventory = `-- name: ListRepairLogsByInventory :many
SELECT id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at FROM warehouse.repair_logs
WHERE workspace_id = $1 AND inventory_id = $2
ORDER BY created_at DESC
`

type ListRepairLogsByInventoryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	InventoryID uuid.UUID `json:"inventory_id"`
}

func (q *Queries) ListRepairLogsByInventory(ctx context.Context, arg ListRepairLogsByInventoryParams) ([]WarehouseRepairLog, error) {
	rows, err := q.db.Query(ctx, listRepairLogsByInventory, arg.WorkspaceID, arg.InventoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseRepairLog{}
	for rows.Next() {
		var i WarehouseRepairLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.Status,
			&i.Description,
			&i.RepairDate,
			&i.Cost,
			&i.CurrencyCode,
			&i.ServiceProvider,
			&i.CompletedAt,
			&i.NewCondition,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepairLogsByStatus = `-- name: ListRepairLogsByStatus :many
SELECT id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at FROM warehouse.repair_logs
WHERE workspace_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListRepairLogsByStatusParams struct {
	WorkspaceID uuid.UUID                 `json:"workspace_id"`
	Status      WarehouseRepairStatusEnum `json:"status"`
	Limit       int32                     `json:"limit"`
	Offset      int32                     `json:"offset"`
}

func (q *Queries) ListRepairLogsByStatus(ctx context.Context, arg ListRepairLogsByStatusParams) ([]WarehouseRepairLog, error) {
	rows, err := q.db.Query(ctx, listRepairLogsByStatus,
		arg.WorkspaceID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseRepairLog{}
	for rows.Next() {
		var i WarehouseRepairLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.Status,
			&i.Description,
			&i.RepairDate,
			&i.Cost,
			&i.CurrencyCode,
			&i.ServiceProvider,
			&i.CompletedAt,
			&i.NewCondition,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepairLogsByWorkspace = `-- name: ListRepairLogsByWorkspace :many
SELECT id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at FROM warehouse.repair_logs
WHERE workspace_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRepairLogsByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListRepairLogsByWorkspace(ctx context.Context, arg ListRepairLogsByWorkspaceParams) ([]WarehouseRepairLog, error) {
	rows, err := q.db.Query(ctx, listRepairLogsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseRepairLog{}
	for rows.Next() {
		var i WarehouseRepairLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.Status,
			&i.Description,
			&i.RepairDate,
			&i.Cost,
			&i.CurrencyCode,
			&i.ServiceProvider,
			&i.CompletedAt,
			&i.NewCondition,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRepairLog = `-- name: UpdateRepairLog :one
UPDATE warehouse.repair_logs
SET
    description = $2,
    repair_date = $3,
    cost = $4,
    currency_code = $5,
    service_provider = $6,
    notes = $7,
    updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at
`

type UpdateRepairLogParams struct {
	ID              uuid.UUID   `json:"id"`
	Description     string      `json:"description"`
	RepairDate      pgtype.Date `json:"repair_date"`
	Cost            *int32      `json:"cost"`
	CurrencyCode    *string     `json:"currency_code"`
	ServiceProvider *string     `json:"service_provider"`
	Notes           *string     `json:"notes"`
}

func (q *Queries) UpdateRepairLog(ctx context.Context, arg UpdateRepairLogParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, updateRepairLog,
		arg.ID,
		arg.Description,
		arg.RepairDate,
		arg.Cost,
		arg.CurrencyCode,
		arg.ServiceProvider,
		arg.Notes,
	)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRepairLogStatus = `-- name: UpdateRepairLogStatus :one
UPDATE warehouse.repair_logs
SET status = $2, updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at
`

type UpdateRepairLogStatusParams struct {
	ID     uuid.UUID                 `json:"id"`
	Status WarehouseRepairStatusEnum `json:"status"`
}

func (q *Queries) UpdateRepairLogStatus(ctx context.Context, arg UpdateRepairLogStatusParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, updateRepairLogStatus, arg.ID, arg.Status)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
