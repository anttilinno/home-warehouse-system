// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: repair_logs.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeRepairLog = `-- name: CompleteRepairLog :one
UPDATE warehouse.repair_logs
SET
    status = 'COMPLETED',
    completed_at = now(),
    new_condition = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent
`

type CompleteRepairLogParams struct {
	ID           uuid.UUID                      `json:"id"`
	NewCondition NullWarehouseItemConditionEnum `json:"new_condition"`
}

func (q *Queries) CompleteRepairLog(ctx context.Context, arg CompleteRepairLogParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, completeRepairLog, arg.ID, arg.NewCondition)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsWarrantyClaim,
		&i.ReminderDate,
		&i.ReminderSent,
	)
	return i, err
}

const countRepairLogsByInventory = `-- name: CountRepairLogsByInventory :one
SELECT COUNT(*)::int FROM warehouse.repair_logs
WHERE workspace_id = $1 AND inventory_id = $2
`

type CountRepairLogsByInventoryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	InventoryID uuid.UUID `json:"inventory_id"`
}

func (q *Queries) CountRepairLogsByInventory(ctx context.Context, arg CountRepairLogsByInventoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, countRepairLogsByInventory, arg.WorkspaceID, arg.InventoryID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createRepairLog = `-- name: CreateRepairLog :one
INSERT INTO warehouse.repair_logs (
    id, workspace_id, inventory_id, status, description,
    repair_date, cost, currency_code, service_provider, notes
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent
`

type CreateRepairLogParams struct {
	ID              uuid.UUID                 `json:"id"`
	WorkspaceID     uuid.UUID                 `json:"workspace_id"`
	InventoryID     uuid.UUID                 `json:"inventory_id"`
	Status          WarehouseRepairStatusEnum `json:"status"`
	Description     string                    `json:"description"`
	RepairDate      pgtype.Date               `json:"repair_date"`
	Cost            *int32                    `json:"cost"`
	CurrencyCode    *string                   `json:"currency_code"`
	ServiceProvider *string                   `json:"service_provider"`
	Notes           *string                   `json:"notes"`
}

func (q *Queries) CreateRepairLog(ctx context.Context, arg CreateRepairLogParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, createRepairLog,
		arg.ID,
		arg.WorkspaceID,
		arg.InventoryID,
		arg.Status,
		arg.Description,
		arg.RepairDate,
		arg.Cost,
		arg.CurrencyCode,
		arg.ServiceProvider,
		arg.Notes,
	)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsWarrantyClaim,
		&i.ReminderDate,
		&i.ReminderSent,
	)
	return i, err
}

const createRepairLogWithWarranty = `-- name: CreateRepairLogWithWarranty :one
INSERT INTO warehouse.repair_logs (
    id, workspace_id, inventory_id, status, description,
    repair_date, cost, currency_code, service_provider, notes,
    is_warranty_claim, reminder_date
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent
`

type CreateRepairLogWithWarrantyParams struct {
	ID              uuid.UUID                 `json:"id"`
	WorkspaceID     uuid.UUID                 `json:"workspace_id"`
	InventoryID     uuid.UUID                 `json:"inventory_id"`
	Status          WarehouseRepairStatusEnum `json:"status"`
	Description     string                    `json:"description"`
	RepairDate      pgtype.Date               `json:"repair_date"`
	Cost            *int32                    `json:"cost"`
	CurrencyCode    *string                   `json:"currency_code"`
	ServiceProvider *string                   `json:"service_provider"`
	Notes           *string                   `json:"notes"`
	IsWarrantyClaim bool                      `json:"is_warranty_claim"`
	ReminderDate    pgtype.Date               `json:"reminder_date"`
}

func (q *Queries) CreateRepairLogWithWarranty(ctx context.Context, arg CreateRepairLogWithWarrantyParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, createRepairLogWithWarranty,
		arg.ID,
		arg.WorkspaceID,
		arg.InventoryID,
		arg.Status,
		arg.Description,
		arg.RepairDate,
		arg.Cost,
		arg.CurrencyCode,
		arg.ServiceProvider,
		arg.Notes,
		arg.IsWarrantyClaim,
		arg.ReminderDate,
	)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsWarrantyClaim,
		&i.ReminderDate,
		&i.ReminderSent,
	)
	return i, err
}

const deleteRepairLog = `-- name: DeleteRepairLog :exec
DELETE FROM warehouse.repair_logs
WHERE id = $1
`

func (q *Queries) DeleteRepairLog(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRepairLog, id)
	return err
}

const getRepairLog = `-- name: GetRepairLog :one
SELECT id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent FROM warehouse.repair_logs
WHERE id = $1 AND workspace_id = $2
`

type GetRepairLogParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetRepairLog(ctx context.Context, arg GetRepairLogParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, getRepairLog, arg.ID, arg.WorkspaceID)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsWarrantyClaim,
		&i.ReminderDate,
		&i.ReminderSent,
	)
	return i, err
}

const getTotalRepairCostByInventory = `-- name: GetTotalRepairCostByInventory :many
SELECT
    currency_code,
    COALESCE(SUM(cost), 0)::int AS total_cost_cents,
    COUNT(*)::int AS repair_count
FROM warehouse.repair_logs
WHERE workspace_id = $1
  AND inventory_id = $2
  AND status = 'COMPLETED'
GROUP BY currency_code
`

type GetTotalRepairCostByInventoryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	InventoryID uuid.UUID `json:"inventory_id"`
}

type GetTotalRepairCostByInventoryRow struct {
	CurrencyCode   *string `json:"currency_code"`
	TotalCostCents int32   `json:"total_cost_cents"`
	RepairCount    int32   `json:"repair_count"`
}

func (q *Queries) GetTotalRepairCostByInventory(ctx context.Context, arg GetTotalRepairCostByInventoryParams) ([]GetTotalRepairCostByInventoryRow, error) {
	rows, err := q.db.Query(ctx, getTotalRepairCostByInventory, arg.WorkspaceID, arg.InventoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTotalRepairCostByInventoryRow{}
	for rows.Next() {
		var i GetTotalRepairCostByInventoryRow
		if err := rows.Scan(&i.CurrencyCode, &i.TotalCostCents, &i.RepairCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepairLogsByInventory = `-- name: ListRepairLogsByInventory :many
SELECT id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent FROM warehouse.repair_logs
WHERE workspace_id = $1 AND inventory_id = $2
ORDER BY created_at DESC
`

type ListRepairLogsByInventoryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	InventoryID uuid.UUID `json:"inventory_id"`
}

func (q *Queries) ListRepairLogsByInventory(ctx context.Context, arg ListRepairLogsByInventoryParams) ([]WarehouseRepairLog, error) {
	rows, err := q.db.Query(ctx, listRepairLogsByInventory, arg.WorkspaceID, arg.InventoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseRepairLog{}
	for rows.Next() {
		var i WarehouseRepairLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.Status,
			&i.Description,
			&i.RepairDate,
			&i.Cost,
			&i.CurrencyCode,
			&i.ServiceProvider,
			&i.CompletedAt,
			&i.NewCondition,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsWarrantyClaim,
			&i.ReminderDate,
			&i.ReminderSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepairLogsByStatus = `-- name: ListRepairLogsByStatus :many
SELECT id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent FROM warehouse.repair_logs
WHERE workspace_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListRepairLogsByStatusParams struct {
	WorkspaceID uuid.UUID                 `json:"workspace_id"`
	Status      WarehouseRepairStatusEnum `json:"status"`
	Limit       int32                     `json:"limit"`
	Offset      int32                     `json:"offset"`
}

func (q *Queries) ListRepairLogsByStatus(ctx context.Context, arg ListRepairLogsByStatusParams) ([]WarehouseRepairLog, error) {
	rows, err := q.db.Query(ctx, listRepairLogsByStatus,
		arg.WorkspaceID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseRepairLog{}
	for rows.Next() {
		var i WarehouseRepairLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.Status,
			&i.Description,
			&i.RepairDate,
			&i.Cost,
			&i.CurrencyCode,
			&i.ServiceProvider,
			&i.CompletedAt,
			&i.NewCondition,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsWarrantyClaim,
			&i.ReminderDate,
			&i.ReminderSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepairLogsByWorkspace = `-- name: ListRepairLogsByWorkspace :many
SELECT id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent FROM warehouse.repair_logs
WHERE workspace_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRepairLogsByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListRepairLogsByWorkspace(ctx context.Context, arg ListRepairLogsByWorkspaceParams) ([]WarehouseRepairLog, error) {
	rows, err := q.db.Query(ctx, listRepairLogsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseRepairLog{}
	for rows.Next() {
		var i WarehouseRepairLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.Status,
			&i.Description,
			&i.RepairDate,
			&i.Cost,
			&i.CurrencyCode,
			&i.ServiceProvider,
			&i.CompletedAt,
			&i.NewCondition,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsWarrantyClaim,
			&i.ReminderDate,
			&i.ReminderSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepairsNeedingReminder = `-- name: ListRepairsNeedingReminder :many
SELECT
    rl.id,
    rl.workspace_id,
    rl.inventory_id,
    rl.description,
    rl.reminder_date,
    it.name AS item_name
FROM warehouse.repair_logs rl
JOIN warehouse.inventory inv ON rl.inventory_id = inv.id
JOIN warehouse.items it ON inv.item_id = it.id
WHERE rl.reminder_date <= $1
  AND rl.reminder_sent = false
`

type ListRepairsNeedingReminderRow struct {
	ID           uuid.UUID   `json:"id"`
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	InventoryID  uuid.UUID   `json:"inventory_id"`
	Description  string      `json:"description"`
	ReminderDate pgtype.Date `json:"reminder_date"`
	ItemName     string      `json:"item_name"`
}

func (q *Queries) ListRepairsNeedingReminder(ctx context.Context, reminderDate pgtype.Date) ([]ListRepairsNeedingReminderRow, error) {
	rows, err := q.db.Query(ctx, listRepairsNeedingReminder, reminderDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRepairsNeedingReminderRow{}
	for rows.Next() {
		var i ListRepairsNeedingReminderRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.Description,
			&i.ReminderDate,
			&i.ItemName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markRepairReminderSent = `-- name: MarkRepairReminderSent :exec
UPDATE warehouse.repair_logs
SET reminder_sent = true, updated_at = now()
WHERE id = $1
`

func (q *Queries) MarkRepairReminderSent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markRepairReminderSent, id)
	return err
}

const updateRepairLog = `-- name: UpdateRepairLog :one
UPDATE warehouse.repair_logs
SET
    description = $2,
    repair_date = $3,
    cost = $4,
    currency_code = $5,
    service_provider = $6,
    notes = $7,
    updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent
`

type UpdateRepairLogParams struct {
	ID              uuid.UUID   `json:"id"`
	Description     string      `json:"description"`
	RepairDate      pgtype.Date `json:"repair_date"`
	Cost            *int32      `json:"cost"`
	CurrencyCode    *string     `json:"currency_code"`
	ServiceProvider *string     `json:"service_provider"`
	Notes           *string     `json:"notes"`
}

func (q *Queries) UpdateRepairLog(ctx context.Context, arg UpdateRepairLogParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, updateRepairLog,
		arg.ID,
		arg.Description,
		arg.RepairDate,
		arg.Cost,
		arg.CurrencyCode,
		arg.ServiceProvider,
		arg.Notes,
	)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsWarrantyClaim,
		&i.ReminderDate,
		&i.ReminderSent,
	)
	return i, err
}

const updateRepairLogReminderDate = `-- name: UpdateRepairLogReminderDate :one
UPDATE warehouse.repair_logs
SET reminder_date = $2, reminder_sent = false, updated_at = now()
WHERE id = $1 AND workspace_id = $3
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent
`

type UpdateRepairLogReminderDateParams struct {
	ID           uuid.UUID   `json:"id"`
	ReminderDate pgtype.Date `json:"reminder_date"`
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
}

func (q *Queries) UpdateRepairLogReminderDate(ctx context.Context, arg UpdateRepairLogReminderDateParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, updateRepairLogReminderDate, arg.ID, arg.ReminderDate, arg.WorkspaceID)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsWarrantyClaim,
		&i.ReminderDate,
		&i.ReminderSent,
	)
	return i, err
}

const updateRepairLogStatus = `-- name: UpdateRepairLogStatus :one
UPDATE warehouse.repair_logs
SET status = $2, updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent
`

type UpdateRepairLogStatusParams struct {
	ID     uuid.UUID                 `json:"id"`
	Status WarehouseRepairStatusEnum `json:"status"`
}

func (q *Queries) UpdateRepairLogStatus(ctx context.Context, arg UpdateRepairLogStatusParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, updateRepairLogStatus, arg.ID, arg.Status)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsWarrantyClaim,
		&i.ReminderDate,
		&i.ReminderSent,
	)
	return i, err
}

const updateRepairLogWarrantyClaim = `-- name: UpdateRepairLogWarrantyClaim :one
UPDATE warehouse.repair_logs
SET is_warranty_claim = $2, updated_at = now()
WHERE id = $1 AND workspace_id = $3
RETURNING id, workspace_id, inventory_id, status, description, repair_date, cost, currency_code, service_provider, completed_at, new_condition, notes, created_at, updated_at, is_warranty_claim, reminder_date, reminder_sent
`

type UpdateRepairLogWarrantyClaimParams struct {
	ID              uuid.UUID `json:"id"`
	IsWarrantyClaim bool      `json:"is_warranty_claim"`
	WorkspaceID     uuid.UUID `json:"workspace_id"`
}

func (q *Queries) UpdateRepairLogWarrantyClaim(ctx context.Context, arg UpdateRepairLogWarrantyClaimParams) (WarehouseRepairLog, error) {
	row := q.db.QueryRow(ctx, updateRepairLogWarrantyClaim, arg.ID, arg.IsWarrantyClaim, arg.WorkspaceID)
	var i WarehouseRepairLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.Status,
		&i.Description,
		&i.RepairDate,
		&i.Cost,
		&i.CurrencyCode,
		&i.ServiceProvider,
		&i.CompletedAt,
		&i.NewCondition,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsWarrantyClaim,
		&i.ReminderDate,
		&i.ReminderSent,
	)
	return i, err
}
