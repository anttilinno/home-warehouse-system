// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attachments.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAttachment = `-- name: CreateAttachment :one
INSERT INTO warehouse.attachments (id, item_id, file_id, attachment_type, title, is_primary, docspell_item_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, item_id, file_id, attachment_type, title, is_primary, docspell_item_id, created_at, updated_at
`

type CreateAttachmentParams struct {
	ID             uuid.UUID                   `json:"id"`
	ItemID         uuid.UUID                   `json:"item_id"`
	FileID         pgtype.UUID                 `json:"file_id"`
	AttachmentType WarehouseAttachmentTypeEnum `json:"attachment_type"`
	Title          *string                     `json:"title"`
	IsPrimary      *bool                       `json:"is_primary"`
	DocspellItemID *string                     `json:"docspell_item_id"`
}

func (q *Queries) CreateAttachment(ctx context.Context, arg CreateAttachmentParams) (WarehouseAttachment, error) {
	row := q.db.QueryRow(ctx, createAttachment,
		arg.ID,
		arg.ItemID,
		arg.FileID,
		arg.AttachmentType,
		arg.Title,
		arg.IsPrimary,
		arg.DocspellItemID,
	)
	var i WarehouseAttachment
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.FileID,
		&i.AttachmentType,
		&i.Title,
		&i.IsPrimary,
		&i.DocspellItemID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO warehouse.files (id, workspace_id, original_name, extension, mime_type, size_bytes, checksum, storage_key, uploaded_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, workspace_id, original_name, extension, mime_type, size_bytes, checksum, storage_key, uploaded_by, created_at, updated_at
`

type CreateFileParams struct {
	ID           uuid.UUID   `json:"id"`
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	OriginalName string      `json:"original_name"`
	Extension    *string     `json:"extension"`
	MimeType     *string     `json:"mime_type"`
	SizeBytes    *int64      `json:"size_bytes"`
	Checksum     *string     `json:"checksum"`
	StorageKey   *string     `json:"storage_key"`
	UploadedBy   pgtype.UUID `json:"uploaded_by"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (WarehouseFile, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.ID,
		arg.WorkspaceID,
		arg.OriginalName,
		arg.Extension,
		arg.MimeType,
		arg.SizeBytes,
		arg.Checksum,
		arg.StorageKey,
		arg.UploadedBy,
	)
	var i WarehouseFile
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.OriginalName,
		&i.Extension,
		&i.MimeType,
		&i.SizeBytes,
		&i.Checksum,
		&i.StorageKey,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAttachment = `-- name: DeleteAttachment :exec
DELETE FROM warehouse.attachments WHERE id = $1
`

func (q *Queries) DeleteAttachment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttachment, id)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM warehouse.files WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFile, id)
	return err
}

const getAttachment = `-- name: GetAttachment :one
SELECT id, item_id, file_id, attachment_type, title, is_primary, docspell_item_id, created_at, updated_at FROM warehouse.attachments WHERE id = $1
`

func (q *Queries) GetAttachment(ctx context.Context, id uuid.UUID) (WarehouseAttachment, error) {
	row := q.db.QueryRow(ctx, getAttachment, id)
	var i WarehouseAttachment
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.FileID,
		&i.AttachmentType,
		&i.Title,
		&i.IsPrimary,
		&i.DocspellItemID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFile = `-- name: GetFile :one
SELECT id, workspace_id, original_name, extension, mime_type, size_bytes, checksum, storage_key, uploaded_by, created_at, updated_at FROM warehouse.files WHERE id = $1
`

func (q *Queries) GetFile(ctx context.Context, id uuid.UUID) (WarehouseFile, error) {
	row := q.db.QueryRow(ctx, getFile, id)
	var i WarehouseFile
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.OriginalName,
		&i.Extension,
		&i.MimeType,
		&i.SizeBytes,
		&i.Checksum,
		&i.StorageKey,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAttachmentsByItem = `-- name: ListAttachmentsByItem :many
SELECT a.id, a.item_id, a.file_id, a.attachment_type, a.title, a.is_primary, a.docspell_item_id, a.created_at, a.updated_at, f.original_name, f.mime_type, f.size_bytes
FROM warehouse.attachments a
LEFT JOIN warehouse.files f ON a.file_id = f.id
WHERE a.item_id = $1
ORDER BY a.is_primary DESC, a.created_at
`

type ListAttachmentsByItemRow struct {
	ID             uuid.UUID                   `json:"id"`
	ItemID         uuid.UUID                   `json:"item_id"`
	FileID         pgtype.UUID                 `json:"file_id"`
	AttachmentType WarehouseAttachmentTypeEnum `json:"attachment_type"`
	Title          *string                     `json:"title"`
	IsPrimary      *bool                       `json:"is_primary"`
	DocspellItemID *string                     `json:"docspell_item_id"`
	CreatedAt      pgtype.Timestamptz          `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz          `json:"updated_at"`
	OriginalName   *string                     `json:"original_name"`
	MimeType       *string                     `json:"mime_type"`
	SizeBytes      *int64                      `json:"size_bytes"`
}

func (q *Queries) ListAttachmentsByItem(ctx context.Context, itemID uuid.UUID) ([]ListAttachmentsByItemRow, error) {
	rows, err := q.db.Query(ctx, listAttachmentsByItem, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAttachmentsByItemRow{}
	for rows.Next() {
		var i ListAttachmentsByItemRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.FileID,
			&i.AttachmentType,
			&i.Title,
			&i.IsPrimary,
			&i.DocspellItemID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OriginalName,
			&i.MimeType,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPrimaryAttachment = `-- name: SetPrimaryAttachment :exec
UPDATE warehouse.attachments
SET is_primary = (id = $2)
WHERE item_id = $1
`

type SetPrimaryAttachmentParams struct {
	ItemID uuid.UUID `json:"item_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) SetPrimaryAttachment(ctx context.Context, arg SetPrimaryAttachmentParams) error {
	_, err := q.db.Exec(ctx, setPrimaryAttachment, arg.ItemID, arg.ID)
	return err
}
