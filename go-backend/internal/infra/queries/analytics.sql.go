// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getCategoryStats = `-- name: GetCategoryStats :many
SELECT
    c.id,
    c.name,
    COUNT(DISTINCT i.id)::int as item_count,
    COUNT(inv.id)::int as inventory_count,
    COALESCE(SUM(inv.purchase_price), 0)::int as total_value
FROM warehouse.categories c
LEFT JOIN warehouse.items i ON i.category_id = c.id AND i.is_archived = false
LEFT JOIN warehouse.inventory inv ON inv.item_id = i.id AND inv.is_archived = false
WHERE c.workspace_id = $1 AND c.is_archived = false
GROUP BY c.id, c.name
ORDER BY item_count DESC
LIMIT $2
`

type GetCategoryStatsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
}

type GetCategoryStatsRow struct {
	ID             uuid.UUID `json:"id"`
	Name           string    `json:"name"`
	ItemCount      int32     `json:"item_count"`
	InventoryCount int32     `json:"inventory_count"`
	TotalValue     int32     `json:"total_value"`
}

func (q *Queries) GetCategoryStats(ctx context.Context, arg GetCategoryStatsParams) ([]GetCategoryStatsRow, error) {
	rows, err := q.db.Query(ctx, getCategoryStats, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryStatsRow{}
	for rows.Next() {
		var i GetCategoryStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ItemCount,
			&i.InventoryCount,
			&i.TotalValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardStats = `-- name: GetDashboardStats :one

SELECT
    (SELECT COUNT(*) FROM warehouse.items it WHERE it.workspace_id = $1 AND it.is_archived = false)::int as total_items,
    (SELECT COUNT(*) FROM warehouse.inventory inv WHERE inv.workspace_id = $1 AND inv.is_archived = false)::int as total_inventory,
    (SELECT COUNT(*) FROM warehouse.locations loc WHERE loc.workspace_id = $1 AND loc.is_archived = false)::int as total_locations,
    (SELECT COUNT(*) FROM warehouse.containers con WHERE con.workspace_id = $1 AND con.is_archived = false)::int as total_containers,
    (SELECT COUNT(*) FROM warehouse.loans ln WHERE ln.workspace_id = $1 AND ln.returned_at IS NULL)::int as active_loans,
    (SELECT COUNT(*) FROM warehouse.loans ln2 WHERE ln2.workspace_id = $1 AND ln2.returned_at IS NULL AND ln2.due_date < CURRENT_DATE)::int as overdue_loans,
    (SELECT COUNT(*) FROM (
        SELECT i.id
        FROM warehouse.items i
        LEFT JOIN warehouse.inventory inven ON i.id = inven.item_id AND inven.is_archived = false
        WHERE i.workspace_id = $1 AND i.is_archived = false AND i.min_stock_level > 0
        GROUP BY i.id, i.min_stock_level
        HAVING COALESCE(SUM(inven.quantity), 0) < i.min_stock_level
    ) low_stock)::int as low_stock_items,
    (SELECT COUNT(*) FROM warehouse.categories cat WHERE cat.workspace_id = $1 AND cat.is_archived = false)::int as total_categories,
    (SELECT COUNT(*) FROM warehouse.borrowers bor WHERE bor.workspace_id = $1 AND bor.is_archived = false)::int as total_borrowers
`

type GetDashboardStatsRow struct {
	TotalItems      int32 `json:"total_items"`
	TotalInventory  int32 `json:"total_inventory"`
	TotalLocations  int32 `json:"total_locations"`
	TotalContainers int32 `json:"total_containers"`
	ActiveLoans     int32 `json:"active_loans"`
	OverdueLoans    int32 `json:"overdue_loans"`
	LowStockItems   int32 `json:"low_stock_items"`
	TotalCategories int32 `json:"total_categories"`
	TotalBorrowers  int32 `json:"total_borrowers"`
}

// Analytics Queries
// These queries provide dashboard statistics and analytics for workspaces
func (q *Queries) GetDashboardStats(ctx context.Context, workspaceID uuid.UUID) (GetDashboardStatsRow, error) {
	row := q.db.QueryRow(ctx, getDashboardStats, workspaceID)
	var i GetDashboardStatsRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalInventory,
		&i.TotalLocations,
		&i.TotalContainers,
		&i.ActiveLoans,
		&i.OverdueLoans,
		&i.LowStockItems,
		&i.TotalCategories,
		&i.TotalBorrowers,
	)
	return i, err
}

const getInventoryValueByLocation = `-- name: GetInventoryValueByLocation :many
SELECT
    l.id,
    l.name,
    COUNT(inv.id)::int as item_count,
    COALESCE(SUM(inv.quantity), 0)::int as total_quantity,
    COALESCE(SUM(COALESCE(inv.purchase_price, 0) * inv.quantity), 0)::int as total_value
FROM warehouse.locations l
LEFT JOIN warehouse.inventory inv ON inv.location_id = l.id AND inv.is_archived = false
WHERE l.workspace_id = $1 AND l.is_archived = false
GROUP BY l.id, l.name
ORDER BY total_value DESC
LIMIT $2
`

type GetInventoryValueByLocationParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
}

type GetInventoryValueByLocationRow struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	ItemCount     int32     `json:"item_count"`
	TotalQuantity int32     `json:"total_quantity"`
	TotalValue    int32     `json:"total_value"`
}

func (q *Queries) GetInventoryValueByLocation(ctx context.Context, arg GetInventoryValueByLocationParams) ([]GetInventoryValueByLocationRow, error) {
	rows, err := q.db.Query(ctx, getInventoryValueByLocation, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInventoryValueByLocationRow{}
	for rows.Next() {
		var i GetInventoryValueByLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ItemCount,
			&i.TotalQuantity,
			&i.TotalValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsByCondition = `-- name: GetItemsByCondition :many
SELECT
    inv.condition,
    COUNT(*)::int as count
FROM warehouse.inventory inv
WHERE inv.workspace_id = $1 AND inv.is_archived = false AND inv.condition IS NOT NULL
GROUP BY inv.condition
ORDER BY count DESC
`

type GetItemsByConditionRow struct {
	Condition NullWarehouseItemConditionEnum `json:"condition"`
	Count     int32                          `json:"count"`
}

func (q *Queries) GetItemsByCondition(ctx context.Context, workspaceID uuid.UUID) ([]GetItemsByConditionRow, error) {
	rows, err := q.db.Query(ctx, getItemsByCondition, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetItemsByConditionRow{}
	for rows.Next() {
		var i GetItemsByConditionRow
		if err := rows.Scan(&i.Condition, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsByStatus = `-- name: GetItemsByStatus :many
SELECT
    inv.status,
    COUNT(*)::int as count
FROM warehouse.inventory inv
WHERE inv.workspace_id = $1 AND inv.is_archived = false AND inv.status IS NOT NULL
GROUP BY inv.status
ORDER BY count DESC
`

type GetItemsByStatusRow struct {
	Status NullWarehouseItemStatusEnum `json:"status"`
	Count  int32                       `json:"count"`
}

func (q *Queries) GetItemsByStatus(ctx context.Context, workspaceID uuid.UUID) ([]GetItemsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getItemsByStatus, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetItemsByStatusRow{}
	for rows.Next() {
		var i GetItemsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoanStats = `-- name: GetLoanStats :one
SELECT
    COUNT(*)::int as total_loans,
    COUNT(*) FILTER (WHERE returned_at IS NULL)::int as active_loans,
    COUNT(*) FILTER (WHERE returned_at IS NOT NULL)::int as returned_loans,
    COUNT(*) FILTER (WHERE returned_at IS NULL AND due_date < CURRENT_DATE)::int as overdue_loans
FROM warehouse.loans
WHERE workspace_id = $1
`

type GetLoanStatsRow struct {
	TotalLoans    int32 `json:"total_loans"`
	ActiveLoans   int32 `json:"active_loans"`
	ReturnedLoans int32 `json:"returned_loans"`
	OverdueLoans  int32 `json:"overdue_loans"`
}

func (q *Queries) GetLoanStats(ctx context.Context, workspaceID uuid.UUID) (GetLoanStatsRow, error) {
	row := q.db.QueryRow(ctx, getLoanStats, workspaceID)
	var i GetLoanStatsRow
	err := row.Scan(
		&i.TotalLoans,
		&i.ActiveLoans,
		&i.ReturnedLoans,
		&i.OverdueLoans,
	)
	return i, err
}

const getMonthlyLoanActivity = `-- name: GetMonthlyLoanActivity :many
SELECT
    DATE_TRUNC('month', loaned_at)::date as month,
    COUNT(*)::int as loans_created,
    COUNT(*) FILTER (WHERE returned_at IS NOT NULL)::int as loans_returned
FROM warehouse.loans
WHERE workspace_id = $1
  AND loaned_at >= $2
GROUP BY DATE_TRUNC('month', loaned_at)
ORDER BY month ASC
`

type GetMonthlyLoanActivityParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	LoanedAt    pgtype.Timestamptz `json:"loaned_at"`
}

type GetMonthlyLoanActivityRow struct {
	Month         pgtype.Date `json:"month"`
	LoansCreated  int32       `json:"loans_created"`
	LoansReturned int32       `json:"loans_returned"`
}

func (q *Queries) GetMonthlyLoanActivity(ctx context.Context, arg GetMonthlyLoanActivityParams) ([]GetMonthlyLoanActivityRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyLoanActivity, arg.WorkspaceID, arg.LoanedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMonthlyLoanActivityRow{}
	for rows.Next() {
		var i GetMonthlyLoanActivityRow
		if err := rows.Scan(&i.Month, &i.LoansCreated, &i.LoansReturned); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentActivity = `-- name: GetRecentActivity :many
SELECT
    id,
    workspace_id,
    user_id,
    action,
    entity_type,
    entity_id,
    entity_name,
    changes,
    metadata,
    created_at
FROM warehouse.activity_log
WHERE workspace_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetRecentActivityParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
}

func (q *Queries) GetRecentActivity(ctx context.Context, arg GetRecentActivityParams) ([]WarehouseActivityLog, error) {
	rows, err := q.db.Query(ctx, getRecentActivity, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseActivityLog{}
	for rows.Next() {
		var i WarehouseActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.EntityName,
			&i.Changes,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopBorrowers = `-- name: GetTopBorrowers :many
SELECT
    b.id,
    b.name,
    b.email,
    COUNT(l.id)::int as total_loans,
    COUNT(*) FILTER (WHERE l.returned_at IS NULL)::int as active_loans
FROM warehouse.borrowers b
LEFT JOIN warehouse.loans l ON l.borrower_id = b.id
WHERE b.workspace_id = $1 AND b.is_archived = false
GROUP BY b.id, b.name, b.email
ORDER BY total_loans DESC
LIMIT $2
`

type GetTopBorrowersParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
}

type GetTopBorrowersRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Email       *string   `json:"email"`
	TotalLoans  int32     `json:"total_loans"`
	ActiveLoans int32     `json:"active_loans"`
}

func (q *Queries) GetTopBorrowers(ctx context.Context, arg GetTopBorrowersParams) ([]GetTopBorrowersRow, error) {
	rows, err := q.db.Query(ctx, getTopBorrowers, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopBorrowersRow{}
	for rows.Next() {
		var i GetTopBorrowersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.TotalLoans,
			&i.ActiveLoans,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
