// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movements.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMovement = `-- name: CreateMovement :one
INSERT INTO warehouse.inventory_movements (
    id, workspace_id, inventory_id, from_location_id, from_container_id,
    to_location_id, to_container_id, quantity, moved_by, reason
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, workspace_id, inventory_id, from_location_id, from_container_id, to_location_id, to_container_id, quantity, moved_by, reason, created_at
`

type CreateMovementParams struct {
	ID              uuid.UUID   `json:"id"`
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	InventoryID     uuid.UUID   `json:"inventory_id"`
	FromLocationID  pgtype.UUID `json:"from_location_id"`
	FromContainerID pgtype.UUID `json:"from_container_id"`
	ToLocationID    pgtype.UUID `json:"to_location_id"`
	ToContainerID   pgtype.UUID `json:"to_container_id"`
	Quantity        int32       `json:"quantity"`
	MovedBy         pgtype.UUID `json:"moved_by"`
	Reason          *string     `json:"reason"`
}

func (q *Queries) CreateMovement(ctx context.Context, arg CreateMovementParams) (WarehouseInventoryMovement, error) {
	row := q.db.QueryRow(ctx, createMovement,
		arg.ID,
		arg.WorkspaceID,
		arg.InventoryID,
		arg.FromLocationID,
		arg.FromContainerID,
		arg.ToLocationID,
		arg.ToContainerID,
		arg.Quantity,
		arg.MovedBy,
		arg.Reason,
	)
	var i WarehouseInventoryMovement
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.FromLocationID,
		&i.FromContainerID,
		&i.ToLocationID,
		&i.ToContainerID,
		&i.Quantity,
		&i.MovedBy,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const getMovement = `-- name: GetMovement :one
SELECT id, workspace_id, inventory_id, from_location_id, from_container_id, to_location_id, to_container_id, quantity, moved_by, reason, created_at FROM warehouse.inventory_movements WHERE id = $1 AND workspace_id = $2
`

type GetMovementParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetMovement(ctx context.Context, arg GetMovementParams) (WarehouseInventoryMovement, error) {
	row := q.db.QueryRow(ctx, getMovement, arg.ID, arg.WorkspaceID)
	var i WarehouseInventoryMovement
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.FromLocationID,
		&i.FromContainerID,
		&i.ToLocationID,
		&i.ToContainerID,
		&i.Quantity,
		&i.MovedBy,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const listMovementsByInventory = `-- name: ListMovementsByInventory :many
SELECT m.id, m.workspace_id, m.inventory_id, m.from_location_id, m.from_container_id, m.to_location_id, m.to_container_id, m.quantity, m.moved_by, m.reason, m.created_at,
       fl.name as from_location_name, fc.name as from_container_name,
       tl.name as to_location_name, tc.name as to_container_name,
       u.full_name as moved_by_name
FROM warehouse.inventory_movements m
LEFT JOIN warehouse.locations fl ON m.from_location_id = fl.id
LEFT JOIN warehouse.containers fc ON m.from_container_id = fc.id
LEFT JOIN warehouse.locations tl ON m.to_location_id = tl.id
LEFT JOIN warehouse.containers tc ON m.to_container_id = tc.id
LEFT JOIN auth.users u ON m.moved_by = u.id
WHERE m.inventory_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type ListMovementsByInventoryParams struct {
	InventoryID uuid.UUID `json:"inventory_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListMovementsByInventoryRow struct {
	ID                uuid.UUID          `json:"id"`
	WorkspaceID       uuid.UUID          `json:"workspace_id"`
	InventoryID       uuid.UUID          `json:"inventory_id"`
	FromLocationID    pgtype.UUID        `json:"from_location_id"`
	FromContainerID   pgtype.UUID        `json:"from_container_id"`
	ToLocationID      pgtype.UUID        `json:"to_location_id"`
	ToContainerID     pgtype.UUID        `json:"to_container_id"`
	Quantity          int32              `json:"quantity"`
	MovedBy           pgtype.UUID        `json:"moved_by"`
	Reason            *string            `json:"reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	FromLocationName  *string            `json:"from_location_name"`
	FromContainerName *string            `json:"from_container_name"`
	ToLocationName    *string            `json:"to_location_name"`
	ToContainerName   *string            `json:"to_container_name"`
	MovedByName       *string            `json:"moved_by_name"`
}

func (q *Queries) ListMovementsByInventory(ctx context.Context, arg ListMovementsByInventoryParams) ([]ListMovementsByInventoryRow, error) {
	rows, err := q.db.Query(ctx, listMovementsByInventory, arg.InventoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMovementsByInventoryRow{}
	for rows.Next() {
		var i ListMovementsByInventoryRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.FromLocationID,
			&i.FromContainerID,
			&i.ToLocationID,
			&i.ToContainerID,
			&i.Quantity,
			&i.MovedBy,
			&i.Reason,
			&i.CreatedAt,
			&i.FromLocationName,
			&i.FromContainerName,
			&i.ToLocationName,
			&i.ToContainerName,
			&i.MovedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovementsByLocation = `-- name: ListMovementsByLocation :many
SELECT id, workspace_id, inventory_id, from_location_id, from_container_id, to_location_id, to_container_id, quantity, moved_by, reason, created_at FROM warehouse.inventory_movements
WHERE workspace_id = $1 AND (from_location_id = $2 OR to_location_id = $2)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListMovementsByLocationParams struct {
	WorkspaceID    uuid.UUID   `json:"workspace_id"`
	FromLocationID pgtype.UUID `json:"from_location_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListMovementsByLocation(ctx context.Context, arg ListMovementsByLocationParams) ([]WarehouseInventoryMovement, error) {
	rows, err := q.db.Query(ctx, listMovementsByLocation,
		arg.WorkspaceID,
		arg.FromLocationID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseInventoryMovement{}
	for rows.Next() {
		var i WarehouseInventoryMovement
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.FromLocationID,
			&i.FromContainerID,
			&i.ToLocationID,
			&i.ToContainerID,
			&i.Quantity,
			&i.MovedBy,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovementsByWorkspace = `-- name: ListMovementsByWorkspace :many
SELECT m.id, m.workspace_id, m.inventory_id, m.from_location_id, m.from_container_id, m.to_location_id, m.to_container_id, m.quantity, m.moved_by, m.reason, m.created_at, it.name as item_name
FROM warehouse.inventory_movements m
JOIN warehouse.inventory inv ON m.inventory_id = inv.id
JOIN warehouse.items it ON inv.item_id = it.id
WHERE m.workspace_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type ListMovementsByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListMovementsByWorkspaceRow struct {
	ID              uuid.UUID          `json:"id"`
	WorkspaceID     uuid.UUID          `json:"workspace_id"`
	InventoryID     uuid.UUID          `json:"inventory_id"`
	FromLocationID  pgtype.UUID        `json:"from_location_id"`
	FromContainerID pgtype.UUID        `json:"from_container_id"`
	ToLocationID    pgtype.UUID        `json:"to_location_id"`
	ToContainerID   pgtype.UUID        `json:"to_container_id"`
	Quantity        int32              `json:"quantity"`
	MovedBy         pgtype.UUID        `json:"moved_by"`
	Reason          *string            `json:"reason"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	ItemName        string             `json:"item_name"`
}

func (q *Queries) ListMovementsByWorkspace(ctx context.Context, arg ListMovementsByWorkspaceParams) ([]ListMovementsByWorkspaceRow, error) {
	rows, err := q.db.Query(ctx, listMovementsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMovementsByWorkspaceRow{}
	for rows.Next() {
		var i ListMovementsByWorkspaceRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.FromLocationID,
			&i.FromContainerID,
			&i.ToLocationID,
			&i.ToContainerID,
			&i.Quantity,
			&i.MovedBy,
			&i.Reason,
			&i.CreatedAt,
			&i.ItemName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
