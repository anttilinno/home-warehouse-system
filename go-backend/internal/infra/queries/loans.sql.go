// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: loans.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLoan = `-- name: CreateLoan :one
INSERT INTO warehouse.loans (id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at
`

type CreateLoanParams struct {
	ID          uuid.UUID          `json:"id"`
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	InventoryID uuid.UUID          `json:"inventory_id"`
	BorrowerID  uuid.UUID          `json:"borrower_id"`
	Quantity    int32              `json:"quantity"`
	LoanedAt    pgtype.Timestamptz `json:"loaned_at"`
	DueDate     pgtype.Date        `json:"due_date"`
	Notes       *string            `json:"notes"`
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (WarehouseLoan, error) {
	row := q.db.QueryRow(ctx, createLoan,
		arg.ID,
		arg.WorkspaceID,
		arg.InventoryID,
		arg.BorrowerID,
		arg.Quantity,
		arg.LoanedAt,
		arg.DueDate,
		arg.Notes,
	)
	var i WarehouseLoan
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.BorrowerID,
		&i.Quantity,
		&i.LoanedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const extendLoanDueDate = `-- name: ExtendLoanDueDate :one
UPDATE warehouse.loans
SET due_date = $2, updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at
`

type ExtendLoanDueDateParams struct {
	ID      uuid.UUID   `json:"id"`
	DueDate pgtype.Date `json:"due_date"`
}

func (q *Queries) ExtendLoanDueDate(ctx context.Context, arg ExtendLoanDueDateParams) (WarehouseLoan, error) {
	row := q.db.QueryRow(ctx, extendLoanDueDate, arg.ID, arg.DueDate)
	var i WarehouseLoan
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.BorrowerID,
		&i.Quantity,
		&i.LoanedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveLoanForInventory = `-- name: GetActiveLoanForInventory :one
SELECT id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at FROM warehouse.loans
WHERE inventory_id = $1 AND returned_at IS NULL
`

func (q *Queries) GetActiveLoanForInventory(ctx context.Context, inventoryID uuid.UUID) (WarehouseLoan, error) {
	row := q.db.QueryRow(ctx, getActiveLoanForInventory, inventoryID)
	var i WarehouseLoan
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.BorrowerID,
		&i.Quantity,
		&i.LoanedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLoan = `-- name: GetLoan :one
SELECT id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at FROM warehouse.loans
WHERE id = $1 AND workspace_id = $2
`

type GetLoanParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetLoan(ctx context.Context, arg GetLoanParams) (WarehouseLoan, error) {
	row := q.db.QueryRow(ctx, getLoan, arg.ID, arg.WorkspaceID)
	var i WarehouseLoan
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.BorrowerID,
		&i.Quantity,
		&i.LoanedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLoanWithDetails = `-- name: GetLoanWithDetails :one
SELECT l.id, l.workspace_id, l.inventory_id, l.borrower_id, l.quantity, l.loaned_at, l.due_date, l.returned_at, l.notes, l.created_at, l.updated_at,
       i.quantity as inventory_quantity, i.status as inventory_status,
       it.name as item_name, it.sku,
       b.name as borrower_name, b.email as borrower_email
FROM warehouse.loans l
JOIN warehouse.inventory i ON l.inventory_id = i.id
JOIN warehouse.items it ON i.item_id = it.id
JOIN warehouse.borrowers b ON l.borrower_id = b.id
WHERE l.id = $1 AND l.workspace_id = $2
`

type GetLoanWithDetailsParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type GetLoanWithDetailsRow struct {
	ID                uuid.UUID                   `json:"id"`
	WorkspaceID       uuid.UUID                   `json:"workspace_id"`
	InventoryID       uuid.UUID                   `json:"inventory_id"`
	BorrowerID        uuid.UUID                   `json:"borrower_id"`
	Quantity          int32                       `json:"quantity"`
	LoanedAt          pgtype.Timestamptz          `json:"loaned_at"`
	DueDate           pgtype.Date                 `json:"due_date"`
	ReturnedAt        pgtype.Timestamptz          `json:"returned_at"`
	Notes             *string                     `json:"notes"`
	CreatedAt         pgtype.Timestamptz          `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz          `json:"updated_at"`
	InventoryQuantity int32                       `json:"inventory_quantity"`
	InventoryStatus   NullWarehouseItemStatusEnum `json:"inventory_status"`
	ItemName          string                      `json:"item_name"`
	Sku               string                      `json:"sku"`
	BorrowerName      string                      `json:"borrower_name"`
	BorrowerEmail     *string                     `json:"borrower_email"`
}

func (q *Queries) GetLoanWithDetails(ctx context.Context, arg GetLoanWithDetailsParams) (GetLoanWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getLoanWithDetails, arg.ID, arg.WorkspaceID)
	var i GetLoanWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.BorrowerID,
		&i.Quantity,
		&i.LoanedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InventoryQuantity,
		&i.InventoryStatus,
		&i.ItemName,
		&i.Sku,
		&i.BorrowerName,
		&i.BorrowerEmail,
	)
	return i, err
}

const getTotalLoanedQuantity = `-- name: GetTotalLoanedQuantity :one
SELECT COALESCE(SUM(quantity), 0)::int as total
FROM warehouse.loans
WHERE inventory_id = $1 AND returned_at IS NULL
`

func (q *Queries) GetTotalLoanedQuantity(ctx context.Context, inventoryID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getTotalLoanedQuantity, inventoryID)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const listActiveLoans = `-- name: ListActiveLoans :many
SELECT id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at FROM warehouse.loans
WHERE workspace_id = $1 AND returned_at IS NULL
ORDER BY due_date ASC NULLS LAST
`

func (q *Queries) ListActiveLoans(ctx context.Context, workspaceID uuid.UUID) ([]WarehouseLoan, error) {
	rows, err := q.db.Query(ctx, listActiveLoans, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLoan{}
	for rows.Next() {
		var i WarehouseLoan
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.BorrowerID,
			&i.Quantity,
			&i.LoanedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveLoansWithDetails = `-- name: ListActiveLoansWithDetails :many
SELECT l.id, l.workspace_id, l.inventory_id, l.borrower_id, l.quantity, l.loaned_at, l.due_date, l.returned_at, l.notes, l.created_at, l.updated_at,
       i.quantity as inventory_quantity,
       it.name as item_name, it.sku,
       b.name as borrower_name, b.email as borrower_email,
       loc.name as location_name
FROM warehouse.loans l
JOIN warehouse.inventory i ON l.inventory_id = i.id
JOIN warehouse.items it ON i.item_id = it.id
JOIN warehouse.borrowers b ON l.borrower_id = b.id
JOIN warehouse.locations loc ON i.location_id = loc.id
WHERE l.workspace_id = $1 AND l.returned_at IS NULL
ORDER BY l.due_date ASC NULLS LAST
LIMIT $2 OFFSET $3
`

type ListActiveLoansWithDetailsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListActiveLoansWithDetailsRow struct {
	ID                uuid.UUID          `json:"id"`
	WorkspaceID       uuid.UUID          `json:"workspace_id"`
	InventoryID       uuid.UUID          `json:"inventory_id"`
	BorrowerID        uuid.UUID          `json:"borrower_id"`
	Quantity          int32              `json:"quantity"`
	LoanedAt          pgtype.Timestamptz `json:"loaned_at"`
	DueDate           pgtype.Date        `json:"due_date"`
	ReturnedAt        pgtype.Timestamptz `json:"returned_at"`
	Notes             *string            `json:"notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	InventoryQuantity int32              `json:"inventory_quantity"`
	ItemName          string             `json:"item_name"`
	Sku               string             `json:"sku"`
	BorrowerName      string             `json:"borrower_name"`
	BorrowerEmail     *string            `json:"borrower_email"`
	LocationName      string             `json:"location_name"`
}

func (q *Queries) ListActiveLoansWithDetails(ctx context.Context, arg ListActiveLoansWithDetailsParams) ([]ListActiveLoansWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listActiveLoansWithDetails, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveLoansWithDetailsRow{}
	for rows.Next() {
		var i ListActiveLoansWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.BorrowerID,
			&i.Quantity,
			&i.LoanedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InventoryQuantity,
			&i.ItemName,
			&i.Sku,
			&i.BorrowerName,
			&i.BorrowerEmail,
			&i.LocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByBorrower = `-- name: ListLoansByBorrower :many
SELECT id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at FROM warehouse.loans
WHERE workspace_id = $1 AND borrower_id = $2
ORDER BY loaned_at DESC
LIMIT $3 OFFSET $4
`

type ListLoansByBorrowerParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	BorrowerID  uuid.UUID `json:"borrower_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListLoansByBorrower(ctx context.Context, arg ListLoansByBorrowerParams) ([]WarehouseLoan, error) {
	rows, err := q.db.Query(ctx, listLoansByBorrower,
		arg.WorkspaceID,
		arg.BorrowerID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLoan{}
	for rows.Next() {
		var i WarehouseLoan
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.BorrowerID,
			&i.Quantity,
			&i.LoanedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByInventory = `-- name: ListLoansByInventory :many
SELECT id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at FROM warehouse.loans
WHERE workspace_id = $1 AND inventory_id = $2
ORDER BY loaned_at DESC
`

type ListLoansByInventoryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	InventoryID uuid.UUID `json:"inventory_id"`
}

func (q *Queries) ListLoansByInventory(ctx context.Context, arg ListLoansByInventoryParams) ([]WarehouseLoan, error) {
	rows, err := q.db.Query(ctx, listLoansByInventory, arg.WorkspaceID, arg.InventoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLoan{}
	for rows.Next() {
		var i WarehouseLoan
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.BorrowerID,
			&i.Quantity,
			&i.LoanedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByWorkspace = `-- name: ListLoansByWorkspace :many
SELECT id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at FROM warehouse.loans
WHERE workspace_id = $1
ORDER BY loaned_at DESC
LIMIT $2 OFFSET $3
`

type ListLoansByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListLoansByWorkspace(ctx context.Context, arg ListLoansByWorkspaceParams) ([]WarehouseLoan, error) {
	rows, err := q.db.Query(ctx, listLoansByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLoan{}
	for rows.Next() {
		var i WarehouseLoan
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.BorrowerID,
			&i.Quantity,
			&i.LoanedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansNeedingReminder = `-- name: ListLoansNeedingReminder :many
SELECT l.id, l.workspace_id, l.due_date, l.quantity, l.notes,
       b.id as borrower_id, b.name as borrower_name, b.email as borrower_email,
       it.name as item_name, it.sku
FROM warehouse.loans l
JOIN warehouse.borrowers b ON l.borrower_id = b.id
JOIN warehouse.inventory inv ON l.inventory_id = inv.id
JOIN warehouse.items it ON inv.item_id = it.id
WHERE l.returned_at IS NULL 
  AND l.due_date <= $1 
  AND b.email IS NOT NULL
ORDER BY l.due_date ASC
`

type ListLoansNeedingReminderRow struct {
	ID            uuid.UUID   `json:"id"`
	WorkspaceID   uuid.UUID   `json:"workspace_id"`
	DueDate       pgtype.Date `json:"due_date"`
	Quantity      int32       `json:"quantity"`
	Notes         *string     `json:"notes"`
	BorrowerID    uuid.UUID   `json:"borrower_id"`
	BorrowerName  string      `json:"borrower_name"`
	BorrowerEmail *string     `json:"borrower_email"`
	ItemName      string      `json:"item_name"`
	Sku           string      `json:"sku"`
}

// Lists loans that are due within the specified date and have borrowers with email addresses.
// Used by the background job to send reminder notifications.
func (q *Queries) ListLoansNeedingReminder(ctx context.Context, dueDate pgtype.Date) ([]ListLoansNeedingReminderRow, error) {
	rows, err := q.db.Query(ctx, listLoansNeedingReminder, dueDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLoansNeedingReminderRow{}
	for rows.Next() {
		var i ListLoansNeedingReminderRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.DueDate,
			&i.Quantity,
			&i.Notes,
			&i.BorrowerID,
			&i.BorrowerName,
			&i.BorrowerEmail,
			&i.ItemName,
			&i.Sku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOverdueLoans = `-- name: ListOverdueLoans :many
SELECT id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at FROM warehouse.loans
WHERE workspace_id = $1 AND returned_at IS NULL AND due_date < now()
ORDER BY due_date ASC
`

func (q *Queries) ListOverdueLoans(ctx context.Context, workspaceID uuid.UUID) ([]WarehouseLoan, error) {
	rows, err := q.db.Query(ctx, listOverdueLoans, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseLoan{}
	for rows.Next() {
		var i WarehouseLoan
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InventoryID,
			&i.BorrowerID,
			&i.Quantity,
			&i.LoanedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnLoan = `-- name: ReturnLoan :one
UPDATE warehouse.loans
SET returned_at = now(), updated_at = now()
WHERE id = $1
RETURNING id, workspace_id, inventory_id, borrower_id, quantity, loaned_at, due_date, returned_at, notes, created_at, updated_at
`

func (q *Queries) ReturnLoan(ctx context.Context, id uuid.UUID) (WarehouseLoan, error) {
	row := q.db.QueryRow(ctx, returnLoan, id)
	var i WarehouseLoan
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InventoryID,
		&i.BorrowerID,
		&i.Quantity,
		&i.LoanedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
