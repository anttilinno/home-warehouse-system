// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activity.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldActivity = `-- name: CleanupOldActivity :exec
DELETE FROM warehouse.activity_log
WHERE created_at < $1
`

func (q *Queries) CleanupOldActivity(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, cleanupOldActivity, createdAt)
	return err
}

const createActivityLog = `-- name: CreateActivityLog :one
INSERT INTO warehouse.activity_log (id, workspace_id, user_id, action, entity_type, entity_id, entity_name, changes, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, workspace_id, user_id, action, entity_type, entity_id, entity_name, changes, metadata, created_at
`

type CreateActivityLogParams struct {
	ID          uuid.UUID                   `json:"id"`
	WorkspaceID uuid.UUID                   `json:"workspace_id"`
	UserID      pgtype.UUID                 `json:"user_id"`
	Action      WarehouseActivityActionEnum `json:"action"`
	EntityType  WarehouseActivityEntityEnum `json:"entity_type"`
	EntityID    uuid.UUID                   `json:"entity_id"`
	EntityName  *string                     `json:"entity_name"`
	Changes     []byte                      `json:"changes"`
	Metadata    []byte                      `json:"metadata"`
}

func (q *Queries) CreateActivityLog(ctx context.Context, arg CreateActivityLogParams) (WarehouseActivityLog, error) {
	row := q.db.QueryRow(ctx, createActivityLog,
		arg.ID,
		arg.WorkspaceID,
		arg.UserID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.EntityName,
		arg.Changes,
		arg.Metadata,
	)
	var i WarehouseActivityLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UserID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.EntityName,
		&i.Changes,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listActivityByEntity = `-- name: ListActivityByEntity :many
SELECT a.id, a.workspace_id, a.user_id, a.action, a.entity_type, a.entity_id, a.entity_name, a.changes, a.metadata, a.created_at, u.full_name as user_name
FROM warehouse.activity_log a
LEFT JOIN auth.users u ON a.user_id = u.id
WHERE a.workspace_id = $1 AND a.entity_type = $2 AND a.entity_id = $3
ORDER BY a.created_at DESC
LIMIT $4 OFFSET $5
`

type ListActivityByEntityParams struct {
	WorkspaceID uuid.UUID                   `json:"workspace_id"`
	EntityType  WarehouseActivityEntityEnum `json:"entity_type"`
	EntityID    uuid.UUID                   `json:"entity_id"`
	Limit       int32                       `json:"limit"`
	Offset      int32                       `json:"offset"`
}

type ListActivityByEntityRow struct {
	ID          uuid.UUID                   `json:"id"`
	WorkspaceID uuid.UUID                   `json:"workspace_id"`
	UserID      pgtype.UUID                 `json:"user_id"`
	Action      WarehouseActivityActionEnum `json:"action"`
	EntityType  WarehouseActivityEntityEnum `json:"entity_type"`
	EntityID    uuid.UUID                   `json:"entity_id"`
	EntityName  *string                     `json:"entity_name"`
	Changes     []byte                      `json:"changes"`
	Metadata    []byte                      `json:"metadata"`
	CreatedAt   pgtype.Timestamptz          `json:"created_at"`
	UserName    *string                     `json:"user_name"`
}

func (q *Queries) ListActivityByEntity(ctx context.Context, arg ListActivityByEntityParams) ([]ListActivityByEntityRow, error) {
	rows, err := q.db.Query(ctx, listActivityByEntity,
		arg.WorkspaceID,
		arg.EntityType,
		arg.EntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActivityByEntityRow{}
	for rows.Next() {
		var i ListActivityByEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.EntityName,
			&i.Changes,
			&i.Metadata,
			&i.CreatedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivityByUser = `-- name: ListActivityByUser :many
SELECT a.id, a.workspace_id, a.user_id, a.action, a.entity_type, a.entity_id, a.entity_name, a.changes, a.metadata, a.created_at
FROM warehouse.activity_log a
WHERE a.workspace_id = $1 AND a.user_id = $2
ORDER BY a.created_at DESC
LIMIT $3 OFFSET $4
`

type ListActivityByUserParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	UserID      pgtype.UUID `json:"user_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) ListActivityByUser(ctx context.Context, arg ListActivityByUserParams) ([]WarehouseActivityLog, error) {
	rows, err := q.db.Query(ctx, listActivityByUser,
		arg.WorkspaceID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WarehouseActivityLog{}
	for rows.Next() {
		var i WarehouseActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.EntityName,
			&i.Changes,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivityByWorkspace = `-- name: ListActivityByWorkspace :many
SELECT a.id, a.workspace_id, a.user_id, a.action, a.entity_type, a.entity_id, a.entity_name, a.changes, a.metadata, a.created_at, u.full_name as user_name
FROM warehouse.activity_log a
LEFT JOIN auth.users u ON a.user_id = u.id
WHERE a.workspace_id = $1
ORDER BY a.created_at DESC
LIMIT $2 OFFSET $3
`

type ListActivityByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListActivityByWorkspaceRow struct {
	ID          uuid.UUID                   `json:"id"`
	WorkspaceID uuid.UUID                   `json:"workspace_id"`
	UserID      pgtype.UUID                 `json:"user_id"`
	Action      WarehouseActivityActionEnum `json:"action"`
	EntityType  WarehouseActivityEntityEnum `json:"entity_type"`
	EntityID    uuid.UUID                   `json:"entity_id"`
	EntityName  *string                     `json:"entity_name"`
	Changes     []byte                      `json:"changes"`
	Metadata    []byte                      `json:"metadata"`
	CreatedAt   pgtype.Timestamptz          `json:"created_at"`
	UserName    *string                     `json:"user_name"`
}

func (q *Queries) ListActivityByWorkspace(ctx context.Context, arg ListActivityByWorkspaceParams) ([]ListActivityByWorkspaceRow, error) {
	rows, err := q.db.Query(ctx, listActivityByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActivityByWorkspaceRow{}
	for rows.Next() {
		var i ListActivityByWorkspaceRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.EntityName,
			&i.Changes,
			&i.Metadata,
			&i.CreatedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentActivity = `-- name: ListRecentActivity :many
SELECT a.id, a.workspace_id, a.user_id, a.action, a.entity_type, a.entity_id, a.entity_name, a.changes, a.metadata, a.created_at, u.full_name as user_name
FROM warehouse.activity_log a
LEFT JOIN auth.users u ON a.user_id = u.id
WHERE a.workspace_id = $1 AND a.created_at > $2
ORDER BY a.created_at DESC
`

type ListRecentActivityParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type ListRecentActivityRow struct {
	ID          uuid.UUID                   `json:"id"`
	WorkspaceID uuid.UUID                   `json:"workspace_id"`
	UserID      pgtype.UUID                 `json:"user_id"`
	Action      WarehouseActivityActionEnum `json:"action"`
	EntityType  WarehouseActivityEntityEnum `json:"entity_type"`
	EntityID    uuid.UUID                   `json:"entity_id"`
	EntityName  *string                     `json:"entity_name"`
	Changes     []byte                      `json:"changes"`
	Metadata    []byte                      `json:"metadata"`
	CreatedAt   pgtype.Timestamptz          `json:"created_at"`
	UserName    *string                     `json:"user_name"`
}

func (q *Queries) ListRecentActivity(ctx context.Context, arg ListRecentActivityParams) ([]ListRecentActivityRow, error) {
	rows, err := q.db.Query(ctx, listRecentActivity, arg.WorkspaceID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentActivityRow{}
	for rows.Next() {
		var i ListRecentActivityRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.EntityName,
			&i.Changes,
			&i.Metadata,
			&i.CreatedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
